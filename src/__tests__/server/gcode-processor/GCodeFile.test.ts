/* eslint-disable no-console */
/**
 * @file GCodeFile.test.ts
 * @description
 *
 * @author Tom Glastonbury <t@tg73.net>
 * @license MIT
 * @copyright 2024
 *
 * THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
 * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

import { describe, test, expect } from 'vitest';
import { GCodeFlavour } from '@/server/gcode-processor/GCodeInfo';
import semver, { SemVer } from 'semver';
import path from 'path';
import { GCodeFile } from '@/server/gcode-processor/GCodeFile';

describe('tryParseHeader', async () => {
	test('PrusaSlicer 2.8.0', () => {
		const header = '; generated by PrusaSlicer 2.8.0+win64 on 2024-09-06 at 08:32:07 UTC\n\n';
		const parsed = GCodeFile.tryParseHeader(header);

		expect(parsed).not.toBeNull();
		expect(parsed!.flavour).toEqual(GCodeFlavour.PrusaSlicer);
		expect(parsed!.generator).toEqual('PrusaSlicer');
		expect(parsed!.generatorTimestamp).toEqual(new Date('2024-09-06 08:32:07 UTC'));
		expect(parsed!.generatorVersion).toEqual(semver.coerce('2.8.0+win64'));
		expect(parsed!.ratosDialectVersion).toBeUndefined();
		expect(parsed!.processedByRatOSVersion).toBeUndefined();
		expect(parsed!.processedByRatOSTimestamp).toBeUndefined();
	});

	test('SuperSlicer 2.5.59.13', async () => {
		const header = '; generated by SuperSlicer 2.5.59.13 on 2024-09-14 at 09:35:09 UTC\n\n';
		const parsed = GCodeFile.tryParseHeader(header);

		expect(parsed).not.toBeNull();
		expect(parsed!.flavour).toEqual(GCodeFlavour.SuperSlicer);
		expect(parsed!.generator).toEqual('SuperSlicer');
		expect(parsed!.generatorTimestamp).toEqual(new Date('2024-09-14 09:35:09 UTC'));
		expect(parsed!.generatorVersion).toEqual(semver.coerce('2.5.59.13'));
		expect(parsed!.ratosDialectVersion).toBeUndefined();
		expect(parsed!.processedByRatOSVersion).toBeUndefined();
		expect(parsed!.processedByRatOSTimestamp).toBeUndefined();
	});

	test('OrcaSlicer 2.1.1', async () => {
		const header =
			'; HEADER_BLOCK_START\n' +
			'; generated by OrcaSlicer 2.1.1 on 2024-09-12 at 14:57:24\n' +
			'; total layer number: 240';

		const parsed = GCodeFile.tryParseHeader(header);

		expect(parsed).not.toBeNull();
		expect(parsed!.flavour).toEqual(GCodeFlavour.OrcaSlicer);
		expect(parsed!.generator).toEqual('OrcaSlicer');
		expect(parsed!.generatorTimestamp).toEqual(new Date('2024-09-12 14:57:24'));
		expect(parsed!.generatorVersion).toEqual(semver.coerce('2.1.1'));
		expect(parsed!.ratosDialectVersion).toBeUndefined();
		expect(parsed!.processedByRatOSVersion).toBeUndefined();
		expect(parsed!.processedByRatOSTimestamp).toBeUndefined();
	});

	test('CustomGenerator in RatOS dialect', async () => {
		const header = '; generated by CustomGenerator 0.1-alpha in RatOS dialect 0.1 on 2025-01-01 at 08:32:07 UTC\n\n';
		const parsed = GCodeFile.tryParseHeader(header);

		expect(parsed).not.toBeNull();
		expect(parsed!.flavour).toEqual(GCodeFlavour.RatOS);
		expect(parsed!.generator).toEqual('CustomGenerator');
		expect(parsed!.generatorTimestamp).toEqual(new Date('2025-01-01 08:32:07 UTC'));
		expect(parsed!.generatorVersion).toEqual(semver.coerce('0.1-alpha'));
		expect(parsed!.ratosDialectVersion).toEqual(semver.coerce('0.1'));
		expect(parsed!.processedByRatOSVersion).toBeUndefined();
		expect(parsed!.processedByRatOSTimestamp).toBeUndefined();
	});

	test('CustomGenerator without RatOS dialect', async () => {
		const header = '; generated by CustomGenerator 0.1-alpha on 2025-01-01 at 08:32:07 UTC\n\n';
		const parsed = GCodeFile.tryParseHeader(header);

		expect(parsed).not.toBeNull();
		expect(parsed!.flavour).toEqual(GCodeFlavour.Unknown);
		expect(parsed!.generator).toEqual('CustomGenerator');
		expect(parsed!.generatorTimestamp).toEqual(new Date('2025-01-01 08:32:07 UTC'));
		expect(parsed!.generatorVersion).toEqual(semver.coerce('0.1-alpha'));
		expect(parsed!.ratosDialectVersion).toBeUndefined();
		expect(parsed!.processedByRatOSVersion).toBeUndefined();
		expect(parsed!.processedByRatOSTimestamp).toBeUndefined();
	});

	test('already processed v1', async () => {
		const header =
			'; generated by PrusaSlicer 2.8.0+win64 on 2024-09-06 at 08:32:07 UTC\n' +
			'; processed by RatOS 2.0.2-518-g4ffef464 on 2025-01-01 at 08:30:00Z\n';
		const parsed = GCodeFile.tryParseHeader(header);

		expect(parsed).not.toBeNull();
		expect(parsed!.flavour).toEqual(GCodeFlavour.PrusaSlicer);
		expect(parsed!.generator).toEqual('PrusaSlicer');
		expect(parsed!.generatorTimestamp).toEqual(new Date('2024-09-06 08:32:07 UTC'));
		expect(parsed!.generatorVersion).toEqual(semver.coerce('2.8.0+win64'));
		expect(parsed!.ratosDialectVersion).toBeUndefined();
		expect(parsed!.processedByRatOSVersion).toEqual(semver.coerce('2.0.2-518-g4ffef464'));
		expect(parsed!.processedByRatOSTimestamp).toEqual(new Date('2025-01-01 08:30:00Z'));
	});

	test('no match', async () => {
		let parsed = GCodeFile.tryParseHeader('blah blah blah');
		expect(parsed).toBeNull();
	});

	test('getProcessedByRatosHeader', async () => {
		const header = GCodeFile.getProcessedByRatosHeader(new SemVer('1.2.3'), new Date(0xbadbabe), 0xdecafbad);
		expect(header).toEqual('; processed by RatOS 1.2.3 on 1970-01-03 at 06:25:34 UTC v:2 m:decafbad');
	});
});

describe('fromFile', async () => {
	test('unprocessed', async () => {
		const gcf = await GCodeFile.inspect(
			path.join(__dirname, 'fixtures', 'slicer_output', '001', 'SS_IDEX_MultiColor_WipeTower.gcode'),
			{},
		);
		const parsed = gcf.info;
		expect(parsed).not.toBeNull();
		expect(parsed!.flavour).toEqual(GCodeFlavour.SuperSlicer);
		expect(parsed!.generator).toEqual('SuperSlicer');
		expect(parsed!.generatorTimestamp).toEqual(new Date('2024-10-31T03:29:37.000Z'));
		expect(parsed!.generatorVersion).toEqual(semver.coerce('2.5.60'));
		expect(parsed!.ratosDialectVersion).toBeUndefined();
		expect(parsed!.processedByRatOSVersion).toBeUndefined();
		expect(parsed!.processedByRatOSTimestamp).toBeUndefined();
	});

	test('legacy processed', async () => {
		const gcf = await GCodeFile.inspect(path.join(__dirname, 'fixtures', 'other', 'legacy_processed.gcode'), {});
		const parsed = gcf.info;
		expect(parsed).not.toBeNull();
		expect(parsed!.flavour).toEqual(GCodeFlavour.SuperSlicer);
		expect(parsed!.generator).toEqual('SuperSlicer');
		expect(parsed!.generatorTimestamp).toEqual(new Date('2024-10-31T03:29:37.000Z'));
		expect(parsed!.generatorVersion).toEqual(semver.coerce('2.5.60'));
		expect(parsed!.ratosDialectVersion).toBeUndefined();
		expect(parsed!.processedByRatOSVersion).toEqual(new SemVer('1.0.0-legacy'));
		expect(parsed!.processedByRatOSTimestamp).toBeUndefined();
	});

	test('v2 without ratos_meta block', async () => {
		const warnings: string[] = [];
		const gcf = await GCodeFile.inspect(path.join(__dirname, 'fixtures', 'other', 'without_ratos_meta.gcode'), {
			onWarning: (c, m) => {
				const msg = `${c}: ${m}`;
				warnings.push(msg);
				//console.log(msg);
			},
		});
		const parsed = gcf.info;
		expect(parsed).not.toBeNull();
		expect(parsed!.processedByRatOSVersion).not.toBeUndefined();
		expect(parsed!.processedByRatOSTimestamp).not.toBeUndefined();
		expect(warnings).toHaveLength(1);
		expect(warnings[0]).toEqual('INVALID_METADATA: The ratos_meta block was not found.');
	});

	test('v2 without ratos_meta begin', async () => {
		const warnings: string[] = [];
		const gcf = await GCodeFile.inspect(path.join(__dirname, 'fixtures', 'other', 'without_ratos_meta_begin.gcode'), {
			onWarning: (c, m) => {
				const msg = `${c}: ${m}`;
				warnings.push(msg);
				//console.log(msg);
			},
		});
		const parsed = gcf.info;
		expect(parsed).not.toBeNull();
		expect(parsed!.processedByRatOSVersion).not.toBeUndefined();
		expect(parsed!.processedByRatOSTimestamp).not.toBeUndefined();
		expect(warnings).toHaveLength(1);
		expect(warnings[0]).toEqual('INVALID_METADATA: Failed to parse ratos_meta block: the begin marker was not found.');
	});

	test('v2 wrong ratos_meta data length', async () => {
		const warnings: string[] = [];
		const gcf = await GCodeFile.inspect(
			path.join(__dirname, 'fixtures', 'other', 'ratos_meta_wrong_data_length.gcode'),
			{
				onWarning: (c, m) => {
					const msg = `${c}: ${m}`;
					warnings.push(msg);
					//console.log(msg);
				},
			},
		);
		const parsed = gcf.info;
		expect(parsed).not.toBeNull();
		expect(parsed!.processedByRatOSVersion).not.toBeUndefined();
		expect(parsed!.processedByRatOSTimestamp).not.toBeUndefined();
		expect(warnings).toHaveLength(1);
		expect(warnings[0]).toEqual(
			'INVALID_METADATA: Failed to parse ratos_meta block: expected 999 base64 characters, but found 34.',
		);
	});
});
