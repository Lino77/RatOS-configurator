(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5136],{40300:function(e,t,r){"use strict";r.d(t,{addImpl:function(){return a},bincountImpl:function(){return bincountImpl},bincountReduceImpl:function(){return bincountReduceImpl},bitwiseAndImpl:function(){return o},castImpl:function(){return castImpl},ceilImpl:function(){return s},concatImpl:function(){return concatImpl},equalImpl:function(){return u},expImpl:function(){return l},expm1Impl:function(){return d},floorDivImpl:function(){return c},floorImpl:function(){return h},gatherNdImpl:function(){return gatherNdImpl},gatherV2Impl:function(){return gatherV2Impl},greaterEqualImpl:function(){return f},greaterImpl:function(){return p},lessEqualImpl:function(){return g},lessImpl:function(){return m},linSpaceImpl:function(){return linSpaceImpl},logImpl:function(){return y},maxImpl:function(){return maxImpl},maximumImpl:function(){return x},minimumImpl:function(){return b},multiplyImpl:function(){return v},negImpl:function(){return negImpl},notEqualImpl:function(){return C},prodImpl:function(){return prodImpl},raggedGatherImpl:function(){return raggedGatherImpl},raggedRangeImpl:function(){return raggedRangeImpl},raggedTensorToTensorImpl:function(){return raggedTensorToTensorImpl},rangeImpl:function(){return rangeImpl},rsqrtImpl:function(){return I},scatterImpl:function(){return scatterImpl},sigmoidImpl:function(){return k},simpleAbsImpl:function(){return simpleAbsImpl},sliceImpl:function(){return sliceImpl},sparseFillEmptyRowsImpl:function(){return sparseFillEmptyRowsImpl},sparseReshapeImpl:function(){return sparseReshapeImpl},sparseSegmentReductionImpl:function(){return sparseSegmentReductionImpl},sqrtImpl:function(){return R},staticRegexReplaceImpl:function(){return $},stridedSliceImpl:function(){return stridedSliceImpl},stringNGramsImpl:function(){return stringNGramsImpl},stringSplitImpl:function(){return stringSplitImpl},stringToHashBucketFastImpl:function(){return stringToHashBucketFastImpl},subImpl:function(){return T},tileImpl:function(){return tileImpl},topKImpl:function(){return topKImpl},transposeImpl:function(){return transposeImpl},uniqueImpl:function(){return uniqueImpl}});var n=r(82783);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function assertNotComplex(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&n.D5U.assert("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function simpleAbsImpl(e){let t=new Float32Array(e.length);for(let r=0;r<e.length;++r)t[r]=Math.abs(e[r]);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function createSimpleBinaryKernelImpl(e){return(t,r,a,i,o)=>{let s=n.backend_util.assertAndGetBroadcastShape(t,r),u=s.length,l=n.D5U.computeStrides(s),d=n.D5U.sizeFromShape(s),h=n.D5U.getTypedArrayFromDType(o,d),c=t.length,p=r.length,f=n.D5U.computeStrides(t),m=n.D5U.computeStrides(r),g=n.backend_util.getBroadcastDims(t,s),y=n.backend_util.getBroadcastDims(r,s);if(g.length+y.length===0)for(let t=0;t<h.length;++t)h[t]=e(a[t%a.length],i[t%i.length]);else for(let t=0;t<h.length;++t){let r=n.D5U.indexToLoc(t,u,l),o=r.slice(-c);g.forEach(e=>o[e]=0);let s=n.D5U.locToIndex(o,c,f),d=r.slice(-p);y.forEach(e=>d[e]=0);let x=n.D5U.locToIndex(d,p,m);h[t]=e(a[s],i[x])}return[h,s]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function complex(e){let{inputs:t,backend:r}=e,{real:n,imag:a}=t,i=r.data.get(n.dataId).values,o=r.data.get(a.dataId).values,s=r.makeTensorInfo(n.shape,"complex64"),u=r.data.get(s.dataId);return u.complexTensorInfos={real:r.makeTensorInfo(n.shape,"float32",i),imag:r.makeTensorInfo(a.shape,"float32",o)},s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function identity(e){let{inputs:t,backend:r}=e,{x:n}=t;return r.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function castImpl(e,t,r,a){if("int32"===a){let r=Int32Array.from(e);return[t,"int32",r]}if("bool"===a){let a=n.D5U.toTypedArray([0],r),[i,o]=createSimpleBinaryKernelImpl((e,t)=>e!==t?1:0)(t,[],e,a,"bool");return[o,"bool",i]}throw Error(`Error in Cast: failed to cast ${r} to ${a}`)}function cast(e){let{inputs:t,backend:r,attrs:a}=e,{x:i}=t,{dtype:o}=a;if("complex64"===o){if("complex64"===i.dtype)return identity({inputs:{x:i},backend:r});let e=/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zeros(e,t,r="float32"){if("complex64"===r){let r=zeros(e,t,"float32"),n=zeros(e,t,"float32");return complex({inputs:{real:r,imag:n},backend:e})}let a=n.D5U.makeZerosTypedArray(n.D5U.sizeFromShape(t),r);return e.makeTensorInfo(t,r,a)}(r,i.shape,i.dtype),t=cast({inputs:{x:i},backend:r,attrs:{dtype:"float32"}}),a=complex({inputs:{real:t,imag:e},backend:r});return r.disposeIntermediateTensorInfo(e),r.disposeIntermediateTensorInfo(t),a}if("complex64"===i.dtype){let e=/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r}=e,{input:n}=t,a=r.data.get(n.dataId).complexTensorInfos.real,i=r.data.get(a.dataId).values;return r.makeTensorInfo(a.shape,a.dtype,i)}({inputs:{input:i},backend:r}),t=cast({inputs:{x:e},backend:r,attrs:{dtype:o}});return r.disposeIntermediateTensorInfo(e),t}if(!n.D5U.hasEncodingLoss(i.dtype,o)){let e=identity({inputs:{x:i},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:o}}let s=r.data.get(i.dataId).values,[u,l,d]=castImpl(s,i.shape,i.dtype,o);return r.makeTensorInfo(u,l,d)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function binaryKernelFunc(e,t,r,a){return null==r?({inputs:r,backend:i})=>{let{a:o,b:s}=r;assertNotComplex([o,s],e);let u=i.data.get(o.dataId).values,l=i.data.get(s.dataId).values,d="string"===o.dtype?n.backend_util.fromUint8ToStringArray(u):u,h="string"===o.dtype?n.backend_util.fromUint8ToStringArray(l):l,c=a||o.dtype,[p,f]=t(o.shape,s.shape,d,h,c);return i.makeTensorInfo(f,c,p)}:({inputs:e,backend:n})=>{let{a:i,b:o}=e;if("complex64"===i.dtype||"complex64"===o.dtype){let e=cast({inputs:{x:i},backend:n,attrs:{dtype:"complex64"}}),t=n.data.get(e.dataId),a=t.complexTensorInfos.real,s=t.complexTensorInfos.imag,u=n.data.get(a.dataId).values,l=n.data.get(s.dataId).values,d=cast({inputs:{x:o},backend:n,attrs:{dtype:"complex64"}}),h=n.data.get(d.dataId),c=h.complexTensorInfos.real,p=h.complexTensorInfos.imag,f=n.data.get(c.dataId).values,m=n.data.get(p.dataId).values,[g,y,x]=r(i.shape,o.shape,u,l,f,m),b=n.makeTensorInfo(x,"float32",g),v=n.makeTensorInfo(x,"float32",y),w=complex({inputs:{real:b,imag:v},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(v),w}{let e=n.data.get(i.dataId).values,r=n.data.get(o.dataId).values,s=a||i.dtype,[u,l]=t(i.shape,o.shape,e,r,s);return n.makeTensorInfo(l,s,u)}}}function createComplexBinaryKernelImpl(e){return(t,r,a,i,o,s)=>{let u=n.backend_util.assertAndGetBroadcastShape(t,r),l=n.D5U.sizeFromShape(u),d=u.length,h=n.D5U.computeStrides(u),c=n.D5U.getTypedArrayFromDType("float32",l),p=n.D5U.getTypedArrayFromDType("float32",l),f=n.backend_util.getBroadcastDims(t,u),m=n.backend_util.getBroadcastDims(r,u),g=n.backend_util.mergeRealAndImagArrays(a,i),y=n.backend_util.mergeRealAndImagArrays(o,s),x=t.length,b=n.D5U.computeStrides(t),v=r.length,w=n.D5U.computeStrides(r);if(f.length+m.length===0)for(let t=0;t<c.length;t++){let r=t%g.length,n=t%y.length,a=e(g[2*r],g[2*r+1],y[2*n],y[2*n+1]);c[t]=a.real,p[t]=a.imag}else for(let t=0;t<c.length;t++){let r=n.D5U.indexToLoc(t,d,h),a=r.slice(-x);f.forEach(e=>a[e]=0);let i=n.D5U.locToIndex(a,x,b),o=r.slice(-v);m.forEach(e=>o[e]=0);let s=n.D5U.locToIndex(o,v,w),u=e(g[2*i],g[2*i+1],y[2*s],y[2*s+1]);c[t]=u.real,p[t]=u.imag}return[c,p,u]}}n.SYM,n.Zz9,n.iJz,n.xJR,n.RFZ;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let a=createSimpleBinaryKernelImpl((e,t)=>e+t),i=createComplexBinaryKernelImpl((e,t,r,n)=>({real:e+r,imag:t+n}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bincountImpl(e,t,r,a,i){let o=n.D5U.sizeFromShape(a),s=n.D5U.makeZerosTypedArray(i,r);for(let r=0;r<e.length;r++){let n=e[r];if(n<0)throw Error("Input x must be non-negative!");n>=i||(o>0?s[n]+=t[r]:s[n]+=1)}return s}function bincountReduceImpl(e,t,r,a=!1){let i=e.shape[0],o=e.shape[1],s=(0,n.f3b)([i,r],t.dtype);for(let n=0;n<i;n++)for(let i=0;i<o;i++){let o=e.get(n,i);if(o<0)throw Error("Input x must be non-negative!");o>=r||(a?s.set(1,n,o):t.size>0?s.set(s.get(n,o)+t.get(n,i),n,o):s.set(s.get(n,o)+1,n,o))}return s}binaryKernelFunc(n.mm_,a,i),n.mm_;/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let o=createSimpleBinaryKernelImpl((e,t)=>e&t);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function createSimpleUnaryImpl(e){return(t,r,a)=>{let i=n.D5U.getArrayFromDType(r,t.length);for(let r=0;r<t.length;++r)i[r]=e(t[r],a);return i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function unaryKernelFunc(e,t,r){let n=createSimpleUnaryImpl(t);return unaryKernelFuncFromImpl(e,n,r)}function unaryKernelFuncFromImpl(e,t,r){return({inputs:a,attrs:i,backend:o})=>{let s;let{x:u}=a;assertNotComplex(u,e);let l=o.data.get(u.dataId).values;if("string"===u.dtype){if(!Array.isArray(l))throw Error("String tensor's value was not an instance of Array");s=n.backend_util.fromUint8ToStringArray(l)}else s=l;let d=r||u.dtype,h=t(s,d,i);return o.makeTensorInfo(u.shape,d,h)}}binaryKernelFunc(n.hCO,o),n.hCO;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let s=createSimpleUnaryImpl(e=>Math.ceil(e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function concatImpl(e,t,r,a){let i=n.D5U.getArrayFromDType(r,n.D5U.sizeFromShape(t));if(a&&"string"!==r){let t=0;e.forEach(e=>{let r=n.D5U.sizeFromShape(e.shape);i.set(e.vals,t),t+=r})}else{let a=0;e.forEach(e=>{let o="string"===r?n.backend_util.fromUint8ToStringArray(e.vals):e.vals,s=0;for(let r=0;r<e.shape[0];++r){let n=r*t[1]+a;for(let t=0;t<e.shape[1];++t)i[n+t]=o[s++]}a+=e.shape[1]})}return i}unaryKernelFuncFromImpl(n.gJX,s),n.gJX;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let u=createSimpleBinaryKernelImpl((e,t)=>e===t?1:0);binaryKernelFunc(n.hdR,u,null,"bool"),n.hdR;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let l=createSimpleUnaryImpl(e=>Math.exp(e));unaryKernelFuncFromImpl(n.NEP,l,"float32"),n.NEP;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let d=createSimpleUnaryImpl(e=>Math.expm1(e));unaryKernelFuncFromImpl(n.Y0y,d),n.Y0y;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let h=createSimpleUnaryImpl(e=>Math.floor(e));unaryKernelFuncFromImpl(n.OR,h),n.OR;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let c=createSimpleBinaryKernelImpl((e,t)=>Math.floor(e/t));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gatherNdImpl(e,t,r,a,i,o,s,u,l){let d=(0,n.f3b)([a,o],r);for(let r=0;r<a;r++){let n=[],a=0;for(let t=0;t<i;t++){let o=e[r*i+t];a+=o*s[t],n.push(o)}if(a<0||a>=l/o)throw Error(`Invalid indices: ${n} does not index into ${u}`);for(let e=0;e<o;e++)d.values[r*o+e]=t.get(...t.indexToLoc(a*o+e))}return d}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gatherV2Impl(e,t,r){let a=(0,n.f3b)(r,e.dtype);for(let r=0;r<a.size;++r){let n=a.indexToLoc(r),i=n.slice(),o=i[0],s=i[2],u=t.locToIndex([o,s]);i[2]=t.values[u];let l=e.locToIndex(i);0<=l&&l<e.values.length&&(a.values[r]=e.values[l])}return a}binaryKernelFunc(n.jeX,c,null,"int32"),n.jeX;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let p=createSimpleBinaryKernelImpl((e,t)=>e>t?1:0);binaryKernelFunc(n.iZT,p,null,"bool"),n.iZT;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let f=createSimpleBinaryKernelImpl((e,t)=>e>=t?1:0);binaryKernelFunc(n.Acj,f,null,"bool"),n.Acj;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let m=createSimpleBinaryKernelImpl((e,t)=>e<t?1:0);binaryKernelFunc(n.vtC,m,null,"bool"),n.vtC;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let g=createSimpleBinaryKernelImpl((e,t)=>e<=t?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function linSpaceImpl(e,t,r){let a=(t-e)/(r-1),i=n.D5U.makeZerosTypedArray(r,"float32");i[0]=e;for(let e=1;e<i.length;e++)i[e]=i[e-1]+a;return i}binaryKernelFunc(n.CAk,g,null,"bool"),n.CAk;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let y=createSimpleUnaryImpl(e=>Math.log(e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function maxImpl(e,t,r,a){let i=n.D5U.getTypedArrayFromDType(a,n.D5U.sizeFromShape(r));for(let r=0;r<i.length;++r){let n=r*t,a=e[n];for(let r=0;r<t;++r){let t=e[n+r];(Number.isNaN(t)||t>a)&&(a=t)}i[r]=a}return i}unaryKernelFuncFromImpl(n.ZbH,y),n.ZbH;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let x=createSimpleBinaryKernelImpl((e,t)=>Math.max(e,t));binaryKernelFunc(n.BMI,x),n.BMI;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let b=createSimpleBinaryKernelImpl((e,t)=>Math.min(e,t));binaryKernelFunc(n.q8u,b),n.q8u;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let v=createSimpleBinaryKernelImpl((e,t)=>e*t),w=createComplexBinaryKernelImpl((e,t,r,n)=>({real:e*r-t*n,imag:e*n+t*r}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function negImpl(e,t,r){let a=n.D5U.createScalarValue(-1,r);return v([],t,a,e,r)}binaryKernelFunc(n.wYn,v,w),n.wYn,n.kuV;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let C=createSimpleBinaryKernelImpl((e,t)=>e!==t?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function transposeImpl(e,t,r,a,i){let o=t.length,s=n.D5U.sizeFromShape(t),u=n.D5U.computeStrides(t),l=n.D5U.computeStrides(i),d=n.D5U.getTypedArrayFromDType(r,n.D5U.sizeFromShape(i));for(let t=0;t<s;++t){let r=n.D5U.indexToLoc(t,o,u),i=Array(r.length);for(let e=0;e<i.length;e++)i[e]=r[a[e]];let s=n.D5U.locToIndex(i,o,l);d[s]=e[t]}return d}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function prodImpl(e,t,r,a){let[i,o]=n.backend_util.computeOutAndReduceShapes(e,a),s=(0,n.x8V)(t,"int32"),u=n.D5U.makeZerosTypedArray(n.D5U.sizeFromShape(i),s),l=n.D5U.sizeFromShape(o);for(let e=0;e<u.length;++e){let t=e*l,n=1;for(let e=0;e<l;++e)n*=r[t+e];u[e]=n}return{outVals:u,outShape:i,outDtype:s}}function computeFlatOuterDims(e,t){let r=e.slice(0,t);for(;r.length<t;)r.push(1);for(let n=t;n<e.length;n++)r[t-1]*=e[n];return r}function raggedGatherImpl(e,t,r,a,i,o,s,u){if(0===e.length)throw Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw Error("Split tensors must not be scalars");let l=t[0][0]-1;if(!/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t,r){e.forEach((e,a)=>{if(e<0||e>=r){let i=n.D5U.indexToLoc(a,t.length,n.D5U.computeStrides(t)).join(",");throw Error(`indices[${i}] = ${e} is not in [0, ${r})`)}})}(o,s,l),0===a.length)throw Error("params.rank must be nonzero");let d=a[0],{outSplits:h,valueSlices:c,numValues:p}=function(e,t,r,n){let a=[],i=0,o=t.length-1+r.length,s=Array(o).fill(null).map(()=>[0]);!function(e,t){for(let r=0;r<e.length;++r){let n=e[r],a=r===e.length-1?t:e[r+1].length;if(0===n.length)throw Error("Ragged splits may not be empty");if(n[0]<0)throw Error("Ragged splits must be non-negative");if(n[n.length-1]>a)throw Error("Ragged splits must not point past values");for(let e=1;e<n.length;++e)if(n[e-1]>n[e])throw Error("Ragged splits must be sorted in ascending order")}}(r,n);let u=1;for(let e=0;e<t.length-1;++e){u*=t[e];let r=t[e+1];for(let t=1;t<u+1;++t)s[e].push(t*r)}for(let n=0;n<e.length;++n){let o=e[n],u=e[n]+1;for(let e=0;e<r.length;++e){let n=r[e],a=e+t.length-1;if(a>=0){let e=s[a],t=e[e.length-1]-n[o];for(let e=o;e<u;++e)s[a].push(n[e+1]+t)}o=n[o],u=n[u]}u!==o&&(a.push([o,u]),i+=u-o)}return{outSplits:s,valueSlices:a,numValues:i}}(o,s,e,d),f=function(e){let t=[];for(let r=0;r<e.length;++r){let a=e[r].length,i=n.D5U.getArrayFromDType("int32",a);t.push(i),e[r].forEach((e,t)=>i[t]=e)}return t}(h),m=function(e,t,r,a,i){let o=t.slice();o[0]=i;let s=n.D5U.getArrayFromDType(r,n.D5U.sizeFromShape(o)),u=e.length,l=0===u?0:u/t[0];return!function(e,t,r,n,a,i){let o=computeFlatOuterDims(t,2)[1],s=computeFlatOuterDims(i,2)[1],u=0;for(let t of r)for(let r=t[0];r<t[1];++r){for(let t=0;t<n;++t)a[u*s+t]=e[r*o+t];++u}}(e,t,a,l,s,o),[s,o]}(r,a,i,c,p);return[f,m[0],m[1]]}function raggedRangeImpl(e,t,r,a,i,o,s){if(t.length>1)throw Error("starts must be a scalar or vector");if(i.length>1)throw Error("limits must be a scalar or vector");if(s.length>1)throw Error("deltas must be a scalar or vector");let u=0===t.length,l=0===i.length,d=0===s.length,h=[];u||h.push(t[0]),l||h.push(i[0]),d||h.push(s[0]);for(let e=1;e<h.length;++e)if(h[e]!==h[e-1])throw Error("starts, limits, and deltas must have the same shape");let c=0===h.length?1:h[0],p=n.D5U.getArrayFromDType("int32",c+1);p[0]=0;for(let t=0;t<c;++t){let r;let n=u?e[0]:e[t],i=l?a[0]:a[t],s=d?o[0]:o[t];if(0===s)throw Error("Requires delta != 0");if(s>0&&i<n||s<0&&i>n)r=0;else if((r=Math.ceil(Math.abs((i-n)/s)))>2147483647)throw Error("Requires ((limit - start) / delta) <= 2147483647");p[t+1]=p[t]+r}let f=p[c],m=n.D5U.getArrayFromDType(r,f),g=0;for(let t=0;t<c;++t){let r=p[t+1]-p[t],n=u?e[0]:e[t],a=d?o[0]:o[t];for(let e=0;e<r;++e)m[g++]=n,n+=a}return[p,m]}binaryKernelFunc(n.yQU,C,null,"bool"),n.yQU,n.G3Y,n.DlI;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var S=n.backend_util.RowPartitionType;let RaggedTensorToTensorOp=class RaggedTensorToTensorOp{constructor(e,t,r,a,i,o,s,u,l,d){this.shape=e,this.shapeShape=t,this.values=r,this.valuesShape=a,this.valuesDType=i,this.defaultValue=o,this.defaultValueShape=s,this.rowPartitionValues=u,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=n.backend_util.getRowPartitionTypesHelper(d),this.raggedRank=n.backend_util.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===S.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===S.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){let t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case S.VALUE_ROWIDS:return RaggedTensorToTensorOp.getMaxWidthValueRowID(t);case S.ROW_SPLITS:return RaggedTensorToTensorOp.getMaxWidthRowSplit(t);default:throw Error(`Cannot handle partition type ${S[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){let t=e.length;if(0===t||1===t)return 0;let r=0;for(let n=0;n<t-1;++n){let t=e[n+1]-e[n];t>r&&(r=t)}return r}static getMaxWidthValueRowID(e){let t=e.length;if(0===t)return 0;let r=0,n=e[0],a=0;for(let i=1;i<t;++i){let t=e[i];t!==n&&(n=t,a=Math.max(i-r,a),r=i)}return Math.max(t-r,a)}tensorShapeFromTensor(e,t,r=!0){if(0===t.length){if(-1===e[0])return[];throw Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return makeShape(e,r)}calculateOutputSize(e){let t=this.valuesShape,r=this.defaultValueShape;n.backend_util.validateDefaultValueShape(r,t);let a=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=n.backend_util.combineRaggedTensorToTensorShapes(this.raggedRank,a,t);i[0]<0&&(i[0]=e);for(let e=1;e<=this.raggedRank;++e)i[e]<0&&(i[e]=this.getMaxWidth(e));return i}calculateFirstParentOutputIndex(e,t,r){let a=Math.min(e,r),i=[],o=0;for(let e=0;e<a;++e,o+=t)i.push(o);for(let t=a;t<e;++t)i.push(-1);return n.D5U.assert(i.length===e,()=>"Final length of result must be equal to firstDimension."),i}calculateOutputIndexRowSplit(e,t,r,n){let a=e.length,i=[];for(let o=0;o<a-1;++o){let a=e[o+1]-e[o],s=Math.min(n,a),u=t[o];-1===u&&(s=0);for(let e=0;e<s;++e)i.push(u),u+=r;for(let e=0;e<a-s;++e)i.push(-1)}if(a>0&&i.length!==e[a-1])throw Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(e,t,r,n){let a=e.length,i=[];if(0===a)return[];let o=0,s=e[0];if(s>=t.length)throw Error(`Got currentValueRowId=${s}, which is not less than ${t.length}`);let u=t[s];i.push(u);for(let l=1;l<a;++l){let a=e[l];if(a===s)u>=0&&(++o<n?u+=r:u=-1);else{if(o=0,s=a,a>=t.length)throw Error(`Got nextValueRowId=${a} which is not less than ${t.length}`);u=t[a]}i.push(u)}if(i.length!==e.length)throw Error("Invalid row ids.");return i}calculateOutputIndex(e,t,r,n){let a=this.getRowPartitionTensor(e),i=this.getRowPartitionTypeByDimension(e);switch(i){case S.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,t,r,n);case S.ROW_SPLITS:if(a.length-1>t.length)throw Error(`Row partition size is greater than output size: ${a.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(a,t,r,n);default:throw Error(`Unsupported partition type: ${S[i]}`)}}getFirstDimensionSize(){let e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw Error("No row_partition_types given.");let t=this.rowPartitionTypes[0];switch(t){case S.FIRST_DIM_SIZE:return e[0];case S.VALUE_ROWIDS:throw Error("Cannot handle VALUE_ROWIDS in first dimension.");case S.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw Error(`Cannot handle type ${S[t]}`)}}compute(){let e=this.rowPartitionValues[0];if(e.length<=0)throw Error("Invalid first partition input. Tensor requires at least one element.");let t=this.getFirstDimensionSize(),r=this.calculateOutputSize(t),a=Array(this.raggedRank+1);a[a.length-1]=1;for(let e=a.length-2;e>=0;--e)a[e]=a[e+1]*r[e+1];let i=makeShape(r,!1),o=n.D5U.getArrayFromDType(this.valuesDType,n.D5U.sizeFromShape(i)),s=a[0]*r[0];if(s>0){let e=this.calculateFirstParentOutputIndex(t,a[0],r[0]);for(let t=1;t<=this.raggedRank;++t){let n=this.calculateOutputIndex(t-1,e,a[t],r[t]);e=n}this.setOutput(this.raggedRank,e,o,i)}return[i,o]}setOutput(e,t,r,a){if(0===r.length)return;let i=this.values,o=a.slice();o=o.slice(e+1);let s=n.D5U.sizeFromShape(o),u=t.length,l=this.defaultValue;if(l.length!==s&&1!==l.length){let e=this.defaultValueShape;(0,n.lub)(()=>{let t=(0,n.XLQ)(l,e),r=(0,n.UFq)(t,o);l=r.dataSync()})}let d=0,h=0,c=0;for(let e=0;e<=u;++e){let n=e<u?t[e]:-1;if(n===c){++c;continue}if(h<c){let e=i.subarray(d*s),t=r.subarray(h*s),n=(c-h)*s;copyArray(t,e,n)}if(e>=u){let e=r.length;n=Math.floor(e/s)}if(n>c){if(1===this.defaultValue.length)r.subarray(c*s,n*s).fill(this.defaultValue[0]),c=n;else for(;n>c;){let e=r.slice(c*s);copyArray(e,l,s),++c}}n<0?(d=e+1,h=c):(d=e,c=(h=c)+1)}}};function copyArray(e,t,r){for(let n=0;n<r;n++)e[n]=t[n]}function makeShape(e,t){let r=[];for(let n of e){if(n<0){if(!t)throw Error(`Dimension ${n} must be >= 0`);if(n<-1)throw Error(`Dimension ${n} must be >= -1`);n=-1}r.push(n)}return r}function raggedTensorToTensorImpl(e,t,r,n,a,i,o,s,u,l){return new RaggedTensorToTensorOp(e,t,r,n,a,i,o,s,u,l).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rangeImpl(e,t,r,a){let i=e<t&&r<0,o=t<e&&r>1;if(e===t||i||o)return n.D5U.makeZerosTypedArray(0,a);let s=Math.abs(Math.ceil((t-e)/r)),u=n.D5U.makeZerosTypedArray(s,a);t<e&&1===r&&(r=-1),u[0]=e;for(let e=1;e<u.length;e++)u[e]=u[e-1]+r;return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let I=createSimpleUnaryImpl(e=>1/Math.sqrt(e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function scatterImpl(e,t,r,a,i,o,s,u,l,d){let h=[a/i,i],c=e.values,p=t.values;if(0===a)return(0,n.f3b)(r,t.dtype);let f=l instanceof n.YDk?l:(0,n.f3b)(h,t.dtype);"string"==typeof l?f.values.fill(l):"number"==typeof l?f.values.fill(l):"boolean"==typeof l&&f.values.fill(+l);for(let e=0;e<o;e++){let n=[],o=0;for(let t=0;t<s;t++){let r=c[e*s+t];n.push(r),o+=r*u[t]}if(o<0||o>=a/i)throw Error(`Invalid indices: ${n} does not index into ${r}`);for(let r=0;r<i;r++)d?f.values[o*i+r]+=p[e*i+r]:f.values[o*i+r]=0===t.rank?p[0]:p[e*i+r]}return f}unaryKernelFuncFromImpl(n.bV0,I),n.bV0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let k=createSimpleUnaryImpl(e=>1/(1+Math.exp(-e)));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sliceImpl(e,t,r,a,i){let o=n.kuN.isSliceContinous(a,t,r),s=n.D5U.sizeFromShape(r),u=n.D5U.computeStrides(a);if(o){let r=n.kuN.computeFlatOffset(t,u);return"string"===i?e.slice(r,r+s):e.subarray(r,r+s)}let l="string"===i?n.backend_util.fromUint8ToStringArray(e):e,d=(0,n.f3b)(a,i,l),h=(0,n.f3b)(r,i);for(let e=0;e<h.size;++e){let r=h.indexToLoc(e),n=r.map((e,r)=>e+t[r]);h.set(d.get(...n),...r)}return"string"===i?n.backend_util.fromStringArrayToUint8(h.values):h.values}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseFillEmptyRowsImpl(e,t,r,a,i,o,s){let u=t[0],l=o[0],d=Array(l),h=Array(u),c=t[1];if(0===l){if(0!==u)throw Error(n.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(u));let e=n.D5U.getArrayFromDType(r,0),t=n.D5U.getArrayFromDType(i,0);return[e,[0,c],t,d,h]}let p=!0,f=0,m=Array(l).fill(0);for(let t=0;t<u;++t){let r=e[t*c];if(r<0)throw Error(n.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(t,r));if(r>=l)throw Error(n.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(t,r,l));++m[r],p=p&&r>=f,f=r}let g=!0;for(let e=0;e<l;++e){let t=0===m[e];d[e]=t,g=g&&!t,m[e]=Math.max(m[e],1),e>0&&(m[e]+=m[e-1])}if(g&&p){for(let e=0;e<u;++e)h[e]=e;return[e,[u,c],a,d,h]}{let t=m[l-1],o=n.D5U.getArrayFromDType(r,t*c),p=n.D5U.getArrayFromDType(i,t),f=Array(l).fill(0);for(let t=0;t<u;++t){let r=e[t*c],n=f[r],i=(0===r?0:m[r-1])+n;f[r]++;for(let r=0;r<c;++r)o[i*c+r]=e[t*c+r];p[i]=a[t],h[t]=i}for(let e=0;e<l;++e){let t=f[e];if(0===t){let t=0===e?0:m[e-1];o[t*c+0]=e;for(let e=1;e<c;++e)o[t*c+e]=0;p[t]=s}}return[o,[t,c],p,d,h]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseReshapeImpl(e,t,r,a,i){let o=n.D5U.sizeFromShape(a),s=t[0],u=i.length,l=[],d=1,h=-1;for(let e=0;e<u;++e){let t=i[e];if(-1===t){if(-1!==h)throw Error(n.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(h,e));h=e,l.push(1)}else{if(t<0)throw Error(n.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(e,t));d*=t,l.push(t)}}if(-1!==h){if(d<=0)throw Error(n.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let e=Math.trunc(o/d);if(d*e!==o)throw Error(n.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(a,l));l[h]=e}let c=n.D5U.sizeFromShape(l);if(c!==o)throw Error(n.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(a,l));let p=a.length,f=[];if(p>0){f[p-1]=1;for(let e=p-2;e>=0;--e)f[e]=f[e+1]*a[e+1]}let m=[];if(u>0){m[u-1]=1;for(let e=u-2;e>=0;--e)m[e]=m[e+1]*l[e+1]}let g=n.D5U.getArrayFromDType(r,s*u);for(let t=0;t<s;++t){let r=0;for(let n=0;n<p;++n)r+=e[t*p+n]*f[n];for(let e=0;e<u;++e)g[t*u+e]=Math.trunc(r/m[e]),r%=m[e]}return[g,[s,u],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseSegmentReductionImpl(e,t,r,a,i,o=!1,s=0){let u=a.length,l=[t[0],e.length/t[0]],d=l[1],h=u>0?i[u-1]+1:0;if(h<0)throw Error(n.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let c=t.slice();c[0]=h;let p=c.reduce((e,t)=>e*t,1),f=n.D5U.getArrayFromDType(r,p);if(0===u)return h>0&&f.fill(s),[f,c];if(h<=0)throw Error(n.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=0,g=1,y=0,x=i[0];for(;;){let t=0;if(g<u){if(x===(t=i[g])){++g;continue}if(x>=t)throw Error(n.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(x<0||x>=h)throw Error(n.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(x,h));x>y&&f.fill(s,y*d,x*d);for(let t=m;t<g;++t){let r=a[t];if(r<0||r>=l[0])throw Error(n.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(t,a[t],l[0]));for(let t=0;t<d;t++)f[x*d+t]+=e[r*d+t]}if(o)for(let e=0;e<d;e++)f[x*d+e]/=g-m;if(m=g,++g,y=x+1,x=t,g>u)break}return y<h&&f.fill(s,y*d,h*d),[f,c]}unaryKernelFunc(n.a5O,e=>1/(1+Math.exp(-e))),n.a5O,n.p2w;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let R=createSimpleUnaryImpl(e=>Math.sqrt(e));unaryKernelFunc(n.FKq,e=>Math.sqrt(e)),n.FKq;/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let $=createSimpleUnaryImpl((e,t)=>{let{pattern:r,replaceGlobal:n,rewrite:a}=t;return e.replace(new RegExp(r,n?"g":""),a)});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stridedSliceImpl(e,t,r,a){let i=(0,n.f3b)(e,t.dtype);for(let e=0;e<i.size;e++){let n=i.indexToLoc(e),o=Array(n.length);for(let e=0;e<o.length;e++)o[e]=n[e]*r[e]+a[e];i.set(t.get(...o),...n)}return i}unaryKernelFuncFromImpl(n.e0R,$),n.e0R;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let StringNGramsOp=class StringNGramsOp{constructor(e,t,r,a,i,o){this.separator=n.D5U.encodeString(e),this.nGramWidths=t,this.leftPad=n.D5U.encodeString(r),this.rightPad=n.D5U.encodeString(a),this.padWidth=i,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let r=this.getPadWidth(t);return Math.max(0,e+2*r-t+1)}createNGrams(e,t,r,n,a,i){for(let o=0;o<a;++o){let s;let u=this.getPadWidth(i),l=Math.max(0,u-o),d=Math.max(0,u-(a-(o+1))),h=i-(l+d),c=t+(l>0?0:o-u);s=0+l*this.leftPad.length;for(let t=0;t<h;++t)s+=e[c+t].length;s+=d*this.rightPad.length;let p=l+d+h-1;s+=p*this.separator.length,r[n+o]=new Uint8Array(s);let f=r[n+o],m=0,appendToNGram=e=>e.forEach(e=>f[m++]=e);for(let e=0;e<l;++e)appendToNGram(this.leftPad),appendToNGram(this.separator);for(let t=0;t<h-1;++t)appendToNGram(e[c+t]),appendToNGram(this.separator);if(h>0){appendToNGram(e[c+h-1]);for(let e=0;e<d;++e)appendToNGram(this.separator),appendToNGram(this.rightPad)}else{for(let e=0;e<d-1;++e)appendToNGram(this.rightPad),appendToNGram(this.separator);appendToNGram(this.rightPad)}}}compute(e,t){let r=e.length,a=t.length;if(a>0){let e=t[0];if(0!==e)throw Error(`First split value must be 0, got ${e}`);for(let n=1;n<a;++n){let a=t[n]>=e;if(!(a=a&&t[n]<=r))throw Error(`Invalid split value ${t[n]}, must be in [${e}, ${r}]`);e=t[n]}if(e!==r)throw Error(`Last split value must be data size. Expected ${r}, got ${e}`)}let i=a-1,o=n.D5U.getArrayFromDType("int32",a);if(0===r||0===a){let e=Array(r);for(let e=0;e<=i;++e)o[e]=0;return[e,o]}o[0]=0;for(let e=1;e<=i;++e){let r=t[e]-t[e-1],n=0;this.nGramWidths.forEach(e=>{n+=this.getNumNGrams(r,e)}),this.preserveShort&&r>0&&0===n&&(n=1),o[e]=o[e-1]+n}let s=Array(o[i]);for(let r=0;r<i;++r){let n=t[r],a=o[r];if(this.nGramWidths.forEach(i=>{let o=t[r+1]-t[r],u=this.getNumNGrams(o,i);this.createNGrams(e,n,s,a,u,i),a+=u}),this.preserveShort&&a===o[r]){let i=t[r+1]-t[r];if(0===i)continue;let o=i+2*this.padWidth;this.createNGrams(e,n,s,a,1,o)}}return[s,o]}};function stringNGramsImpl(e,t,r,n,a,i,o,s){return new StringNGramsOp(r,n,a,i,o,s).compute(e,t)}function stringSplitImpl(e,t,r){let a=e.length,i=[],o=0,s=0,u=Array(a);for(let n=0;n<a;++n){let a=i.length;!/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t,r,n){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)n.push(e.subarray(t,t+1));return}if(1===t.length){let a=t[0],i=e.indexOf(a);for(;-1!==i;){let t=e.subarray(0,i);r&&0===t.length||n.push(t),i=(e=e.subarray(i+1)).indexOf(a)}r&&0===e.length||n.push(e);return}let a=0;for(let i=0;i<e.length+1;i++)if(i===e.length||-1!==t.indexOf(e[i])){let t=e.subarray(a,i);r&&0===t.length||n.push(t),a=i+1}}(e[n],t,r,i);let l=i.length-a;u[n]=l,o+=l,s=Math.max(s,l)}let l=n.D5U.getArrayFromDType("int32",2*o),d=Array(o),h=[a,s],c=0;for(let e=0;e<a;++e)for(let t=0;t<u[e];++t)l[2*c]=e,l[2*c+1]=t,d[c]=i[c],++c;return[l,d,h]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function stringToHashBucketFastImpl(e,t){let r=n.D5U.getArrayFromDType("int32",e.length);for(let a=0;a<e.length;++a)r[a]=n.D5U.fingerPrint64(e[a]).modulo(t).getLowBitsUnsigned();return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let T=createSimpleBinaryKernelImpl((e,t)=>e-t),D=createComplexBinaryKernelImpl((e,t,r,n)=>({real:e-r,imag:t-n}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tileImpl(e,t){let r=Array(e.rank);for(let n=0;n<r.length;n++)r[n]=e.shape[n]*t[n];let a=(0,n.f3b)(r,e.dtype);for(let t=0;t<a.values.length;++t){let r=a.indexToLoc(t),n=Array(e.rank);for(let t=0;t<n.length;t++)n[t]=r[t]%e.shape[t];let i=e.locToIndex(n);a.values[t]=e.values[i]}return a}binaryKernelFunc(n.Tr8,T,D),n.Tr8;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let comparePair=(e,t)=>{let r=t.value-e.value;return 0===r?e.index-t.index:r};function topKImpl(e,t,r,a,i){let o=t[t.length-1],[s,u]=[e.length/o,o],l=n.D5U.getTypedArrayFromDType(r,s*a),d=n.D5U.getTypedArrayFromDType("int32",s*a);for(let t=0;t<s;t++){let r=t*u,o=e.subarray(r,r+u),s=Array(o.length);o.forEach((e,t)=>s[t]={value:e,index:t}),a<s.length&&(function TopK_impl_select(e,t,r=0,a=e.length-1){for(;a>r;){if(a-r>600){let n=a-r+1,i=t-r+1,o=Math.log(n),s=.5*Math.exp(2*o/3),u=.5*Math.sqrt(o*s*(n-s)/n)*Math.sign(i-n/2),l=Math.max(r,Math.floor(t-i*s/n+u)),d=Math.min(a,Math.floor(t+(n-i)*s/n+u));TopK_impl_select(e,t,l,d)}let i=e[t],o=r,s=a;for(n.D5U.swap(e,r,t),comparePair(e[a],i)>0&&n.D5U.swap(e,r,a);o<s;){for(n.D5U.swap(e,o,s),o++,s--;0>comparePair(e[o],i);)o+=1;for(;comparePair(e[s],i)>0;)s-=1}0===comparePair(e[r],i)?n.D5U.swap(e,r,s):(s+=1,n.D5U.swap(e,s,a)),s<=t&&(r=s+1),t<=s&&(a=s-1)}}(s,a),s=s.slice(0,a)),i&&s.sort(comparePair);let h=t*a,c=l.subarray(h,h+a),p=d.subarray(h,h+a);for(let e=0;e<a;e++)c[e]=s[e].value,p[e]=s[e].index}let h=t.slice();return h[h.length-1]=a,[(0,n.f3b)(h,r,l),(0,n.f3b)(h,"int32",d)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uniqueImpl(e,t,r,a){let i=n.D5U.parseAxisParam(t,r)[0],o=[1,r[0],1];for(let e=0;e<i;e++)o[0]*=r[e];o[1]=r[i];for(let e=i+1;e<r.length;e++)o[2]*=r[e];let s=new Map,u=new Int32Array(r[i]),l=new n.YDk(o,a,e),d=[],h=1===o[0]&&1===o[2];for(let t=0;t<r[i];t++){let r;if(h)r=e[t].toString();else{let e=[];for(let r=0;r<o[0];r++)for(let n=0;n<o[2];n++)e.push(l.get(r,t,n));r=e.join(",")}let n=s.get(r);if(null!=n)u[t]=n;else{let e=s.size;s.set(r,e),u[t]=e,d.push(t)}}let c=o.slice();c[1]=s.size;let p=new n.YDk(c,a);d.forEach((e,t)=>{for(let r=0;r<o[0];r++)for(let n=0;n<o[2];n++)p.set(l.get(r,e,n),r,t,n)});let f=r.slice();return f[i]=c[1],{outputValues:p.values,outputShape:f,indices:u}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */},58876:function(e,t,r){"use strict";r.d(t,{jl:function(){return function getWebGLContext(e,t){if(!(e in a)||null!=t){let r=function(e,t){if(1!==e&&2!==e)throw Error("Cannot get WebGL rendering context, WebGL is disabled.");let r=null==t?function(e){if(!(0,n.OBj)().getBool("IS_SAFARI")&&"undefined"!=typeof OffscreenCanvas&&2===e)return new OffscreenCanvas(300,150);if("undefined"!=typeof document)return document.createElement("canvas");throw Error("Cannot create a canvas in this context")}(e):t;return(r.addEventListener("webglcontextlost",t=>{t.preventDefault(),delete a[e]},!1),(0,n.OBj)().getBool("SOFTWARE_WEBGL_ENABLED")&&(i.failIfMajorPerformanceCaveat=!1),1===e)?r.getContext("webgl",i)||r.getContext("experimental-webgl",i):r.getContext("webgl2",i)}(e,t);if(null===r)return console.log("Could not get context for WebGL version",e),null;a[e]=r}let r=a[e];return null==r||r.isContextLost()?(delete a[e],getWebGLContext(e)):(r.disable(r.DEPTH_TEST),r.disable(r.STENCIL_TEST),r.disable(r.BLEND),r.disable(r.DITHER),r.disable(r.POLYGON_OFFSET_FILL),r.disable(r.SAMPLE_COVERAGE),r.enable(r.SCISSOR_TEST),r.enable(r.CULL_FACE),r.cullFace(r.BACK),a[e])}},nd:function(){return setWebGLContext}});var n=r(82783);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let a={},i={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function setWebGLContext(e,t){a[e]=t}},90564:function(e,t,r){"use strict";r.d(t,{_:function(){return DecodeMatrixProgram}});var n=r(12011),a=r(58257),i=r(37589),o=r(15389);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DecodeMatrixProgram=class DecodeMatrixProgram{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=o.m1.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=(0,n.A)();this.outputShape=e,this.enableShapeUniforms=(0,a.C9)(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?i.Kn(["r","c","d"],e):i.RW(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}},4880:function(e,t,r){"use strict";r.d(t,{G:function(){return DecodeMatrixPackedProgram}});var n=r(12011),a=r(58257),i=r(37589),o=r(15389);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DecodeMatrixPackedProgram=class DecodeMatrixPackedProgram{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=o.m1.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=(0,n.A)();this.outputShape=e,this.enableShapeUniforms=(0,a.C9)(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?i.Kn(["r","c","d"],e):i.RW(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}},65347:function(e,t,r){"use strict";r.d(t,{q:function(){return EncodeFloatProgram}});var n=r(12011),a=r(37589),i=r(15389);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let EncodeFloatProgram=class EncodeFloatProgram{constructor(e){this.variableNames=["A"],this.outTexUsage=i.v2.DOWNLOAD;let t=(0,n.A)();this.outputShape=e,this.userCode=`
      ${a.ye}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}},43564:function(e,t,r){"use strict";r.d(t,{d:function(){return EncodeFloatPackedProgram}});var n=r(12011),a=r(37589),i=r(15389);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let EncodeFloatPackedProgram=class EncodeFloatPackedProgram{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=i.v2.DOWNLOAD;let t=(0,n.A)();this.outputShape=e,this.userCode=`
      ${a.ye}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}},12616:function(e,t,r){"use strict";r.d(t,{F:function(){return EncodeMatrixProgram}});var n=r(12011),a=r(58257),i=r(37589);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let o={R:0,G:1,B:2,A:3};let EncodeMatrixProgram=class EncodeMatrixProgram{constructor(e,t=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let s=(0,n.A)();this.outputShape=e,this.enableShapeUniforms=(0,a.C9)(this.outputShape.length);let u="result";t&&(u="floor(result * 255. + 0.5)");let l="";for(let e=0;e<r.length;e++){let t=r[e];l+=`
          if(offset == ${e}) {
            result = values[${o[t]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?i.nc():i.ku(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${s.texture2D}(A, uv);
          ${l}
        }
        ${s.output} = vec4(${u}, 0., 0., 0.);
      }
    `}}},88501:function(e,t,r){"use strict";r.d(t,{Z:function(){return EncodeMatrixPackedProgram}});var n=r(12011),a=r(58257),i=r(37589);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let EncodeMatrixPackedProgram=class EncodeMatrixPackedProgram{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=(0,n.A)();this.outputShape=e,this.enableShapeUniforms=(0,a.C9)(this.outputShape.length);let o="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let t=0;t<=1;t++)for(let n=0;n<=1;n++){let a=2*t+n;o+=`
          localCoords = coords;
          if(localCoords[2] + ${n} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${n};
          if (localCoords[1] + ${t} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${t};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${a}] = values[0];
            } else if (offset == 1) {
              result[${a}] = values[1];
            } else if (offset == 2) {
              result[${a}] = values[2];
            } else {
              result[${a}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?i.nc():i.ku(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${o}

          ${r.output} = ${s};
        }
    `}}},77674:function(e,t,r){"use strict";var n=r(82783),a=r(67818);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let i=(0,n.OBj)();i.registerFlag("HAS_WEBGL",()=>i.getNumber("WEBGL_VERSION")>0),i.registerFlag("WEBGL_VERSION",()=>(0,a.uH)(2)?2:(0,a.uH)(1)?1:0),i.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),i.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===i.get("WEBGL_VERSION")),i.registerFlag("WEBGL_CPU_FORWARD",()=>!0),i.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),i.registerFlag("WEBGL_PACK",()=>i.getBool("HAS_WEBGL")),i.registerFlag("WEBGL_PACK_NORMALIZATION",()=>i.getBool("WEBGL_PACK")),i.registerFlag("WEBGL_PACK_CLIP",()=>i.getBool("WEBGL_PACK")),i.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>i.getBool("WEBGL_PACK")),i.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>i.getBool("WEBGL_PACK")),i.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>i.getBool("WEBGL_PACK")),i.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>i.getBool("WEBGL_PACK")),i.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>i.getBool("WEBGL_PACK")),i.registerFlag("WEBGL_PACK_REDUCE",()=>i.getBool("WEBGL_PACK")),i.registerFlag("WEBGL_LAZILY_UNPACK",()=>i.getBool("WEBGL_PACK")),i.registerFlag("WEBGL_CONV_IM2COL",()=>i.getBool("WEBGL_PACK")),i.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>i.getBool("WEBGL_PACK")),i.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>(0,a.lo)(i.getNumber("WEBGL_VERSION"))),i.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>(0,a.KP)(i.getNumber("WEBGL_VERSION"))),i.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let e=i.getNumber("WEBGL_VERSION");return 0===e?0:(0,a.nr)(e)}),i.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>i.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!n.C2$.isMobile()),i.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>(0,a.wb)(i.getNumber("WEBGL_VERSION"))),i.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!i.getBool("WEBGL_FORCE_F16_TEXTURES")&&i.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),i.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>(0,a.BH)(i.getNumber("WEBGL_VERSION"))),i.registerFlag("WEBGL_FENCE_API_ENABLED",()=>(0,a.Qd)(i.getNumber("WEBGL_VERSION"))),i.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>{let e=i.getBool("WEBGL_RENDER_FLOAT32_ENABLED");return e?4:0}),i.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if("number"!=typeof e)throw Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)}),i.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>n.C2$.isMobile()?1:-1,e=>{if("number"!=typeof e)throw Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)}),i.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),i.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),i.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),i.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),i.registerFlag("WEBGL_EXP_CONV",()=>!1),i.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>i.getBool("IS_TEST")),i.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),i.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),i.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),i.registerFlag("ENGINE_COMPILE_ONLY",()=>!1)},12011:function(e,t,r){"use strict";r.d(t,{A:function(){return getGlslDifferences}});var n=r(82783);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getGlslDifferences(){let e,t,r,a,i,o,s,u,l,d;return 2===(0,n.OBj)().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",r="out",a="in",i="texture",o="outputColor",s="out vec4 outputColor;",u=(0,n.OBj)().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",d=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",r="varying",a="varying",i="texture2D",o="gl_FragColor",s="",u=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,d=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:r,varyingFs:a,texture2D:i,output:o,defineOutput:s,defineSpecialNaN:u,defineSpecialInf:l,defineRound:d}}},99233:function(e,t,r){"use strict";r.d(t,{A:function(){return GPGPUContext}});var n=r(82783),a=r(58876),i=r(25121),o=r(15389),s=r(67818);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let GPGPUContext=class GPGPUContext{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=(0,n.OBj)().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,(0,a.nd)(t,e)):this.gl=(0,a.jl)(t),e=this.gl,2===(0,n.OBj)().getNumber("WEBGL_VERSION")){let t=e;this.createVertexArray=()=>s.O7(t,()=>t.createVertexArray()),this.bindVertexArray=e=>s.O7(t,()=>t.bindVertexArray(e)),this.deleteVertexArray=e=>s.O7(t,()=>t.deleteVertexArray(e)),this.getVertexArray=()=>s.O7(t,()=>t.getParameter(t.VERTEX_ARRAY_BINDING))}else if(null!=e){let t=e.getExtension("OES_vertex_array_object");if(null==t)throw Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>s.O7(e,()=>t.createVertexArrayOES()),this.bindVertexArray=r=>s.O7(e,()=>t.bindVertexArrayOES(r)),this.deleteVertexArray=r=>s.O7(e,()=>t.deleteVertexArrayOES(r)),this.getVertexArray=()=>s.O7(e,()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float",u="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===(0,n.OBj)().getNumber("WEBGL_VERSION")){let e="OES_texture_half_float";if(this.textureFloatExtension=s.HH(this.gl,"OES_texture_float"),s.y_(this.gl,e))this.textureHalfFloatExtension=s.HH(this.gl,e);else if((0,n.OBj)().get("WEBGL_FORCE_F16_TEXTURES"))throw Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),s.y_(this.gl,u))this.colorBufferHalfFloatExtension=s.HH(this.gl,u);else if((0,n.OBj)().get("WEBGL_FORCE_F16_TEXTURES"))throw Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",s.y_(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(s.y_(this.gl,u))this.colorBufferHalfFloatExtension=this.gl.getExtension(u);else throw Error("GL context does not support color renderable floats");this.vertexBuffer=i.Y3(this.gl),this.indexBuffer=i.Hb(this.gl),this.framebuffer=s.d8(this.gl),this.textureConfig=o.Sq(this.gl,this.textureHalfFloatExtension)}get debug(){return(0,n.OBj)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;s.O7(e,()=>e.finish()),s.O7(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),s.O7(e,()=>e.deleteFramebuffer(this.framebuffer)),s.O7(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),s.O7(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),s.O7(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),i.T2(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),i.iN(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),i.BQ(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),i.Qr(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,r,n){this.throwIfDisposed(),i.Uk(this.gl,e,t,r,n,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),i.Cs(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),i.cU(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(s.ax(this.gl,this.framebuffer),this.outputTexture=null),s.O7(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,r){return this.downloadMatrixDriver(e,()=>i.HC(this.gl,t,r,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,r,n,a,o){return i.AD(this.gl,e,t,r,n,a,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return i.ez(this.gl,e,t)}createBufferFromTexture(e,t,r){this.bindTextureToFrameBuffer(e);let n=i.A8(this.gl,t,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),n}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,r;if((0,n.OBj)().getBool("WEBGL_FENCE_API_ENABLED")){let n=e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{let t=e.clientWaitSync(n,0,0);return t===e.ALREADY_SIGNALED||t===e.CONDITION_SATISFIED},t=n}else(0,n.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(t,(0,n.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:t,isFencePassed:r}}downloadMatrixFromPackedTexture(e,t,r){return this.downloadMatrixDriver(e,()=>i.P1(this.gl,t,r))}createProgram(e){this.throwIfDisposed();let t=this.gl;null==this.vertexShader&&(this.vertexShader=i.Jj(t));let r=s.HO(t);s.O7(t,()=>t.attachShader(r,this.vertexShader)),s.O7(t,()=>t.attachShader(r,e)),s.aj(t,r);let n=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&s.vu(t,n),n}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;s.O7(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),i.Hc(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(s.O7(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&s.vu(this.gl,this.program),s.O7(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,r=!0){return(this.throwIfDisposed(),r)?s.XE(this.gl,e,t):s.Hg(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),s.O7(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,r){this.throwIfDisposed(),this.throwIfNoProgram(),s.B(this.gl,e,t,r)}setOutputMatrixTexture(e,t,r){this.setOutputMatrixTextureDriver(e,r,t)}setOutputPackedMatrixTexture(e,t,r){this.throwIfDisposed();let[n,a]=o.qe(t,r);this.setOutputMatrixTextureDriver(e,n,a)}setOutputMatrixWriteRegion(e,t,r,n){this.setOutputMatrixWriteRegionDriver(r,e,n,t)}setOutputPackedMatrixWriteRegion(e,t,r,n){throw Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&s.vu(this.gl,this.program),s.cu(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}s.O7(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),s.O7(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=s.HH(this.gl,2===(0,n.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===(0,n.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2(),r=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,r),r}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===(0,n.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){let e=this.gl,t=this.getQueryTimerExtensionWebGL2();e.endQuery(t.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await n.D5U.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,(0,n.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,(0,n.OBj)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){let t=this.gl,r=t.getQueryParameter(e,t.QUERY_RESULT);return r/1e6}{let t=this.getQueryTimerExtensionWebGL1(),r=t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT);return r/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){let t=this.gl,r=this.getQueryTimerExtensionWebGL2(),n=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),n&&!this.disjoint}{let t=this.getQueryTimerExtensionWebGL1(),r=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=function(e){let t=0;for(;t<e.length;++t){let r=e[t]();if(!r)break}return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){let r;this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||("setTimeoutCustom"in(0,n.OBj)().platform&&(r=(0,n.OBj)().platform.setTimeoutCustom.bind((0,n.OBj)().platform)),n.D5U.repeatedTry(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,r))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),s.JG(this.gl,e,this.framebuffer),this.debug&&s.cu(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(s.JG(this.gl,this.outputTexture,this.framebuffer),this.debug&&s.cu(this.gl)):s.ax(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let r=t();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,t,r){this.throwIfDisposed();let n=this.gl;s.JG(n,e,this.framebuffer),this.debug&&s.cu(n),this.outputTexture=e,s.O7(n,()=>n.viewport(0,0,t,r)),s.O7(n,()=>n.scissor(0,0,t,r))}setOutputMatrixWriteRegionDriver(e,t,r,n){this.throwIfDisposed(),s.O7(this.gl,()=>this.gl.scissor(e,t,r,n))}throwIfDisposed(){if(this.disposed)throw Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw Error("No GPU program is currently set.")}}},58257:function(e,t,r){"use strict";r.d(t,{C9:function(){return useShapeUniforms},IJ:function(){return compileProgram},Yv:function(){return getUniformLocations},_s:function(){return runProgram},mi:function(){return makeShaderKey}});var n=r(82783),a=r(10058),i=r(67818);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function compileProgram(e,t,r,o){let s=r.map((e,r)=>{let n={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(n.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[r],shapeInfo:n}}),u=s.map(e=>e.shapeInfo),l={logicalShape:o.shape,texShape:o.texData.texShape,isUniform:!1,isPacked:o.texData.isPacked,flatOffset:null},d=a.Vm(s,l,t),h=(0,i.xc)(e.gl,d),c=e.createProgram(h);return(0,n.OBj)().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:h,source:d,webGLProgram:c,inShapeInfos:u,outShapeInfo:l,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(c),Object.assign({program:t,fragmentShader:h,source:d,webGLProgram:c,inShapeInfos:u,outShapeInfo:l},getUniformLocations(e,t,c)))}function getUniformLocations(e,t,r){let a,i,o;let s=[],u=[],l=null,d=null;for(let a of(d=e.getUniformLocation(r,"NAN",!1),1===(0,n.OBj)().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(r,"INFINITY",!1)),t.variableNames)){let n={name:a,uniform:e.getUniformLocation(r,a,!1),offset:e.getUniformLocation(r,`offset${a}`,!1)};t.enableShapeUniforms&&(n.shape=e.getUniformLocation(r,`${a}Shape`,!1),n.texShape=e.getUniformLocation(r,`${a}TexShape`,!1)),s.push(n)}if(t.enableShapeUniforms&&(a=e.getUniformLocation(r,"outShape",!1),o=e.getUniformLocation(r,"outShapeStrides",!1),i=e.getUniformLocation(r,"outTexShape",!1)),t.customUniforms)for(let n of t.customUniforms)u.push(e.getUniformLocation(r,n.name,!1));return{variablesLocations:s,customUniformLocations:u,infLoc:l,nanLoc:d,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:i}}function validateBinaryAndProgram(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((e,r)=>{let a=e.logicalShape,i=t[r],o=i.shape;if(!n.D5U.arraysEqual(a,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${a} and ${o} must match`);if(e.isUniform&&i.isUniform)return;let s=e.texShape,u=i.isUniform?null:i.texData.texShape;if(!n.D5U.arraysEqual(s,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${s} and ${u} must match`)})}function runProgram(e,t,r,i,o){t.program.enableShapeUniforms||(validateBinaryAndProgram(t.inShapeInfos,r),validateBinaryAndProgram([t.outShapeInfo],[i]));let s=i.texData.texture,u=i.texData.texShape;i.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,u[0],u[1]):e.setOutputMatrixTexture(s.texture,u[0],u[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===(0,n.OBj)().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let i=0;i<r.length;++i){let o=r[i],{uniform:s,offset:u,shape:l,texShape:d}=t.variablesLocations[i];if(l){let{uniformShape:r}=a.Tt(t.program.packedInputs,o.shape,o.texData.texShape);switch(r.length){case 1:e.gl.uniform1iv(l,new Int32Array(r));break;case 2:e.gl.uniform2iv(l,new Int32Array(r));break;case 3:e.gl.uniform3iv(l,new Int32Array(r));break;case 4:e.gl.uniform4iv(l,new Int32Array(r))}}if(d&&e.gl.uniform2i(d,o.texData.texShape[0],o.texData.texShape[1]),null!=s){if(o.isUniform){if(2>n.D5U.sizeFromShape(o.shape))e.gl.uniform1f(s,o.uniformValues[0]);else{let t=o.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(s,t)}continue}null!=o.texData.slice&&null!=u&&e.gl.uniform1i(u,o.texData.slice.flatOffset),e.setInputMatrixTexture(o.texData.texture.texture,s,i)}}let l=t.outShapeLocation;if(l)switch(i.shape.length){case 1:e.gl.uniform1iv(l,new Int32Array(i.shape));break;case 2:e.gl.uniform2iv(l,new Int32Array(i.shape));break;case 3:e.gl.uniform3iv(l,new Int32Array(i.shape));break;case 4:e.gl.uniform4iv(l,new Int32Array(i.shape))}if(t.outShapeStridesLocation){let r=n.D5U.computeStrides(i.shape);switch(i.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(r));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(r));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(r))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,i.texData.texShape[0],i.texData.texShape[1]),t.program.customUniforms&&o)for(let r=0;r<t.program.customUniforms.length;++r){let n=t.program.customUniforms[r],a=t.customUniformLocations[r],i=o[r];if("float"===n.type)e.gl.uniform1fv(a,i);else if("vec2"===n.type)e.gl.uniform2fv(a,i);else if("vec3"===n.type)e.gl.uniform3fv(a,i);else if("vec4"===n.type)e.gl.uniform4fv(a,i);else if("int"===n.type)e.gl.uniform1iv(a,i);else if("ivec2"===n.type)e.gl.uniform2iv(a,i);else if("ivec3"===n.type)e.gl.uniform3iv(a,i);else if("ivec4"===n.type)e.gl.uniform4iv(a,i);else throw Error(`uniform type ${n.type} is not supported yet.`)}e.executeProgram()}function makeShaderKey(e,t,r){let i="";t.concat(r).forEach(t=>{let o=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){let s=t.texData.texShape,{useSqueezeShape:u,uniformShape:l,keptDims:d}=a.Tt(e.packedInputs,t.shape,s),h="",c="",p="";if(1===l.length&&e.packedInputs){let e=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];h=`${e[0]>1}_${e[1]>1}`}else if(2!==l.length||e.packedInputs){if(l.length>2&&!e.packedInputs){let e=n.D5U.computeStrides(l);p=`${e[0]===s[1]}_${e[e.length-1]===s[1]}`}}else c=`${l[0]>1}_${l[1]>1}`;let f=t.shape.length,m=2===l.length&&n.D5U.arraysEqual(t.shape,s),g=1===n.D5U.sizeFromShape(t.shape),y=n.backend_util.getBroadcastDims(t.shape,r.shape),x=!e.packedInputs&&f===r.shape.length&&n.D5U.arraysEqual(s,r.texData.texShape),b=e.packedInputs||l.length>2?"":`${s[0]>1}_${s[1]>1}`;i+=`${f}_${x}_${u?d:""}_${l.length}_${g}_${y}_${m}_${h}_${c}_${p}_${b}_${o}`}else{let e=t.isUniform?"uniform":t.texData.texShape;i+=`${t.shape}_${e}_${o}`}});let o=e.userCode;return e.constructor.name+("_"+i+"_"+o)+`${(0,n.OBj)().getNumber("WEBGL_VERSION")}`}function useShapeUniforms(e){return(0,n.OBj)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}},25121:function(e,t,r){"use strict";r.d(t,{A8:function(){return createBufferFromOutputTexture},AD:function(){return downloadPackedMatrixFromBuffer},BQ:function(){return createUnsignedBytesMatrixTexture},Cs:function(){return createFloat16PackedMatrixTexture},HC:function(){return downloadByteEncodedFloatMatrixFromOutputTexture},Hb:function(){return createIndexBuffer},Hc:function(){return bindVertexProgramAttributeStreams},Jj:function(){return createVertexShader},NQ:function(){return getInternalFormatForUnsignedBytesMatrixTexture},P1:function(){return downloadMatrixFromPackedOutputTexture},Qr:function(){return uploadPixelDataToTexture},T2:function(){return createFloat32MatrixTexture},Uk:function(){return uploadDenseMatrixToTexture},Y3:function(){return createVertexBuffer},cU:function(){return createPackedMatrixTexture},ez:function(){return downloadFloat32MatrixFromBuffer},gl:function(){return getInternalFormatForPackedMatrixTexture},hf:function(){return getInternalFormatForFloat16PackedMatrixTexture},iN:function(){return createFloat16MatrixTexture},m8:function(){return getInternalFormatForFloat16MatrixTexture},q3:function(){return getInternalFormatForFloat32MatrixTexture}});var n=r(82783),a=r(12011),i=r(15389),o=r(67818);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function createVertexShader(e){let t=(0,a.A)(),r=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return o.Jj(e,r)}function createVertexBuffer(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return o.ED(e,t)}function createIndexBuffer(e){let t=new Uint16Array([0,1,2,2,1,3]);return o.mZ(e,t)}function createAndConfigureTexture(e,t,r,a,i,s){o.b6(t,r);let u=o.cU(e),l=e.TEXTURE_2D;return o.O7(e,()=>e.bindTexture(l,u)),o.O7(e,()=>e.texParameteri(l,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),o.O7(e,()=>e.texParameteri(l,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),o.O7(e,()=>e.texParameteri(l,e.TEXTURE_MIN_FILTER,e.NEAREST)),o.O7(e,()=>e.texParameteri(l,e.TEXTURE_MAG_FILTER,e.NEAREST)),1===(0,n.OBj)().getNumber("WEBGL_VERSION")?o.O7(e,()=>e.texImage2D(l,0,a,t,r,0,i,s,null)):o.O7(e,()=>e.texStorage2D(l,1,a,t,r)),o.O7(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:u,texShape:[r,t]}}function getInternalFormatForFloat32MatrixTexture(e){return e.internalFormatFloat}function createFloat32MatrixTexture(e,t,r,n){let[a,o]=i.kk(t,r);return createAndConfigureTexture(e,a,o,getInternalFormatForFloat32MatrixTexture(n),n.textureFormatFloat,e.FLOAT)}function getInternalFormatForFloat16MatrixTexture(e){return e.internalFormatHalfFloat}function createFloat16MatrixTexture(e,t,r,n){let[a,o]=i.kk(t,r);return createAndConfigureTexture(e,a,o,getInternalFormatForFloat16MatrixTexture(n),n.textureFormatFloat,n.textureTypeHalfFloat)}function getInternalFormatForUnsignedBytesMatrixTexture(e){return e.downloadTextureFormat}function createUnsignedBytesMatrixTexture(e,t,r,n){let[a,o]=i.kk(t,r);return createAndConfigureTexture(e,a,o,getInternalFormatForUnsignedBytesMatrixTexture(n),e.RGBA,e.UNSIGNED_BYTE)}function getInternalFormatForPackedMatrixTexture(e){return e.internalFormatPackedFloat}function createPackedMatrixTexture(e,t,r,n){let[a,o]=i.qe(t,r);return createAndConfigureTexture(e,a,o,getInternalFormatForPackedMatrixTexture(n),e.RGBA,e.FLOAT)}function getInternalFormatForFloat16PackedMatrixTexture(e){return e.internalFormatPackedHalfFloat}function createFloat16PackedMatrixTexture(e,t,r,n){let[a,o]=i.qe(t,r);return createAndConfigureTexture(e,a,o,getInternalFormatForFloat16PackedMatrixTexture(n),e.RGBA,n.textureTypeHalfFloat)}function bindVertexProgramAttributeStreams(e,t,r){o.O7(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r));let n=o.sb(e,t,"clipSpacePos",r,3,20,0);return n&&o.sb(e,t,"uv",r,2,20,12)}function uploadDenseMatrixToTexture(e,t,r,a,i,s){let u,l,d;o.O7(e,()=>e.bindTexture(e.TEXTURE_2D,t)),i instanceof Uint8Array?(u=new Uint8Array(r*a*4),l=e.UNSIGNED_BYTE,d=e.RGBA):(u=new Float32Array(r*a*4),l=e.FLOAT,d=s.internalFormatPackedFloat),u.set(i),2===(0,n.OBj)().getNumber("WEBGL_VERSION")?o.O7(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,r,a,e.RGBA,l,u)):o.O7(e,()=>e.texImage2D(e.TEXTURE_2D,0,d,r,a,0,e.RGBA,l,u)),o.O7(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function uploadPixelDataToTexture(e,t,r){o.O7(e,()=>e.bindTexture(e.TEXTURE_2D,t)),r.data instanceof Uint8Array?2===(0,n.OBj)().getNumber("WEBGL_VERSION")?o.O7(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,r.width,r.height,e.RGBA,e.UNSIGNED_BYTE,r.data)):o.O7(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,r.width,r.height,0,e.RGBA,e.UNSIGNED_BYTE,r.data)):2===(0,n.OBj)().getNumber("WEBGL_VERSION")?o.O7(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,r)):o.O7(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,r)),o.O7(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function createBufferFromOutputTexture(e,t,r,n){let a=e.createBuffer();o.O7(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,a));let i=16*t*r;return o.O7(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,i,e.STREAM_READ)),o.O7(e,()=>e.readPixels(0,0,r,t,e.RGBA,e.FLOAT,0)),o.O7(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),a}function downloadFloat32MatrixFromBuffer(e,t,r){let n=new Float32Array(r);return e.bindBuffer(e.PIXEL_PACK_BUFFER,t),e.getBufferSubData(e.PIXEL_PACK_BUFFER,0,n),e.bindBuffer(e.PIXEL_PACK_BUFFER,null),n}function downloadByteEncodedFloatMatrixFromOutputTexture(e,t,r,n){let[a,s]=i.kk(t,r),u=new Uint8Array(i.yb(t*r,4));return o.O7(e,()=>e.readPixels(0,0,a,s,n.downloadTextureFormat,e.UNSIGNED_BYTE,u)),new Float32Array(u.buffer)}function downloadPackedMatrixFromBuffer(e,t,r,n,a,o,s,u){let l=new Float32Array(i.Se(o,s));return e.bindBuffer(e.PIXEL_PACK_BUFFER,t),e.getBufferSubData(e.PIXEL_PACK_BUFFER,0,l),e.bindBuffer(e.PIXEL_PACK_BUFFER,null),l}function downloadMatrixFromPackedOutputTexture(e,t,r){let n=new Float32Array(t*r*4);return o.O7(e,()=>e.readPixels(0,0,r,t,e.RGBA,e.FLOAT,n)),n}},80110:function(e,t,r){"use strict";let n;var a,i,o=r(82783),s=r(21469);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */o.C2$.isBrowser()&&(0,o.jqO)("webgl",()=>new s.QC,2);var u=r(58257);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let l=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;let BinaryOpProgram=class BinaryOpProgram{constructor(e,t,r){this.variableNames=["A","B"],this.outputShape=o.backend_util.assertAndGetBroadcastShape(t,r),this.enableShapeUniforms=(0,u.C9)(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};var d=r(4573),h=r(10058);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let c=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;let BinaryOpPackedProgram=class BinaryOpPackedProgram{constructor(e,t,r,n=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o.backend_util.assertAndGetBroadcastShape(t,r);let a=this.outputShape.length;this.enableShapeUniforms=(0,u.C9)(a);let i="";if(n){if(0===a||1===o.D5U.sizeFromShape(this.outputShape))i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else{let e=(0,h.kW)(a);if(i=`
          ${e} coords = getOutputCoords();
        `,1===a)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let e=(0,d.Ky)("coords",a);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${e[a-2]} + 1) >= outShape[${a} - 2];
            bool nextColOutOfBounds =
              (${e[a-1]} + 1) >= outShape[${a} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${e[a-2]} + 1) >= ${this.outputShape[a-2]};
            bool nextColOutOfBounds =
              (${e[a-1]} + 1) >= ${this.outputShape[a-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}}}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function identity(e){let{inputs:t,backend:r}=e,{x:n}=t;return r.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}let p={kernelName:o.iJz,backendName:"webgl",kernelFunc:identity};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function complex(e){let{inputs:t,backend:r}=e,{real:n,imag:a}=t,i=r.makeTensorInfo(n.shape,"complex64"),o=r.texData.get(i.dataId),s=identity({inputs:{x:n},backend:r}),u=identity({inputs:{x:a},backend:r});return o.complexTensorInfos={real:s,imag:u},i}let f={kernelName:o.Zz9,backendName:"webgl",kernelFunc:complex},m="return (a < 0.) ? b * a : a;",g=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`,y={kernelName:o.J$2,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{alpha:i}=n,s=r.makeTensorInfo([],"float32",o.D5U.createScalarValue(i,"float32")),u=(0,o.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(g,a.shape,s.shape):new BinaryOpProgram(m,a.shape,s.shape),l=r.runWebGLProgram(u,[a,s],"float32");return r.disposeIntermediateTensorInfo(s),l}},x="return (a < 0.) ? b * a : a;",b=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`,v={kernelName:o.o0g,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r}=e,{x:n,alpha:a}=t,i=(0,o.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(b,n.shape,a.shape):new BinaryOpProgram(x,n.shape,a.shape);return r.runWebGLProgram(i,[n,a],"float32")}};var w=r(13150),C=r(38595);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let S="if (isnan(x)) return x;";function unaryKernelFunc({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:r,dtype:n}){return({inputs:a,backend:i})=>{let s;let{x:u}=a,l=n||u.dtype;if(i.shouldExecuteOnCPU([u])&&null!=r){let e=i.texData.get(u.dataId),t=r(e.values,l);return i.makeTensorInfo(u.shape,l,t)}let d=(0,o.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t;return s=d?new C.cc(u.shape,t):new w.l(u.shape,e),i.runWebGLProgram(s,[u],l)}}function binaryKernelFunc({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:r=!1,supportsComplex:n=!1,cpuKernelImpl:a,dtype:i}){return({inputs:s,backend:u})=>{let l;let{a:d,b:h}=s;if(n&&"complex64"===d.dtype){let t=u.texData.get(d.dataId),r=u.texData.get(h.dataId),[n,a]=[[t.complexTensorInfos.real,r.complexTensorInfos.real],[t.complexTensorInfos.imag,r.complexTensorInfos.imag]].map(t=>{let[r,n]=t,a={dataId:r.dataId,dtype:r.dtype,shape:d.shape},i={dataId:n.dataId,dtype:n.dtype,shape:h.shape},s=new BinaryOpProgram(e,d.shape,h.shape);return u.runWebGLProgram(s,[a,i],(0,o.x8V)(r.dtype,n.dtype))}),i=complex({inputs:{real:n,imag:a},backend:u});return u.disposeIntermediateTensorInfo(n),u.disposeIntermediateTensorInfo(a),i}let c=i||(0,o.x8V)(d.dtype,h.dtype);if(("string"===d.dtype||"string"===h.dtype||u.shouldExecuteOnCPU([d,h]))&&null!=a){let e=u.texData.get(d.dataId).values,t=u.texData.get(h.dataId).values,r="string"===d.dtype?o.backend_util.fromUint8ToStringArray(e):e,n="string"===d.dtype?o.backend_util.fromUint8ToStringArray(t):t,[i,s]=a(d.shape,h.shape,r,n,c),l=u.makeTensorInfo(s,c),p=u.texData.get(l.dataId);return p.values=i,l}let p=(0,o.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t;return l=p?new BinaryOpPackedProgram(t,d.shape,h.shape,r):new BinaryOpProgram(e,d.shape,h.shape),u.runWebGLProgram(l,[d,h],c)}}function mapActivationToShaderProgram(e,t=!1){if("linear"===e)return t?C.t$:w.t$;if("relu"===e)return t?C.RX:w.RX;if("elu"===e)return t?C.Cv:w.Cv;if("relu6"===e)return t?C.eW:w.eW;if("prelu"===e)return t?b:x;if("leakyrelu"===e)return t?g:m;if("sigmoid"===e)return t?C.Tq:w.Tq;throw Error(`Activation ${e} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let MatMulPackedProgram=class MatMulPackedProgram{constructor(e,t,r,n=!1,a=!1,i=!1,o=null,s=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=(0,u.C9)(this.outputShape.length);let d=n?e[1]:e[2],h=Math.ceil(d/2),c=n?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],p=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],f="",m="";o&&(f=s?`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:l?`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:`vec4 activation(vec4 x) {
          ${o}
        }`,m="result = activation(result);"),i&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let g="rc.x",y="rc.x";e[0]<t[0]?g=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(y=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${f}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${g};
        int batchB = ${y};
        for (int i = 0; i < ${h}; i++) {
          vec4 a = getMatrixA(batchA, ${n?"i * 2, rc.y":"rc.y, i * 2"});
          vec4 b = getMatrixB(batchB, ${a?"rc.z, i * 2":"i * 2, rc.z"});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${c[0]} * ${p[0]});
          result += (${c[1]} * ${p[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${i?"result += getBiasAtOutCoords();":""}

        ${m}

        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let I={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};let BinaryOpComplexProgram=class BinaryOpComplexProgram{constructor(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=o.backend_util.assertAndGetBroadcastShape(t,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var k=r(48816);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let R="return a * b;";function multiply(e){let t;let{inputs:r,backend:n}=e,{a,b:i}=r,s=o.backend_util.upcastType(a.dtype,i.dtype);if("complex64"===a.dtype){let e=n.texData.get(a.dataId),t=n.texData.get(i.dataId),r=new BinaryOpComplexProgram(I.REAL,a.shape,i.shape),o=new BinaryOpComplexProgram(I.IMAG,a.shape,i.shape),s=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:i.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:i.shape}],u=n.runWebGLProgram(r,s,"float32"),l=n.runWebGLProgram(o,s,"float32"),d=complex({inputs:{real:u,imag:l},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(l),d}if(n.shouldExecuteOnCPU([a,i])){let e=n.texData.get(a.dataId),t=n.texData.get(i.dataId),[r,o]=(0,k.Th)(a.shape,i.shape,e.values,t.values,s),u=n.makeTensorInfo(o,s),l=n.texData.get(u.dataId);return l.values=r,u}return t=(0,o.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(R,a.shape,i.shape):new BinaryOpProgram(R,a.shape,i.shape),n.runWebGLProgram(t,[a,i],s)}let $={kernelName:o.wYn,backendName:"webgl",kernelFunc:multiply};var T=r(68588),D=r(67818);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function reshape(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{shape:i}=n,s=o.D5U.sizeFromShape(a.shape),u=o.D5U.inferFromImplicitShape(i,s),l=o.D5U.sizeFromShape(u);o.D5U.assert(s===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${a.shape}) has ${s} elements. The new shape and old shape must have the same number of elements.`);let d=r.texData.get(a.dataId);return!d.isPacked||(0,D.oT)(a.shape,u)||null!==d.texture&&(0,D.oT)(d.shape,u)?(r.incRef(a.dataId),{dataId:a.dataId,shape:u,dtype:a.dtype}):/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t,r){let n=[(0,D.Cp)(e.shape),...(0,D.W8)(e.shape)],a={dtype:e.dtype,shape:n,dataId:e.dataId},i=[(0,D.Cp)(t),...(0,D.W8)(t)],o=new T.v(i,n),s=[n],u=r.runWebGLProgram(o,[a],e.dtype,s,!0);return{dataId:u.dataId,shape:t,dtype:u.dtype}}(a,u,r)}let A={kernelName:o.HZH,backendName:"webgl",kernelFunc:reshape};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let MeanProgram=class MeanProgram{constructor(e,t){this.variableNames=["x"];let{windowSize:r,batchSize:n,inSize:a,outSize:i}=e;this.outputShape=[n,i];let s=4*Math.floor(r/4),u=r%4,l="sumValue += dot(values, ones);";if(null!=t){let e=1/t;l=`sumValue += dot(values * ${o.D5U.isInt(e)?e.toPrecision(2):e}, ones);`}let d="";a%r>0&&(d=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${s}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${s};
        if (${1===u}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${2===u}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${3===u}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ReduceProgram=class ReduceProgram{constructor(e,t){this.variableNames=["x"];let{windowSize:r,batchSize:n,inSize:a,outSize:i}=e;this.outputShape=[n,i];let o="0.0",s="";"prod"===t?o="1.0":"min"===t?(o="1.0 / 1e-20",s="min"):"max"===t&&(o="-1.0 / 1e-20",s="max");let u=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?u="sumValue":"prod"===t?u="prodValue":"all"===t?u="allValue":"any"===t&&(u="anyValue");let l=4*Math.floor(r/4),d=r%4,h=`
      if (${"sum"===t}) {
        sumValue += dot(values, ones);
      } else if (${"prod"===t}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${s}(values, minMaxValue);
        if (${"min"===t} || ${"max"===t}) {
          minMaxValue = ${s}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,c="vec4";"all"===t?(o="1.0",h=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,c="bvec4"):"any"===t&&(o="0.0",h=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,c="bvec4");let p="";a%r>0&&(p=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${o};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${o});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${l}; i += 4) {
          int inIdx = inOffset + i;
          ${c} values = ${c}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${h}
        }

        int inIdx = inOffset + ${l};
        if (${1===d}) {
          ${c} values = ${c}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${2===d}) {
          ${c} values = ${c}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${3===d}) {
          ${c} values = ${c}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${h}
        }
        setOutput(${u});
      }
    `}};function reduce(e,t,r,n){let a=/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t=[];for(;0===t.length||1!==t[t.length-1].outSize;){let r=t.length?t[t.length-1].outSize:e[1],n=o.backend_util.computeOptimalWindowSize(r);t.push({inSize:r,windowSize:n,outSize:Math.ceil(r/n)})}return t}(e.shape),i=e;for(let o=0;o<a.length;o++){let s,u;let{inSize:l,windowSize:d,outSize:h}=a[o];s="mean"===r?0===o?new MeanProgram({windowSize:d,inSize:l,batchSize:e.shape[0],outSize:h},l):new MeanProgram({windowSize:d,inSize:l,batchSize:e.shape[0],outSize:h}):new ReduceProgram({windowSize:d,inSize:l,batchSize:e.shape[0],outSize:h},r),u=i,i=n.runWebGLProgram(s,[i],t),u.dataId!==e.dataId&&n.disposeIntermediateTensorInfo(u)}return i}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TransposeProgram=class TransposeProgram{constructor(e,t){this.variableNames=["A"];let r=Array(e.length);for(let n=0;n<r.length;n++)r[n]=e[t[n]];this.outputShape=r,this.rank=r.length;let n=(0,h.kW)(this.rank),a=function(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let r=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],n=Array(t);for(let t=0;t<e.length;t++)n[e[t]]=r[t];return n.join()}(t);this.userCode=`
    void main() {
      ${n} resRC = getOutputCoords();
      setOutput(getA(${a}));
    }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TransposePackedProgram=class TransposePackedProgram{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let r=Array(e.length);for(let n=0;n<r.length;n++)r[n]=e[t[n]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let n=(0,h.kW)(this.rank),a=(0,d.k6)("rc",this.rank),i=Array(this.rank);for(let e=0;e<t.length;e++)i[t[e]]=a[e];let o=`vec2(${i.slice(-2).join()})`,s=`++${a[this.rank-1]} < ${r[this.rank-1]}`,u=`getChannel(getA(${i.join()}), ${o})`;this.userCode=`
    void main() {
      ${n} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${s}) {
        result[1] = ${u};
      }
      --${a[this.rank-1]};
      if(++${a[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${u};
        if(${s}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function transposeImpl(e,t,r){let n=(0,o.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new TransposePackedProgram(e.shape,t):new TransposeProgram(e.shape,t);return r.runWebGLProgram(n,[e],e.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sum(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:i,keepDims:s}=n;return(/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t,r,n){let a=e.shape.length,i=o.D5U.parseAxisParam(t,e.shape),s=i,u=o.backend_util.getAxesPermutation(s,a),l=null!=u,d=e;l&&(d=transposeImpl(e,u,n),s=o.backend_util.getInnerMostAxes(s.length,a)),o.backend_util.assertAxesAreInnerMostDims("sum",s,a);let[h,c]=o.backend_util.computeOutAndReduceShapes(d.shape,s),p=h;r&&(p=o.backend_util.expandShapeToKeepDim(h,i));let f=o.D5U.sizeFromShape(c),m=o.D5U.sizeFromShape(e.shape),g=m/f,y=reshape({inputs:{x:d},attrs:{shape:[g,f]},backend:n}),x=(0,o.z4k)(e.dtype),b=reduce(y,x,"sum",n),v=reshape({inputs:{x:b},attrs:{shape:p},backend:n});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),l&&n.disposeIntermediateTensorInfo(d),v}(a,i,s,r))}let P={kernelName:o.GBy,backendName:"webgl",kernelFunc:sum};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function transpose(e){let t;let{inputs:r,backend:n,attrs:a}=e,{x:i}=r,{perm:o}=a,s=i.shape.length,u=Array(s);for(let e=0;e<u.length;e++)u[e]=i.shape[o[e]];if(n.shouldExecuteOnCPU([i])){let e=n.texData.get(i.dataId),r=e.values,a=(0,k.Fv)(r,i.shape,i.dtype,o,u);t=n.makeTensorInfo(u,i.dtype);let s=n.texData.get(t.dataId);s.values=a}else t=transposeImpl(i,o,n);return t}let _={kernelName:o.G3Y,backendName:"webgl",kernelFunc:transpose};function batchMatMulImpl({a:e,b:t,transposeA:r,transposeB:n,backend:a,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:u=0,activation:l=null}){let d;let h=e.shape.length,c=t.shape.length,p=r?e.shape[h-2]:e.shape[h-1],f=n?t.shape[c-1]:t.shape[c-2],m=r?e.shape[h-1]:e.shape[h-2],g=n?t.shape[c-2]:t.shape[c-1],y=e.shape.slice(0,-2),x=t.shape.slice(0,-2),b=o.D5U.sizeFromShape(y),v=o.D5U.sizeFromShape(x),w=o.Jyw.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)),C=w.concat([m,g]);o.D5U.assert(p===f,()=>`Error in matMul: inner shapes (${p}) and (${f}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${r} and transposeB=${n} must match.`);let S=r?[b,p,m]:[b,m,p],I=n?[v,g,f]:[v,f,g],k=reshape({inputs:{x:e},backend:a,attrs:{shape:S}}),R=reshape({inputs:{x:t},backend:a,attrs:{shape:I}}),$=[k,R],T=Math.max(b,v),D=r?k.shape[1]:k.shape[2],A=null!=i,P=null!=s,_="leakyrelu"===l,N=null!=l?mapActivationToShaderProgram(l,!0):null,F=A||P||_||null!=N;if((1===m||1===g)&&D>1e3&&!1===F){let e=k,t=R;r&&(e=transpose({inputs:{x:k},backend:a,attrs:{perm:[0,2,1]}}),$.push(e)),n&&(t=transpose({inputs:{x:R},backend:a,attrs:{perm:[0,2,1]}}),$.push(t));let i=1!==g,o=1===g,s=e;i&&(s=reshape({inputs:{x:e},backend:a,attrs:{shape:[T,D,1]}}),$.push(s));let u=1===g?2:1,l=t;o&&(l=reshape({inputs:{x:t},backend:a,attrs:{shape:[T,1,D]}}),$.push(l));let h=multiply({inputs:{a:s,b:l},backend:a});d=sum({inputs:{x:h},backend:a,attrs:{axis:u,keepDims:!0}}),$.push(h)}else{let l=(0,o.x8V)(e.dtype,t.dtype),h=new MatMulPackedProgram(S,I,[T,m,g],r,n,A,N,P,_),c=[k,R];if(null!=i&&c.push(i),P&&c.push(s),_){let e=a.makeTensorInfo([],"float32",o.D5U.createScalarValue(u,"float32"));c.push(e),$.push(e)}d=a.runWebGLProgram(h,c,l)}let O=reshape({inputs:{x:d},backend:a,attrs:{shape:C}});for(let e of($.push(d),$))a.disposeIntermediateTensorInfo(e);return O}let N={kernelName:o.usg,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{a,b:i,bias:o,preluActivationWeights:s}=t,{transposeA:u,transposeB:l,activation:d,leakyreluAlpha:h}=n;return batchMatMulImpl({a,b:i,transposeA:u,transposeB:l,backend:r,bias:o,preluActivationWeights:s,leakyreluAlpha:h,activation:d})}},F="return abs(x);",O={kernelName:o.SYM,backendName:"webgl",kernelFunc:function(e){let t;let{inputs:r,backend:n}=e,{x:a}=r;if(n.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){let e=n.texData.get(a.dataId),t=(0,k.CJ)(e.values);return n.makeTensorInfo(a.shape,a.dtype,t)}return t=(0,o.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new C.cc(a.shape,F):new w.l(a.shape,F),n.runWebGLProgram(t,[a],a.dtype)}},B=w.D1+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,L=unaryKernelFunc({opSnippet:B}),M={kernelName:o.VGw,backendName:"webgl",kernelFunc:L},U=w.D1+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,z=unaryKernelFunc({opSnippet:U}),W={kernelName:o.SpW,backendName:"webgl",kernelFunc:z},V="return a + b;",G=binaryKernelFunc({opSnippet:V,packedOpSnippet:V,supportsComplex:!0,cpuKernelImpl:k.cK}),H={kernelName:o.mm_,backendName:"webgl",kernelFunc:G};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let AddNProgram=class AddNProgram{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);let r=[];this.variableNames.forEach(e=>{r.push(`float v${e} = get${e}AtOutCoords();`)});let n=this.variableNames.map(e=>`v${e}`).join(" + ");this.userCode=`
      void main() {
        ${r.join("\n        ")}

        float result = ${n};
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let AddNPackedProgram=class AddNPackedProgram{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);let r=[];this.variableNames.forEach(e=>{r.push(`vec4 v${e} = get${e}AtOutCoords();`)});let n=this.variableNames.map(e=>`v${e}`).join(" + ");this.userCode=`
      void main() {
        ${r.join("\n        ")}

        vec4 result = ${n};
        setOutput(result);
      }
    `}};let K={kernelName:o.Xze,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function addN(e){let{inputs:t,backend:r}=e;if(1===t.length)return identity({inputs:{x:t[0]},backend:r});if(t.length>(0,o.OBj)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let e=Math.floor(t.length/2),n=addN({inputs:t.slice(0,e),backend:r}),a=addN({inputs:t.slice(e),backend:r});return addN({inputs:[n,a],backend:r})}let n=t.map(e=>e.dtype).reduce((e,t)=>(0,o.x8V)(e,t)),a=t.map(e=>e.shape),i=(0,o.OBj)().getBool("WEBGL_PACK"),s=i?new AddNPackedProgram(t[0].shape,a):new AddNProgram(t[0].shape,a);return r.runWebGLProgram(s,t,n)}},j={kernelName:o.oT6,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t;let{inputs:r,backend:n,attrs:a}=e,{x:i}=r,{axis:s,keepDims:u}=a,l=i.shape.length,d=o.D5U.parseAxisParam(s,i.shape),h=d,c=o.backend_util.getAxesPermutation(h,l),p=i;null!=c&&(p=transpose({inputs:{x:i},backend:n,attrs:{perm:c}}),h=o.backend_util.getInnerMostAxes(h.length,l)),o.backend_util.assertAxesAreInnerMostDims("all",h,l);let[f,m]=o.backend_util.computeOutAndReduceShapes(p.shape,h),g=o.D5U.sizeFromShape(m),y=reshape({inputs:{x:p},backend:n,attrs:{shape:[-1,g]}}),x=reduce(y,y.dtype,"all",n);if(u){let e=o.backend_util.expandShapeToKeepDim(f,d);t=reshape({inputs:{x:x},backend:n,attrs:{shape:e}})}else t=reshape({inputs:{x:x},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(x),null!=c&&n.disposeIntermediateTensorInfo(p),t}},X={kernelName:o.IKK,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t;let{inputs:r,backend:n,attrs:a}=e,{x:i}=r,{axis:s,keepDims:u}=a,l=i.shape.length,d=o.D5U.parseAxisParam(s,i.shape),h=d,c=o.backend_util.getAxesPermutation(h,l),p=i;null!=c&&(p=transpose({inputs:{x:i},backend:n,attrs:{perm:c}}),h=o.backend_util.getInnerMostAxes(h.length,l)),o.backend_util.assertAxesAreInnerMostDims("any",h,l);let[f,m]=o.backend_util.computeOutAndReduceShapes(p.shape,h),g=o.D5U.sizeFromShape(m),y=reshape({inputs:{x:p},backend:n,attrs:{shape:[-1,g]}}),x=reduce(y,y.dtype,"any",n);if(u){let e=o.backend_util.expandShapeToKeepDim(f,d);t=reshape({inputs:{x:x},backend:n,attrs:{shape:e}})}else t=reshape({inputs:{x:x},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(x),null!=c&&n.disposeIntermediateTensorInfo(p),t}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ArgMinMaxProgram=class ArgMinMaxProgram{constructor(e,t,r){this.variableNames=["A"];let{windowSize:n,batchSize:a,outSize:i}=e;r||this.variableNames.push("bestIndicesA"),this.outputShape=[a,i],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${n}; i++) {
          int inIdx = ${r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};
          float candidate = getA(batch, inIdx);
          if (candidate ${"max"===t?">":"<"} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ArgMinMaxPackedProgram=class ArgMinMaxPackedProgram{constructor(e,t,r,n){let a,i;this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,o.D5U.assert(e.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);let s=e[e.length-1],u=Math.ceil(s/t);this.outputShape=e.slice(0,-1),u>1&&this.outputShape.push(u),n||this.variableNames.push("bestIndicesA");let l=this.outputShape,c=l.length,p=(0,h.kW)(c),f=(0,d.Ky)("coords",c);if(1===u){i=c+1;let e=(0,h.kW)(i);a=`
        ${e} sourceLocR = ${e}(${f.join()}, 0);
        ++${f[c-1]};
        ${e} sourceLocG = ${e}(${f.join()}, 0);
        ++${f[c-2]};
        ${e} sourceLocA = ${e}(${f.join()}, 0);
        --${f[c-1]};
        ${e} sourceLocB = ${e}(${f.join()}, 0);
        --${f[c-2]};`}else i=c,a=`
        ${p} sourceLocR = coords;
        ++${f[c-1]};
        ${p} sourceLocG = coords;
        ++${f[c-2]};
        ${p} sourceLocA = coords;
        --${f[c-1]};
        ${p} sourceLocB = coords;
        --${f[c-2]};`;let m=["x","y","z","w","u","v"].slice(0,i),g="."+m[i-1],y=m.map(e=>"int "+e),x=(0,d.Ky)("sourceLocR",i-1).concat("inIdx.r"),b=(0,d.Ky)("sourceLocG",i-1).concat("inIdx.g"),v=(0,d.Ky)("sourceLocB",i-1).concat("inIdx.b"),w=(0,d.Ky)("sourceLocA",i-1).concat("inIdx.a"),C=n?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${w.join()})));`,S=`vec4(
            getAChannel(${x.join()}),
            hasNextCol ? getAChannel(${b.join()}) : 0.,
            hasNextRow ? getAChannel(${v.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${w.join()}) : 0.)`,I=n?"":`
      float getBestIndicesAChannel(${y.join()}) {
        return getChannel(getBestIndicesA(${m.join()}),
                                          vec2(${m.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${y.join()}) {
        return getChannel(getA(${m.join()}),
                               vec2(${m.slice(-2).join()}));
      }
      ${I}
      void main() {
        ${p} coords = getOutputCoords();
        bool hasNextCol = ${f[c-1]} < ${l[c-1]-1};
        bool hasNextRow = ${f[c-2]} < ${l[c-2]-1};
        ${a}
        ivec4 srcIdx = ivec4(sourceLocR${g}, sourceLocG${g},
          sourceLocB${g}, sourceLocA${g}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${S};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${C}
          vec4 candidate = ${S};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${"max"===r?"greaterThan":"lessThan"}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function argMinMaxReduce(e,t,r,n){let a=[r];if(o.backend_util.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),a,t.shape.length),!(0,o.OBj)().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let r=[],i=e.texData.get(t.dataId),s=null!==i&&i.isPacked,u=t;s&&r.push(u=e.unpackTensor(t));let[l,d]=o.backend_util.computeOutAndReduceShapes(u.shape,a),h=o.D5U.sizeFromShape(d),c=reshape({inputs:{x:u},backend:e,attrs:{shape:[-1,h]}});r.push(c);let p=/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function argReduce(e,t,r,n=null){let a=t.shape[0],i=t.shape[1];null!=n&&(a=n.shape[0],i=n.shape[1]);let s=o.backend_util.computeOptimalWindowSize(i),u={windowSize:s,inSize:i,batchSize:a,outSize:Math.ceil(i/s)},l=new ArgMinMaxProgram(u,r,null==n),d=[t];null!=n&&d.push(n);let h=e.runWebGLProgram(l,d,"int32");if(1===h.shape[1])return h;let c=argReduce(e,t,r,h);return e.disposeIntermediateTensorInfo(h),c}(e,c,n);r.push(p);let f=reshape({inputs:{x:p},backend:e,attrs:{shape:l}});return r.forEach(t=>e.disposeIntermediateTensorInfo(t)),f}return function argReducePacked(e,t,r,n=null){let a=null!=n?n.shape:t.shape,i=a[a.length-1],s=o.backend_util.computeOptimalWindowSize(i),u=new ArgMinMaxPackedProgram(a,s,r,null==n),l=null==n?[t]:[t,n],d=e.runWebGLProgram(u,l,"int32");if(d.shape.length===t.shape.length){let n=argReducePacked(e,t,r,d);return e.disposeIntermediateTensorInfo(d),n}return d}(e,t,n)}let q={kernelName:o.sJF,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:i}=n,s=o.D5U.parseAxisParam(i,a.shape),u=o.backend_util.getAxesPermutation(s,a.shape.length),l=a,d=[];null!=u&&(d.push(l=transpose({inputs:{x:a},backend:r,attrs:{perm:u}})),s=o.backend_util.getInnerMostAxes(s.length,l.shape.length)),o.backend_util.assertAxesAreInnerMostDims("argMax",[s[0]],l.shape.length);let h=argMinMaxReduce(r,l,s[0],"max");return d.forEach(e=>r.disposeIntermediateTensorInfo(e)),h}},Y={kernelName:o.aJk,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:i}=n,s=o.D5U.parseAxisParam(i,a.shape),u=o.backend_util.getAxesPermutation(s,a.shape.length),l=a,d=[];null!=u&&(d.push(l=transpose({inputs:{x:a},backend:r,attrs:{perm:u}})),s=o.backend_util.getInnerMostAxes(s.length,l.shape.length)),o.backend_util.assertAxesAreInnerMostDims("argMin",[s[0]],l.shape.length);let h=argMinMaxReduce(r,l,s[0],"min");return d.forEach(e=>r.disposeIntermediateTensorInfo(e)),h}},Q=w.D1+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,Z=unaryKernelFunc({opSnippet:Q}),J={kernelName:o.M2y,backendName:"webgl",kernelFunc:Z},ee=w.D1+"return log(x + sqrt(x * x + 1.0));",et=unaryKernelFunc({opSnippet:ee}),er={kernelName:o.qw7,backendName:"webgl",kernelFunc:et},en=w.D1+`
  return atan(x);
`,ea=unaryKernelFunc({opSnippet:en}),ei={kernelName:o.jMg,backendName:"webgl",kernelFunc:ea},eo=l+`
  return atan(a, b);
`,es=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+c+`
  return result;
`,eu=binaryKernelFunc({opSnippet:eo,packedOpSnippet:es}),el={kernelName:o.QCc,backendName:"webgl",kernelFunc:eu},ed=w.D1+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,eh=unaryKernelFunc({opSnippet:ed}),ec={kernelName:o.Oyi,backendName:"webgl",kernelFunc:eh};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Pool2DProgram=class Pool2DProgram{constructor(e,t,r,n=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&r)throw Error("Cannot compute positions for average pool.");let i=e.filterWidth,o=e.strideHeight,s=e.strideWidth,u=e.dilationHeight,l=e.dilationWidth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,c=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;let f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,y="0.0";if(f||(y="-1.0 / 1e-20"),r){this.userCode=`
        const ivec2 strides = ivec2(${o}, ${s});
        const ivec2 pads = ivec2(${c}, ${p});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${d};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h};
                wC += ${l}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${n?a?m:g:`wR * ${h} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(x="avgValue / max(count, 1.0)");let b=4*Math.floor(i/4),v=i%4,w=`
      if (${f}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${s});
      const ivec2 pads = ivec2(${c}, ${p});
      const float initializationValue = ${y};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${y});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${d};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${b}; wC += 4) {
            int xC = xCCorner + wC * ${l};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              getValue(batch, xR, xC + 2 * ${l}, d),
              getValue(batch, xR, xC + 3 * ${l}, d)
            );

            ${w}
          }

          int xC = xCCorner + ${b};
          if (${1===v}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${w}
          } else if (${2===v}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              initializationValue,
              initializationValue
            );

            ${w}
          } else if (${3===v}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              getValue(batch, xR, xC + 2 * ${l}, d),
              initializationValue
            );

            ${w}
          }
        }
        setOutput(${x});
      }
    `}};let Pool3DProgram=class Pool3DProgram{constructor(e,t,r,n=!1,a=!1){if(this.variableNames=["x"],"avg"===t&&r)throw Error("Cannot compute positions for average pool.");let i=e.filterWidth,o=e.strideDepth,s=e.strideHeight,u=e.strideWidth,l=e.dilationDepth,d=e.dilationHeight,h=e.dilationWidth,c=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;let x="avg"===t,b="0.0";if(x||(b="-1.0 / 1e-20"),r){this.userCode=`
        const ivec3 strides =
            ivec3(${o}, ${s}, ${u});
        const ivec3 pads = ivec3(${m}, ${g}, ${y});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${c};
              wD += ${l}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${p};
                wR += ${d}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${f};
                  wC += ${h}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${n?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +
                      wR * ${f} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(v="avgValue / max(count, 1.0)");let w=4*Math.floor(i/4),C=i%4,S=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${o}, ${s}, ${u});
      const ivec3 pads = ivec3(${m}, ${g}, ${y});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${c};
            wD += ${l}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p};
            wR += ${d}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${w}; wC += 4) {
              int xC = xCCorner + wC * ${h};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                getValue(batch, xD, xR, xC + 3 * ${h}, ch)
              );

              ${S}
            }

            int xC = xCCorner + ${w};
            if (${1===C}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${S}
            } else if (${2===C}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                initializationValue,
                initializationValue
              );

              ${S}
            } else if (${3===C}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                initializationValue
              );

              ${S}
            }
          }
        }
        setOutput(${v});
      }
    `}};let ep={kernelName:o.JhU,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t;(0,D.HS)(a,"avgPool");let{filterSize:i,strides:s,pad:u,dimRoundingMode:l}=n;o.D5U.assert(o.backend_util.eitherStridesOrDilationsAreOne(s,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${s} and dilations '1'`);let d=o.backend_util.computePool2DInfo(a.shape,i,s,1,u,l);if(1===d.filterWidth&&1===d.filterHeight&&o.D5U.arraysEqual(d.inShape,d.outShape))return identity({inputs:{x:a},backend:r});let h=new Pool2DProgram(d,"avg",!1);return r.runWebGLProgram(h,[a],"float32")}},ef={kernelName:o._k9,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{filterSize:i,strides:s,pad:u,dimRoundingMode:l,dataFormat:d}=n,h=o.backend_util.computePool3DInfo(a.shape,i,s,[1,1,1],u,l,d),c=new Pool3DProgram(h,"avg",!1);return r.runWebGLProgram(c,[a],"float32")}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let AvgPool2DBackpropProgram=class AvgPool2DBackpropProgram{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,r=e.filterWidth,n=e.strideHeight,a=e.strideWidth,i=e.dilationHeight,o=e.dilationWidth,s=e.effectiveFilterHeight,u=e.effectiveFilterWidth,l=s-1-e.padInfo.top,d=u-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${l}, ${d});
      const float avgMultiplier = float(${1/(t*r)});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${o}) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}};let AvgPool3DBackpropProgram=class AvgPool3DBackpropProgram{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,r=e.filterHeight,n=e.filterWidth,a=e.strideDepth,i=e.strideHeight,o=e.strideWidth,s=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,d=e.effectiveFilterDepth,h=e.effectiveFilterHeight,c=e.effectiveFilterWidth,p=d-1-e.padInfo.front,f=h-1-e.padInfo.top,m=c-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${p}, ${f}, ${m});
      const float avgMultiplier = float(${1/(t*r*n)});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${a}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${h};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${l}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};let em={kernelName:o.IMb,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,input:i}=t,{filterSize:s,strides:u,pad:l,dimRoundingMode:d}=n,h=o.backend_util.computePool3DInfo(i.shape,s,u,[1,1,1],l,d),c=new AvgPool3DBackpropProgram(h);return r.runWebGLProgram(c,[a],i.dtype)}},eg={kernelName:o.ROF,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,input:i}=t;(0,D.HS)([a,i],"avgPoolGrad");let{filterSize:s,strides:u,pad:l}=n,d=o.backend_util.computePool2DInfo(i.shape,s,u,1,l),h=new AvgPool2DBackpropProgram(d);return r.runWebGLProgram(h,[a],i.dtype)}},ey={kernelName:o.XLW,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{a,b:i}=t,{transposeA:o,transposeB:s}=n;return batchMatMulImpl({a,b:i,transposeA:o,transposeB:s,backend:r})}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let BatchNormProgram=class BatchNormProgram{constructor(e,t,r,n,a,i){this.outputShape=[],this.variableNames=["x","mean","variance"],o.backend_util.assertAndGetBroadcastShape(e,t),o.backend_util.assertAndGetBroadcastShape(e,r);let s="0.0";null!=n&&(o.backend_util.assertAndGetBroadcastShape(e,n),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");let u="1.0";null!=a&&(o.backend_util.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${s};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let BatchNormPackedProgram=class BatchNormPackedProgram{constructor(e,t,r,n,a,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],o.backend_util.assertAndGetBroadcastShape(e,t),o.backend_util.assertAndGetBroadcastShape(e,r);let s="vec4(0.0)";null!=n&&(o.backend_util.assertAndGetBroadcastShape(e,n),this.variableNames.push("offset"),s="getOffsetAtOutCoords()");let u="vec4(1.0)";null!=a&&(o.backend_util.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${s};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}};let ex={kernelName:o.sHE,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:r})=>{let{x:n,mean:a,variance:i,offset:s,scale:u}=e;o.D5U.assert(a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),o.D5U.assert(null==s||a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),o.D5U.assert(null==u||a.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=r;null==l&&(l=.001);let d=[n,a,i],h=null;null!=s&&(h=s.shape,d.push(s));let c=null;null!=u&&(c=u.shape,d.push(u));let p=(0,o.OBj)().getBool("WEBGL_PACK_NORMALIZATION")?new BatchNormPackedProgram(n.shape,a.shape,i.shape,h,c,l):new BatchNormProgram(n.shape,a.shape,i.shape,h,c,l),f=t.runWebGLProgram(p,d,d[0].dtype);return f}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SliceProgram=class SliceProgram{constructor(e){let t;this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let r=(0,h.kW)(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=function(e){if(1===e)return"sourceLoc";if(e<=6)return eb.slice(0,e).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank),a=e.map((e,t)=>`sourceLoc.${eb[t]} = start[${t}] + coords.${eb[t]};`);t=`
        ${r} sourceLoc;
        ${r} coords = getOutputCoords();
        ${a.join("\n")}
      `,this.userCode=`
      void main() {
        ${t}
        setOutput(getSource(${n}));
      }
    `}};let eb=["x","y","z","w","u","v"];/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SlicePackedProgram=class SlicePackedProgram{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=(0,h.kW)(this.rank),r=(0,d.Ky)("coords",this.rank),n=(0,d.Ky)("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":`vec2(${n.slice(-2).join()})`,i=`getChannel(getSource(${n.join()}), ${a})`,o=`
      result.x = ${i};
      if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
        ++${n[this.rank-1]};
        result.y = ${i};
        --${n[this.rank-1]};
      }
    `,s=1===this.rank?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${e[this.rank-2]}) {
        ++${n[this.rank-2]};
        result.z = ${i};
        if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
          ++${n[this.rank-1]};
          result.w = ${i};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((e,t)=>`start[${t}]`).join()});`:e.map((e,t)=>`${n[t]} = ${r[t]} + start[${t}];`).join("\n");this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${o}
        ${s}
        setOutput(result);
      }
    `}};function slice(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{begin:i,size:s}=n,[u,l]=o.kuN.parseSliceParams(a,i,s);if(o.kuN.assertParamsValid(a,u,l),0===o.D5U.sizeFromShape(l))return r.makeTensorInfo(l,a.dtype,[]);if(r.shouldExecuteOnCPU([a])||"string"===a.dtype){let e=r.texData.get(a.dataId),t=(0,k.nT)(e.values,u,l,a.shape,a.dtype);return r.makeTensorInfo(l,a.dtype,t)}let{isPacked:d}=r.texData.get(a.dataId),h=o.kuN.isSliceContinous(a.shape,u,l);if(d||!h){let e=(0,o.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new SlicePackedProgram(l):new SliceProgram(l),t=[u];return r.runWebGLProgram(e,[a],a.dtype,t)}return r.uploadToGPU(a.dataId),/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t,r,n){let a=n.texData.get(e.dataId),i=n.makeTensorInfo(r,e.dtype),s=n.texData.get(i.dataId);Object.assign(s,a),s.refCount=1,s.shape=r,s.dtype=e.dtype;let u=o.kuN.computeFlatOffset(t,o.D5U.computeStrides(e.shape));a.slice&&(u+=a.slice.flatOffset),s.slice={flatOffset:u,origDataId:a.slice&&a.slice.origDataId||e.dataId};let l=n.dataRefCount.get(s.slice.origDataId)||1;return n.dataRefCount.set(s.slice.origDataId,l+1),i}(a,u,l,r)}let ev={kernelName:o.p2w,backendName:"webgl",kernelFunc:slice},ew={kernelName:o.zws,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{blockShape:i,crops:s}=n;o.D5U.assert(a.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let u=i.reduce((e,t)=>e*t),l=o.backend_util.getReshaped(a.shape,i,u),d=o.backend_util.getPermuted(l.length,i.length),h=o.backend_util.getReshapedPermuted(a.shape,i,u),c=o.backend_util.getSliceBeginCoords(s,i.length),p=o.backend_util.getSliceSize(h,s,i.length),f=[],m=reshape({inputs:{x:a},backend:r,attrs:{shape:l}}),g=transpose({inputs:{x:m},backend:r,attrs:{perm:d}}),y=reshape({inputs:{x:g},backend:r,attrs:{shape:h}}),x=slice({inputs:{x:y},backend:r,attrs:{begin:c,size:p}});return f.push(m),f.push(g),f.push(y),f.forEach(e=>r.disposeIntermediateTensorInfo(e)),x}},eC={kernelName:o.zvY,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,weights:i}=t,{size:o}=n,s=r.readSync(a.dataId),u=r.readSync(i.dataId),l=(0,k.qO)(s,u,i.dtype,i.shape,o);return r.makeTensorInfo([o],i.dtype,l)}},eS=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,eI=`
  return float(int(a.r) & int(b.r));
`,ek={kernelName:o.hCO,backendName:"webgl",kernelFunc:function(e){let t;let{inputs:r,backend:n}=e,{a,b:i}=r,s=(0,o.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS"),u=(0,o.OBj)().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([a,i])||1===u){let e=n.texData.get(a.dataId).values,t=n.texData.get(i.dataId).values,[r,o]=(0,k.XM)(a.shape,i.shape,e,t,a.dtype),s=n.makeTensorInfo(o,a.dtype),u=n.texData.get(s.dataId);return u.values=r,s}return t=s?new BinaryOpPackedProgram(eS,a.shape,i.shape,!1):new BinaryOpProgram(eI,a.shape,i.shape),n.runWebGLProgram(t,[a,i],a.dtype)}},eR={kernelName:o.eEB,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r}=e,{s0:n,s1:a}=t,i=r.readSync(n.dataId),s=r.readSync(a.dataId),u=o.backend_util.assertAndGetBroadcastShape(Array.from(i),Array.from(s));return r.makeTensorInfo([u.length],"int32",Int32Array.from(u))}},e$=binaryKernelFunc({opSnippet:"return float(a != b);",cpuKernelImpl:k.cZ,dtype:"bool"}),eT={kernelName:o.yQU,backendName:"webgl",kernelFunc:e$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function real(e){let{inputs:t,backend:r}=e,{input:n}=t,a=r.texData.get(n.dataId);return identity({inputs:{x:a.complexTensorInfos.real},backend:r})}let eD={kernelName:o.xJR,backendName:"webgl",kernelFunc:real},eE={kernelName:o.RFZ,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cast(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{dtype:i}=n;if("complex64"===i){if("complex64"===a.dtype)return identity({inputs:{x:a},backend:r});let e=o.lls(a.shape),t=cast({inputs:{x:a},backend:r,attrs:{dtype:"float32"}}),n=complex({inputs:{real:t,imag:e},backend:r});return e.dispose(),r.disposeIntermediateTensorInfo(t),n}if("complex64"===a.dtype){let e=real({inputs:{input:a},backend:r}),t=cast({inputs:{x:e},backend:r,attrs:{dtype:i}});return r.disposeIntermediateTensorInfo(e),t}if(!o.D5U.hasEncodingLoss(a.dtype,i)){let e=identity({inputs:{x:a},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(r.shouldExecuteOnCPU([a])){let e=r.texData.get(a.dataId).values,[t,n,o]=(0,k.cm)(e,a.shape,a.dtype,i);return r.makeTensorInfo(t,n,o)}if("int32"===i)return function(e,t){let r=new w.l(e.shape,"return float(int(x));"),n=t.runWebGLProgram(r,[e],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}(a,r);if("bool"===i){let e=r.makeTensorInfo([],"bool",o.D5U.getTypedArrayFromDType("bool",1)),t=e$({inputs:{a:a,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw Error(`Error in Cast: failed to cast ${a.dtype} to ${i}`)}},eA="return ceil(x);",eP=unaryKernelFunc({opSnippet:eA,packedOpSnippet:eA,cpuKernelImpl:k.pk}),e_={kernelName:o.gJX,backendName:"webgl",kernelFunc:eP};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ClipProgram=class ClipProgram{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ClipPackedProgram=class ClipPackedProgram{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};let eN={kernelName:o.xnO,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t;let{inputs:r,backend:n,attrs:a}=e,{x:i}=r,{clipValueMin:s,clipValueMax:u}=a;t=(0,o.OBj)().getBool("WEBGL_PACK_CLIP")?new ClipPackedProgram(i.shape):new ClipProgram(i.shape);let l=[[s],[u]];return n.runWebGLProgram(t,[i],i.dtype,l)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ComplexAbsProgram=class ComplexAbsProgram{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function makeComplexComponentTensorInfo(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}let eF={kernelName:o.yj2,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r}=e,{x:n}=t,a=r.texData.get(n.dataId),i=new ComplexAbsProgram(n.shape),o=[makeComplexComponentTensorInfo(n,a.complexTensorInfos.real),makeComplexComponentTensorInfo(n,a.complexTensorInfos.imag)];return r.runWebGLProgram(i,o,o[0].dtype)}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ConcatProgram=class ConcatProgram{constructor(e){this.outputShape=[],this.outputShape=o.backend_util.computeOutShape(e,1),this.variableNames=e.map((e,t)=>`T${t}`);let t=Array(e.length-1);t[0]=e[0][1];for(let r=1;r<t.length;r++)t[r]=t[r-1]+e[r][1];let r=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<t.length;e++){let n=t[e-1];r.push(`else if (yC < ${t[e]}) setOutput(getT${e}(yR, yC-${n}));`)}let n=t.length,a=t[t.length-1];r.push(`else setOutput(getT${n}(yR, yC-${a}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join("\n        ")}
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ConcatPackedProgram=class ConcatPackedProgram{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=o.backend_util.computeOutShape(e,t);let r=this.outputShape,n=r.length,a=(0,h.kW)(n),i=(0,d.Ky)("coords",n),s=["x","y","z","w","u","v"].slice(0,n);this.variableNames=e.map((e,t)=>`T${t}`);let u=Array(e.length-1);u[0]=e[0][t];for(let r=1;r<u.length;r++)u[r]=u[r-1]+e[r][t];let l=s[t],c=s.slice(-2),p=s.join(),f=`if (${l} < ${u[0]}) {
        return getChannel(
            getT0(${p}), vec2(${c.join()}));
        }`;for(let e=1;e<u.length;e++){let t=u[e-1];f+=`
        if (${l} < ${u[e]}  && ${l} >= ${u[e-1]}) {
          return getChannel(
            getT${e}(${shiftedChannels(s,l,t)}),
            vec2(${shiftedChannels(c,l,t)}));
        }`}let m=u.length,g=u[u.length-1];f+=`
        return getChannel(
          getT${m}(${shiftedChannels(s,l,g)}),
          vec2(${shiftedChannels(c,l,g)}));`,this.userCode=`
      float getValue(${s.map(e=>"int "+e)}) {
        ${f}
      }

      void main() {
        ${a} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[n-1]} = ${i[n-1]} + 1;
        if (${i[n-1]} < ${r[n-1]}) {
          result.g = getValue(${i});
        }

        ${i[n-2]} = ${i[n-2]} + 1;
        if (${i[n-2]} < ${r[n-2]}) {
          result.a = getValue(${i});
        }

        ${i[n-1]} = ${i[n-1]} - 1;
        if (${i[n-2]} < ${r[n-2]} &&
            ${i[n-1]} < ${r[n-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}};function shiftedChannels(e,t,r){let n=e.indexOf(t),a=e.map((e,t)=>t===n?`${e} - ${r}`:e);return a.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function imag(e){let{inputs:t,backend:r}=e,{input:n}=t,a=r.texData.get(n.dataId);return identity({inputs:{x:a.complexTensorInfos.imag},backend:r})}let eO={kernelName:o.J_u,backendName:"webgl",kernelFunc:imag};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function concat(e){let{inputs:t,backend:r,attrs:n}=e,{axis:a}=n,i=o.D5U.parseAxisParam(a,t[0].shape)[0],s=t.map(e=>e.shape);o.backend_util.assertParamsConsistent(s,i);let u=o.backend_util.computeOutShape(t.map(e=>e.shape),i);if(0===o.D5U.sizeFromShape(u))return r.makeTensorInfo(u,t[0].dtype,[]);let l=t.filter(e=>o.D5U.sizeFromShape(e.shape)>0);return 1===l.length?identity({inputs:{x:l[0]},backend:r}):/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function concatImpl(e,t,r){let n=e[0].dtype;if("complex64"===n){let n=e.map(e=>real({inputs:{input:e},backend:r})),a=e.map(e=>imag({inputs:{input:e},backend:r})),i=concatImpl(n,t,r),o=concatImpl(a,t,r),s=complex({inputs:{real:i,imag:o},backend:r});return n.forEach(e=>r.disposeIntermediateTensorInfo(e)),a.forEach(e=>r.disposeIntermediateTensorInfo(e)),r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),s}let a=r.shouldExecuteOnCPU(e);if("string"===n&&(a=!0),a){let a=e.map(e=>{let n=o.D5U.sizeFromShape(e.shape.slice(t));return reshape({inputs:{x:e},backend:r,attrs:{shape:[-1,n]}})}),i=a.map(e=>({vals:r.readSync(e.dataId),shape:e.shape})),s=o.backend_util.computeOutShape(a.map(e=>e.shape),1),u=1===a[0].shape[0],l=(0,k.n7)(i,s,n,u),d=o.backend_util.computeOutShape(e.map(e=>e.shape),t),h=r.makeTensorInfo(d,n,l);return a.forEach(e=>r.disposeIntermediateTensorInfo(e)),h}let i=e.filter(e=>o.D5U.sizeFromShape(e.shape)>0),s=(0,o.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(1===i.length){let t=s?new w.l(e[0].shape,w.bl):new C.cc(e[0].shape,w.bl);return r.runWebGLProgram(t,e,n)}let u=(0,o.OBj)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>u){let e=[];for(let n=0;n<i.length;n+=u){let a=i.slice(n,n+u);e.push(concatImpl(a,t,r))}let n=concatImpl(e,t,r);for(let t of e)r.disposeIntermediateTensorInfo(t);return n}if(s){let e=new ConcatPackedProgram(i.map(e=>e.shape),t);return r.runWebGLProgram(e,i,n)}let{tensors2D:l,outShape:d}=function(e,t,r){let n=o.backend_util.computeOutShape(e.map(e=>e.shape),t),a=e.map(e=>reshape({inputs:{x:e},attrs:{shape:[-1,o.D5U.sizeFromShape(e.shape.slice(t))]},backend:r}));return{tensors2D:a,outShape:n}}(i,t,r),h=new ConcatProgram(l.map(e=>e.shape)),c=r.runWebGLProgram(h,l,n);l.forEach(e=>r.disposeIntermediateTensorInfo(e));let p=reshape({inputs:{x:c},attrs:{shape:d},backend:r});return r.disposeIntermediateTensorInfo(c),p}(l,i,r)}let eB={kernelName:o.Eh3,backendName:"webgl",kernelFunc:concat};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Conv2DProgram=class Conv2DProgram{constructor(e,t=!1,r=null,n=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let i=e.padInfo.top,o=e.padInfo.left,s=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,d=e.dilationWidth,h=e.filterHeight,c=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g="",y="";r&&(g=n?`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:a?`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:`
          float activation(float x) {
            ${r}
          }
        `,y="result = activation(result);"),t&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${g}

      const ivec2 strides = ivec2(${s}, ${u});
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${m?3:1}];

        ivec2 xRCCorner =
            ivec2(coords[${m?1:2}], coords[${m?2:3}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${h}; wR++) {
          int xR = xRCorner + wR * ${l};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${c}; wC++) {
            int xC = xCCorner + wC * ${d};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${p}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${1===f}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${p}) *
                    getW(wR, wC, ${p}, d2);
              } else {
                dotProd +=
                    getX(batch, ${p}, xR, xC) *
                    getW(wR, wC, ${p}, d2);
              }

            } else if (${2===f}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${3===f}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2),
                getW(wR, wC, ${p} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1),
                  getX(batch, xR, xC, ${p} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC),
                  getX(batch, ${p} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${t?"result += getBiasAtOutCoords();":""}
        ${y}
        setOutput(result);
      }
    `}};let Conv3DProgram=class Conv3DProgram{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,r=e.padInfo.top,n=e.padInfo.left,a=e.strideDepth,i=e.strideHeight,o=e.strideWidth,s=e.dilationDepth,u=e.dilationHeight,l=e.dilationWidth,d=e.filterDepth,h=e.filterHeight,c=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${a}, ${i}, ${o});
      const ivec3 pads = ivec3(${t}, ${r}, ${n});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${d}; wF++) {
          int xF = xFCorner + wF * ${s};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${c}; wC++) {
              int xC = xCCorner + wC * ${l};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${p}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${1===f}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${p}) *
                  getW(wF, wR, wC, ${p}, d2);
              } else if (${2===f}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${3===f}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1),
                  getX(batch, xF, xR, xC, ${p} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2),
                  getW(wF, wR, wC, ${p} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Conv2DPackedProgram=class Conv2DPackedProgram{constructor(e,t=!1,r=null,n=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=(0,u.C9)(this.outputShape.length);let i=e.padInfo.left,s=e.strideWidth,l=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,c=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let e=0;e<h;e++)c+=`
           vec4 xTexelC${2*e};
           int xTexelC${2*e}Ready;
           vec4 xTexelC${2*e+1};
           int xTexelC${2*e+1}Ready;
           vec4 xC${e};`;c+=`
     for (int r = 0; r < ${d}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let e=0;e<h;e++)c+=`
           xTexelC${2*e} = vec4(0.0);
           xTexelC${2*e}Ready = 0;
           xTexelC${2*e+1} = vec4(0.0);
           xTexelC${2*e+1}Ready = 0;
           xC${e} = vec4(0.0);`;c+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let t=0;t<(h+1)/2;t++){let r=2*t;if(c+=`
           xC = xCCorner + ${r*l};
           `,1===s){if(r<h&&(i%2==1?(c+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${r}Ready == 0) {
                   xTexelC${r} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${r}.zw = vec2(0.0);
                   }
                   xTexelC${r}Ready = 1;
                 }
               `,1===l&&r>0?c+=`
                 xC${r} = vec4(xTexelC${r-2}.zw, xTexelC${r}.xy);
                 `:c+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${r} = vec4(previous.zw, xTexelC${r}.xy);
                   } else {
                     xC${r} = vec4(0.0, 0.0, xTexelC${r}.xy);
                   }
                   `):c+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${r}Ready == 0) {
                   xTexelC${r} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${r}.zw = vec2(0.0);
                   }
                   xTexelC${r}Ready = 1;
                 }

                 xC${r} = xTexelC${r};
                 `,r+1<h)){let e=i%2==0?o.D5U.nearestLargerEven(l):l;l%2==0&&i%2==1||l%2!=0&&i%2!=1?(c+=`
                   xCOffset = xC + imod(pads[1], 2) + ${e};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${r+1}Ready == 0) {
                     xTexelC${r+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${r+1}.zw = vec2(0.0);
                     }
                     xTexelC${r+1}Ready = 1;
                   }
                   `,l>1?c+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${r+1} = vec4(previous.zw, xTexelC${r+1}.xy);
                     } else {
                      xC${r+1} = vec4(0.0, 0.0, xTexelC${r+1}.xy);
                     }
                     `:c+=`
                     xC${r+1} = vec4(xTexelC${r}.zw, xTexelC${r+1}.xy);
                     `):1===e?c+=`
                     xC${r+1} = xTexelC${r};
                     `:c+=`
                     xCOffset = xC + ${e};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${r+1}Ready == 0) {
                       xTexelC${r+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${r+1}.zw = vec2(0.0);
                       }
                       xTexelC${r+1}Ready = 1;
                     }

                     xC${r+1} = xTexelC${r+1};
                     `}}else r<h&&(i%2==1?(c+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${r}Ready == 0) {
                   xTexelC${r} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${r}.zw = vec2(0.0);
                   }
                   xTexelC${r}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${r+1}Ready == 0) {
                   xTexelC${r+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${r+1}.zw = vec2(0.0);
                   }
                   xTexelC${r+1}Ready = 1;
                 }

                 xC${r} = vec4(xTexelC${r}.zw, xTexelC${r+1}.zw);
               `,r+1<h&&(c+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${r+1} = vec4(xTexelC${r+1}.xy, final.xy);
                 `)):(c+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${r}Ready == 0) {
                   xTexelC${r} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${r}.zw = vec2(0.0);
                   }
                   xTexelC${r}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${r+1}Ready == 0) {
                   xTexelC${r+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${r+1}.zw = vec2(0.);
                   }
                   xTexelC${r+1}Ready = 1;
                 }

                 xC${r} = vec4(
                   xTexelC${r}.xy, xTexelC${r+1}.xy);
               `,r+1<h&&(c+=`
                   xC${r+1} = vec4(xTexelC${r}.zw, xTexelC${r+1}.zw);
                 `)));r<h&&(c+=`
             wTexel = getW(r, ${r}, d1, d2);
             dotProd += xC${r}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${r}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,r+1<h&&(c+=`
               wTexel = getW(r, ${r+1}, d1, d2);
               dotProd += xC${r+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${r+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}c+=`
     }
   
     }
   
     }
   `;let p="",f="";r&&(p=n?`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:a?`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:`vec4 activation(vec4 x) {
           ${r}
         }`,f="result = activation(result);"),t&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${c}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${t?"result += getBiasAtOutCoords();":""}
         ${f}
         setOutput(result);
       }
     `}};var eL=r(12011);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Im2ColPackedProgram=class Im2ColPackedProgram{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=(0,u.C9)(this.outputShape.length);let{dataFormat:r}=t,n=(0,eL.A)(),a="channelsLast"===r,i=a?1:2,o=a?2:3,s=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,l="";for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)l+=`
          blockIndex = rc.z + ${t};
          pos = rc.y + ${e};

          ${s}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${a}) {
                  innerDims = vec2(d1, ch);
                  result[${2*e+t}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${2*e+t}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${n.output} = result;
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getShapeForBatchMatMul(e,t){let r=e.length;return r>=3?t?[...e.slice(0,-3),e[r-3]*e[r-2],e[r-1]]:[...e.slice(0,-3),e[r-3],e[r-2]*e[r-1]]:!t&&1===r&&e[0]>1?[e[0],1]:null}function conv2dByMatMul({x:e,filter:t,convInfo:r,backend:n,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:s=0,activation:u=null}){let l;let d=e.shape,h=n.texData.get(e.dataId),c=r.inChannels,p=d[0]*d[1]*d[2],f=r.outChannels,m="channelsLast"===r.dataFormat,g=[];if(null!=i){let e=getShapeForBatchMatMul(i.shape,m);null!=e&&(i=reshape({inputs:{x:i},backend:n,attrs:{shape:e}}),g.push(i))}if(null!=a){let e=getShapeForBatchMatMul(a.shape,m);null!=e&&(a=reshape({inputs:{x:a},backend:n,attrs:{shape:e}}),g.push(a))}let y=!((1===p||1===f)&&c>1e3)&&h.isPacked&&m&&null!=h.texture&&d[2]%2!=0&&o.D5U.arraysEqual(h.shape.slice(-3),d.slice(-3));if(y){let c=d[0]*d[1]*(d[2]+1),p={dataId:e.dataId,shape:[1,c,r.inChannels],dtype:e.dtype},f=h.shape;h.shape=h.shape.slice(),h.shape[h.shape.length-2]++,o.D5U.assert(D.oT(h.shape,p.shape),()=>`packed reshape ${h.shape} to ${p.shape} isn't free`);let m=reshape({inputs:{x:t},backend:n,attrs:{shape:[1,r.inChannels,r.outChannels]}});g.push(m);let y=batchMatMulImpl({a:p,b:m,backend:n,transposeA:!1,transposeB:!1,bias:a,activation:u,preluActivationWeights:i,leakyreluAlpha:s}),x=n.texData.get(y.dataId);o.D5U.assert(x.isPacked,()=>"batchMatMul result is expected to be packed"),h.shape=f,x.shape=r.outShape,(l=identity({inputs:{x:y},backend:n})).shape=r.outShape,g.push(y)}else{let o=r.outHeight*r.outWidth,d=reshape({inputs:{x:e},backend:n,attrs:{shape:m?[r.batchSize,o,r.inChannels]:[r.batchSize,r.inChannels,o]}}),h=reshape({inputs:{x:t},backend:n,attrs:{shape:[1,r.inChannels,r.outChannels]}}),c=batchMatMulImpl({a:m?d:h,b:m?h:d,transposeA:!m,transposeB:!1,backend:n,bias:a,activation:u,preluActivationWeights:i,leakyreluAlpha:s});l=reshape({inputs:{x:c},backend:n,attrs:{shape:r.outShape}}),g.push(d),g.push(h),g.push(c)}for(let e of g)n.disposeIntermediateTensorInfo(e);return l}function conv2dWithIm2Row({x:e,filter:t,convInfo:r,backend:n,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:s=0,activation:u=null}){let{filterWidth:l,filterHeight:d,inChannels:h,outWidth:c,outHeight:p,dataFormat:f}=r,m="channelsLast"===f,g=l*d*h,y=p*c,x=[r.batchSize,g,y],b=[];if(null!=i){let e=getShapeForBatchMatMul(i.shape,m);null!=e&&(i=reshape({inputs:{x:i},backend:n,attrs:{shape:e}}),b.push(i))}if(null!=a){let e=getShapeForBatchMatMul(a.shape,m);null!=e&&(a=reshape({inputs:{x:a},backend:n,attrs:{shape:e}}),b.push(a))}let v=reshape({inputs:{x:t},backend:n,attrs:{shape:[1,g,o.D5U.sizeFromShape(t.shape)/g]}});b.push(v);let w=new Im2ColPackedProgram(x,r),C=[e.shape,[r.padInfo.top,r.padInfo.left],[r.strideHeight,r.strideWidth],[r.dilationHeight,r.dilationWidth],[r.inChannels],[r.filterWidth*r.inChannels],[r.outWidth]],S=n.runWebGLProgram(w,[e],"float32",C),I=reshape({inputs:{x:S},backend:n,attrs:{shape:x}});b.push(S),b.push(I);let k=null!=a,R=null!=i,$="leakyrelu"===u,T=u?mapActivationToShaderProgram(u,!0):null,D=new MatMulPackedProgram(m?I.shape:v.shape,m?v.shape:I.shape,m?[r.batchSize,y,r.outChannels]:[r.batchSize,r.outChannels,y],!0,!1,k,T,R,$),A=m?[I,v]:[v,I];if(a&&A.push(a),R&&A.push(i),$){let e=n.makeTensorInfo([],"float32",o.D5U.createScalarValue(s,"float32"));A.push(e),b.push(e)}let P=n.runWebGLProgram(D,A,"float32"),_=reshape({inputs:{x:P},backend:n,attrs:{shape:r.outShape}});for(let e of(b.push(P),b))n.disposeIntermediateTensorInfo(e);return _}let eM={kernelName:o.mhS,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t;let{inputs:r,backend:n,attrs:a}=e,{x:i,filter:s}=r,{strides:u,pad:l,dataFormat:d,dilations:h,dimRoundingMode:c}=a,p=o.backend_util.convertConv2DDataFormat(d),f=o.backend_util.computeConv2DInfo(i.shape,s.shape,u,h,l,c,!1,p);if(1===f.filterHeight&&1===f.filterWidth&&1===f.dilationHeight&&1===f.dilationWidth&&1===f.strideHeight&&1===f.strideWidth&&("SAME"===f.padInfo.type||"VALID"===f.padInfo.type))t=conv2dByMatMul({x:i,filter:s,convInfo:f,backend:n});else if(f.strideWidth<=2&&"channelsLast"===p&&(0,o.OBj)().getBool("WEBGL_EXP_CONV")){let e=new Conv2DPackedProgram(f),r=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];t=n.runWebGLProgram(e,[i,s],"float32",r)}else if((0,o.OBj)().getBool("WEBGL_CONV_IM2COL"))t=conv2dWithIm2Row({x:i,filter:s,convInfo:f,backend:n});else{let e=new Conv2DProgram(f);t=n.runWebGLProgram(e,[i,s],"float32")}let m=reshape({inputs:{x:t},backend:n,attrs:{shape:f.outShape}});return n.disposeIntermediateTensorInfo(t),m}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Conv2DDerFilterProgram=class Conv2DDerFilterProgram{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,r=e.strideWidth,n=e.padInfo.top,a=e.padInfo.left,i="channelsLast"===e.dataFormat;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${n};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${i?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}};let Conv2DDerInputProgram=class Conv2DDerInputProgram{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,r=e.filterWidth,n=e.strideHeight,a=e.strideWidth,i="channelsLast"===e.dataFormat,o=t-1-e.padInfo.top,s=r-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${s});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${i?3:1}];

        ivec2 dyCorner = ivec2(coords[${i?1:2}], coords[${i?2:3}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}};let Conv3DDerFilterProgram=class Conv3DDerFilterProgram{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,r=e.strideHeight,n=e.strideWidth,a=e.padInfo.front,i=e.padInfo.top,o=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${a};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${i};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${n} - ${o};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};let Conv3DDerInputProgram=class Conv3DDerInputProgram{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,r=e.filterHeight,n=e.filterWidth,a=e.strideDepth,i=e.strideHeight,o=e.strideWidth,s=t-1-e.padInfo.front,u=r-1-e.padInfo.top,l=n-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${s}, ${u}, ${l});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${a}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${n}; wC++) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${n} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};let eU={kernelName:o.wUP,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,dy:i}=t,{strides:s,pad:u,dataFormat:l,dimRoundingMode:d,filterShape:h}=n,c=o.backend_util.convertConv2DDataFormat(l),p=o.backend_util.computeConv2DInfo(a.shape,h,s,1,u,d,!1,c),f=new Conv2DDerFilterProgram(p);return r.runWebGLProgram(f,[a,i],"float32")}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Conv2DDerInputPackedProgram=class Conv2DDerInputPackedProgram{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=(0,u.C9)(this.outputShape.length);let t=e.filterHeight,r=e.filterWidth,n=t-1-e.padInfo.top,a=r-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${n}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}};let ez={kernelName:o.wm,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,filter:i}=t,{inputShape:s,strides:u,pad:l,dataFormat:d,dimRoundingMode:h}=n,c=o.backend_util.convertConv2DDataFormat(d),p=o.backend_util.computeConv2DInfo(s,i.shape,u,1,l,h,!1,c);if((0,o.OBj)().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===c){let e=[[p.strideHeight,p.strideWidth]],t=new Conv2DDerInputPackedProgram(p);return r.runWebGLProgram(t,[a,i],"float32",e)}{let e=new Conv2DDerInputProgram(p);return r.runWebGLProgram(e,[a,i],"float32")}}},eW={kernelName:o.x12,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,filter:i}=t,{strides:s,pad:u,dilations:l}=n,d=o.backend_util.computeConv3DInfo(a.shape,i.shape,s,l,u),h=new Conv3DProgram(d);return r.runWebGLProgram(h,[a,i],"float32")}},eV={kernelName:o.o2y,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,dy:i}=t,{strides:s,pad:u,filterShape:l}=n,d=o.backend_util.computeConv3DInfo(a.shape,l,s,1,u),h=new Conv3DDerFilterProgram(d);return r.runWebGLProgram(h,[a,i],"float32")}},eG={kernelName:o.ik2,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,filter:i}=t,{pad:s,strides:u,inputShape:l}=n,d=o.backend_util.computeConv3DInfo(l,i.shape,u,1,s),h=new Conv3DDerInputProgram(d);return r.runWebGLProgram(h,[a,i],"float32")}},eH=S+`
  return cos(x);
`,eK=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${c}
  return result;
`,ej=unaryKernelFunc({opSnippet:eH,packedOpSnippet:eK}),eX={kernelName:o.mc4,backendName:"webgl",kernelFunc:ej},eq=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,eY=unaryKernelFunc({opSnippet:eq}),eQ={kernelName:o.TR1,backendName:"webgl",kernelFunc:eY};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let CropAndResizeProgram=class CropAndResizeProgram{constructor(e,t,r,n,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[i,o,s,u]=e,[l]=t,[d,h]=r;this.outputShape=[l,d,h,u];let[c,p]=[`${o-1}.0`,`${s-1}.0`],[f,m,g]=d>1?[`${(o-1)/(d-1)}`,"(y2-y1) * height_ratio",`y1*${c} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${c}`],[y,x,b]=h>1?[`${(s-1)/(h-1)}`,"(x2-x1) * width_ratio",`x1*${p} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${p}`];this.userCode=`
      const float height_ratio = float(${f});
      const float width_ratio = float(${y});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${m};
        float width_scale = ${x};

        float in_y = ${g};
        if( in_y < 0.0 || in_y > ${c} ) {
          setOutput(float(${a}));
          return;
        }
        float in_x = ${b};
        if( in_x < 0.0 || in_x > ${p} ) {
          setOutput(float(${a}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${"bilinear"===n?1:0} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};let eZ={kernelName:o.VcC,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:r,attrs:n}=e,{image:a,boxes:i,boxInd:o}=t,{cropSize:s,method:u,extrapolationValue:l}=n,d=new CropAndResizeProgram(a.shape,i.shape,s,u,l);return r.runWebGLProgram(d,[a,i,o],"float32")}};(a=i||(i={})).Prod="*",a.Sum="+";let CumProgram=class CumProgram{constructor(e,t,r,n){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let a=this.outputShape.length,o=this.op===i.Prod?"1.0":"0.0",s=r?o:`getX(${cum_gpu_getCoords(a,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1],l="",d="";r?(l=n?`end != ${u-1}`:"end != 0",d=n?"end + 1":"end - 1"):(l=n?`end + pow2 < ${u}`:"end >= pow2",d=n?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${(0,h.kW)(a)} coords = getOutputCoords();
        int end = ${getFinalCoord(a,"coords",this.op)};
        float val = ${s};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${d};
          ${getFinalCoord(a,"coords",this.op)} = idx;
          val ${this.op}= getX(${cum_gpu_getCoords(a,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function cum_gpu_getCoords(e,t,r){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative ${r} for rank ${e} is not yet supported`)}function getFinalCoord(e,t,r){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative ${r} for rank ${e} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cumImpl(e,t,r,n,a,i){let s=t.shape.length,u=o.backend_util.getAxesPermutation([n],s),l=t;null!=u&&(l=transpose({inputs:{x:t},backend:r,attrs:{perm:u}}));let d=o.backend_util.getInnerMostAxes(1,s)[0];if(d!==s-1)throw Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${n}`);let h=l.shape[d],c=identity({inputs:{x:l},backend:r});for(let t=0;t<=Math.ceil(Math.log2(h))-1;t++){let n=new CumProgram(e,l.shape,!1,i),a=[[t]],o=c;c=r.runWebGLProgram(n,[c],c.dtype,a),r.disposeIntermediateTensorInfo(o)}if(a){let t=new CumProgram(e,l.shape,a,i),n=c;c=r.runWebGLProgram(t,[c],c.dtype),r.disposeIntermediateTensorInfo(n)}if(null!=u){let e=o.backend_util.getUndoAxesPermutation(u),t=transpose({inputs:{x:c},backend:r,attrs:{perm:e}});return r.disposeIntermediateTensorInfo(c),r.disposeIntermediateTensorInfo(l),t}return c}let eJ={kernelName:o.Byc,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:o,exclusive:s,reverse:u}=n;return cumImpl(i.Prod,a,r,o,s,u)}},e0={kernelName:o.iHb,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:o,exclusive:s,reverse:u}=n;return cumImpl(i.Sum,a,r,o,s,u)}},e1={kernelName:o.QRR,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,weights:i}=t,{size:o,binaryOutput:s}=n;if(1===a.shape.length){let e=r.readSync(a.dataId),t=r.readSync(i.dataId),n=(0,k.qO)(e,t,i.dtype,i.shape,o);return r.makeTensorInfo([o],i.dtype,n)}if(2===a.shape.length){let e=r.bufferSync(a),t=r.bufferSync(i),n=(0,k.cx)(e,t,o,s);return r.makeTensorInfo(n.shape,i.dtype,n.values)}throw Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DepthToSpaceProgram=class DepthToSpaceProgram{constructor(e,t,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};let e2={kernelName:o.T0n,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{blockSize:i,dataFormat:o}=n,s=a.shape[0],u="NHWC"===o?a.shape[1]:a.shape[2],l="NHWC"===o?a.shape[2]:a.shape[3],d="NHWC"===o?a.shape[3]:a.shape[1],h=u*i,c=l*i,p=d/(i*i),f="NHWC"===o?[s,h,c,p]:[s,p,h,c],m=new DepthToSpaceProgram(f,i,o);return r.runWebGLProgram(m,[a],a.dtype)}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DepthwiseConv2DProgram=class DepthwiseConv2DProgram{constructor(e,t=!1,r=null,n=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=(0,u.C9)(this.outputShape.length);let i=e.filterHeight,o=e.filterWidth,s=e.outChannels/e.inChannels,l="",d="";r&&(l=n?`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:a?`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:`
          float activation(float x) {
            ${r}
          }
        `,d="result = activation(result);"),t&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${s};
        int q = d2 - d1 * ${s};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${o}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${t?"result += getBiasAtOutCoords();":""}
        ${d}
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DepthwiseConvPacked2DProgram=class DepthwiseConvPacked2DProgram{constructor(e,t=!1,r=null,n=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=(0,u.C9)(this.outputShape.length);let i=e.outChannels/e.inChannels,s=e.padInfo.left,l=e.strideWidth,d=e.dilationWidth,h=e.filterHeight,c=e.filterWidth,p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let e=0;e<c;e++)p+=`
          vec4 xTexelC${2*e};
          int xTexelC${2*e}Ready;
          vec4 xTexelC${2*e+1};
          int xTexelC${2*e+1}Ready;
          vec4 xC${e};`;p+=`
    for (int r = 0; r < ${h}; r++) {
      `;for(let e=0;e<c;e++)p+=`
          xTexelC${2*e} = vec4(0.0);
          xTexelC${2*e}Ready = 0;
          xTexelC${2*e+1} = vec4(0.0);
          xTexelC${2*e+1}Ready = 0;
          xC${e} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let e=0;e<(c+1)/2;e++){let t=2*e;if(p+=`
          xC = xCCorner + ${t*d};
          `,1===l){if(t<c&&(s%2==1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {
                  xTexelC${t} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${t}.zw = vec2(0.0);
                  }
                  xTexelC${t}Ready = 1;
                }
              `,1===d&&t>0?p+=`
                xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${t} = vec4(previous.zw, xTexelC${t}.xy);
                  } else {
                    xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {
                  xTexelC${t} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${t}.zw = vec2(0.0);
                  }
                  xTexelC${t}Ready = 1;
                }

                xC${t} = xTexelC${t};
                `,t+1<c)){let e=s%2==0?o.D5U.nearestLargerEven(d):d;d%2==0&&s%2==1||d%2!=0&&s%2!=1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${e};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {
                    xTexelC${t+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${t+1}.zw = vec2(0.0);
                    }
                    xTexelC${t+1}Ready = 1;
                  }
                  `,d>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);
                    } else {
                     xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);
                    }
                    `:p+=`
                    xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);
                    `):1===e?p+=`
                    xC${t+1} = xTexelC${t};
                    `:p+=`
                    xCOffset = xC + ${e};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {
                      xTexelC${t+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${t+1}.zw = vec2(0.0);
                      }
                      xTexelC${t+1}Ready = 1;
                    }

                    xC${t+1} = xTexelC${t+1};
                    `}}else t<c&&(s%2==1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {
                  xTexelC${t} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${t}.zw = vec2(0.0);
                  }
                  xTexelC${t}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {
                  xTexelC${t+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${t+1}.zw = vec2(0.0);
                  }
                  xTexelC${t+1}Ready = 1;
                }

                xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);
              `,t+1<c&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {
                  xTexelC${t} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${t}.zw = vec2(0.0);
                  }
                  xTexelC${t}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {
                  xTexelC${t+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${t+1}.zw = vec2(0.);
                  }
                  xTexelC${t+1}Ready = 1;
                }

                xC${t} = vec4(
                  xTexelC${t}.xy, xTexelC${t+1}.xy);
              `,t+1<c&&(p+=`
                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);
                `)));t<c&&(p+=`
            wTexel = getW(r, ${t}, d1, q);
            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);
          `,t+1<c&&(p+=`
              wTexel = getW(r, ${t+1}, d1, q);
              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  
      }
    `;let f="",m="";r&&(f=n?`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:a?`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:`vec4 activation(vec4 x) {
          ${r}
        }`,m="result = activation(result);"),t&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${t?"result += getBiasAtOutCoords();":""}
        ${m}
        setOutput(result);
      }
    `}};let e3={kernelName:o.cie,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t;let{inputs:r,backend:n,attrs:a}=e,{x:i,filter:s}=r,{strides:u,pad:l,dilations:d,dimRoundingMode:h}=a,c=d;null==c&&(c=[1,1]),o.D5U.assert(o.backend_util.eitherStridesOrDilationsAreOne(u,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${c}'`);let p=o.backend_util.computeConv2DInfo(i.shape,s.shape,u,c,l,h,!0);t=(0,o.OBj)().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels==1?new DepthwiseConvPacked2DProgram(p):new DepthwiseConv2DProgram(p);let f=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];return n.runWebGLProgram(t,[i,s],"float32",f)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DepthwiseConv2DDerFilterProgram=class DepthwiseConv2DDerFilterProgram{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,r=e.strideWidth,n=e.padInfo.top,a=e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${n};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}};let DepthwiseConv2DDerInputProgram=class DepthwiseConv2DDerInputProgram{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,r=e.filterWidth,n=e.strideHeight,a=e.strideWidth,i=t-1-e.padInfo.top,o=r-1-e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${s}; dm++) {
              int d2 = d1 * ${s} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};let e4={kernelName:o.sL$,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,dy:i}=t,{strides:s,dilations:u,pad:l,dimRoundingMode:d,filterShape:h}=n,c=o.backend_util.computeConv2DInfo(a.shape,h,s,u,l,d,!0),p=new DepthwiseConv2DDerFilterProgram(c);return r.runWebGLProgram(p,[a,i],"float32")}},e5={kernelName:o.y7R,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,filter:i}=t,{strides:s,dilations:u,pad:l,dimRoundingMode:d,inputShape:h}=n,c=o.backend_util.computeConv2DInfo(h,i.shape,s,u,l,d,!0),p=new DepthwiseConv2DDerInputProgram(c);return r.runWebGLProgram(p,[a,i],"float32")}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DiagProgram=class DiagProgram{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};let e6={kernelName:o.$w,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r}=e,{x:n}=t,a=[...n.shape,...n.shape],i=o.D5U.sizeFromShape(n.shape),s=reshape({inputs:{x:n},backend:r,attrs:{shape:[i]}}),u=new DiagProgram(i),l=r.runWebGLProgram(u,[s],s.dtype),d=reshape({inputs:{x:l},backend:r,attrs:{shape:a}});return r.disposeIntermediateTensorInfo(s),r.disposeIntermediateTensorInfo(l),d}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Dilation2DProgram=class Dilation2DProgram{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:r,padInfo:n,strideHeight:a,strideWidth:i,filterHeight:o,filterWidth:s,dilationHeight:u,dilationWidth:l}=e,{top:d,left:h}=n;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${i});
      const ivec2 pads = ivec2(${d}, ${h});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${o}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${s}; w++) {
              int wIn = wBeg + w * ${l};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};let e8={kernelName:o.p4S,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t;let{inputs:r,backend:n,attrs:a}=e,{x:i,filter:s}=r,{strides:u,pad:l,dilations:d}=a,h=o.backend_util.computeDilation2DInfo(i.shape,s.shape,u,l,"NHWC",d),c=new Dilation2DProgram(h);t=n.runWebGLProgram(c,[i,s],"float32");let p=reshape({inputs:{x:t},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(t),p}},e7={kernelName:o.$g6,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{equation:a}=n,{allDims:i,summedDims:s,idDims:u}=o.backend_util.decodeEinsumEquation(a,t.length);o.backend_util.checkEinsumDimSizes(i.length,u,t);let{path:l,steps:d}=o.backend_util.getEinsumComputePath(s,u),h=d.length,c=null,p=i.length,f=[];for(let e=0;e<h;++e){for(let n of d[e]){let e;let{permutationIndices:a,expandDims:i}=o.backend_util.getEinsumPermutation(p,u[n]);o.backend_util.isIdentityPermutation(a)?e=t[n]:(e=transpose({inputs:{x:t[n]},backend:r,attrs:{perm:a}}),f.push(e));let s=e.shape.slice();for(let e=0;e<i.length;++e)s.splice(i[e],0,1);o.D5U.arraysEqual(e.shape,s)||(e=reshape({inputs:{x:e},backend:r,attrs:{shape:s}}),f.push(e)),null===c?c=e:(c=multiply({inputs:{a:e,b:c},backend:r}),f.push(c))}e<h-1&&(l[e]>=0&&(c=sum({inputs:{x:c},backend:r,attrs:{axis:l[e]-(i.length-p),keepDims:!1}}),f.push(c)),p--)}for(let e of f)e!==c&&r.disposeIntermediateTensorInfo(e);return c}},e9=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,te=unaryKernelFunc({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:e9}),tt={kernelName:o.SX0,backendName:"webgl",kernelFunc:te},tr=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,tn={kernelName:o.HEU,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:r}=e,{dy:n,y:a}=t,i=(0,o.OBj)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new BinaryOpPackedProgram(tr,n.shape,a.shape):new BinaryOpProgram("return (b >= 0.0) ? a : a * (b + 1.0);",n.shape,a.shape);return r.runWebGLProgram(i,[n,a],n.dtype)}},ta=`
  return vec4(equal(a, b));
`,ti=binaryKernelFunc({opSnippet:"return float(a == b);",packedOpSnippet:ta,dtype:"bool",cpuKernelImpl:k.gv}),to={kernelName:o.hdR,backendName:"webgl",kernelFunc:ti},ts=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${o.backend_util.ERF_P};
  float a1 = ${o.backend_util.ERF_A1};
  float a2 = ${o.backend_util.ERF_A2};
  float a3 = ${o.backend_util.ERF_A3};
  float a4 = ${o.backend_util.ERF_A4};
  float a5 = ${o.backend_util.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,tu=unaryKernelFunc({opSnippet:ts}),tl={kernelName:o.Omj,backendName:"webgl",kernelFunc:tu},td=S+`
  return exp(x);
`,th=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,tc=unaryKernelFunc({opSnippet:td,packedOpSnippet:th,cpuKernelImpl:k.aX,dtype:"float32"}),tp={kernelName:o.NEP,backendName:"webgl",kernelFunc:tc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function expandDims(e){let{inputs:t,attrs:r,backend:n}=e,{dim:a}=r,{input:i}=t,s=i.shape.length,u=i.shape.slice(),l=a;return a<0&&(o.D5U.assert(-(s+1)<=a,()=>`Axis must be in the interval [${-(s+1)}, ${s}]`),l=s+a+1),u.splice(l,0,1),reshape({inputs:{x:i},backend:n,attrs:{shape:u}})}let tf={kernelName:o.YFo,backendName:"webgl",kernelFunc:expandDims},tm="return exp(x) - 1.0;",tg=unaryKernelFunc({opSnippet:tm,packedOpSnippet:tm,cpuKernelImpl:k.tx}),ty={kernelName:o.Y0y,backendName:"webgl",kernelFunc:tg};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let FFTProgram=class FFTProgram{constructor(e,t,r){let n;this.variableNames=["real","imag"];let a=t[1];this.outputShape=t;let i=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=r?`${a}.0`:"1.0";if("real"===e)n="return real * expR - imag * expI;";else if("imag"===e)n="return real * expI + imag * expR;";else throw Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${n}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${a});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${a}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fftImpl(e,t,r){let n=r.texData.get(e.dataId),a=o.D5U.sizeFromShape(e.shape),i=e.shape[e.shape.length-1],s=a/i,u=reshape({inputs:{x:e},backend:r,attrs:{shape:[s,i]}}),l=u.shape,d=new FFTProgram("real",l,t),h=new FFTProgram("imag",l,t),c=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:l},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:l}],p=r.runWebGLProgram(d,c,"float32"),f=r.runWebGLProgram(h,c,"float32"),m=complex({inputs:{real:p,imag:f},backend:r});r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(f);let g=reshape({inputs:{x:m},backend:r,attrs:{shape:e.shape}});return r.disposeIntermediateTensorInfo(u),r.disposeIntermediateTensorInfo(m),g}let tx={kernelName:o.vwp,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r}=e,{input:n}=t;return fftImpl(n,!1,r)}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let FillProgram=class FillProgram{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fill(e){let{backend:t,attrs:r}=e,{shape:n,value:a}=r,{dtype:i}=r;if("string"===(i=i||o.D5U.inferDtype(a))){let e=o.D5U.getArrayFromDType(i,o.D5U.sizeFromShape(n));return e.fill(a),t.makeTensorInfo(n,i,e)}{let e=new FillProgram(n,a),r=[[a]];return t.runWebGLProgram(e,[],i,r)}}let tb={kernelName:o.deh,backendName:"webgl",kernelFunc:fill};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let FlipLeftRightProgram=class FlipLeftRightProgram{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tv={kernelName:o.Uyb,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:r}=e,n=new FlipLeftRightProgram(r.shape),a=t.runWebGLProgram(n,[r],r.dtype);return a}},tw="return floor(x);",tC=unaryKernelFunc({opSnippet:tw,packedOpSnippet:tw,cpuKernelImpl:k.MZ}),tS={kernelName:o.OR,backendName:"webgl",kernelFunc:tC},tI=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,tk=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,tR=binaryKernelFunc({opSnippet:tI,packedOpSnippet:tk,dtype:"int32"}),t$={kernelName:o.jeX,backendName:"webgl",kernelFunc:tR};var tT=r(15389);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let FromPixelsProgram=class FromPixelsProgram{constructor(e){this.variableNames=["A"];let t=(0,eL.A)(),[r,n]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${n}.0, ${r}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let FromPixelsPackedProgram=class FromPixelsPackedProgram{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=(0,eL.A)(),[r,n]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${n}.0, ${r}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let tD={kernelName:o.eBW,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:a}=e,{pixels:i}=t,{numChannels:s}=a,u="undefined"!=typeof HTMLVideoElement&&i instanceof HTMLVideoElement,l="undefined"!=typeof HTMLImageElement&&i instanceof HTMLImageElement,[d,h]=u?[i.videoWidth,i.videoHeight]:[i.width,i.height],c=[h,d],p=[h,d,s];if(l||u){let e=(0,o.OBj)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==n||e!==tE)&&(tE=e,n=document.createElement("canvas").getContext("2d",{willReadFrequently:tE})),n.canvas.width=d,n.canvas.height=h,n.drawImage(i,0,0,d,h),i=n.canvas}let f=r.makeTensorInfo(c,"int32");r.texData.get(f.dataId).usage=tT.v2.PIXELS,r.gpgpu.uploadPixelDataToTexture(r.getTexture(f.dataId),i);let m=(0,o.OBj)().getBool("WEBGL_PACK")?new FromPixelsPackedProgram(p):new FromPixelsProgram(p),g=r.runWebGLProgram(m,[f],"int32");return r.disposeData(f.dataId),g}},tE=(0,o.OBj)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU"),tA={kernelName:o._V0,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t;let{inputs:r,backend:n,attrs:a}=e,{x:i,filter:s,bias:u,preluActivationWeights:l}=r,{strides:d,pad:h,dataFormat:c,dilations:p,dimRoundingMode:f,activation:m,leakyreluAlpha:g}=a,y=o.backend_util.convertConv2DDataFormat(c),x=o.backend_util.computeConv2DInfo(i.shape,s.shape,d,p,h,f,!1,y),b=[],v=null!=u,w=null!=l,C="leakyrelu"===m,prepareInputs=()=>{let e=[i,s],alignInputWithDataFormat=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){let t=reshape({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(v&&e.push(alignInputWithDataFormat(u,c)),w&&e.push(alignInputWithDataFormat(l,c)),C){let t=n.makeTensorInfo([],"float32",o.D5U.createScalarValue(g,"float32"));e.push(t),b.push(t)}return e};if(1===x.filterHeight&&1===x.filterWidth&&1===x.dilationHeight&&1===x.dilationWidth&&1===x.strideHeight&&1===x.strideWidth&&("SAME"===x.padInfo.type||"VALID"===x.padInfo.type))t=conv2dByMatMul({x:i,filter:s,convInfo:x,backend:n,bias:u,activation:m,preluActivationWeights:l,leakyreluAlpha:g});else if(x.strideWidth<=2&&"channelsLast"===y&&(0,o.OBj)().getBool("WEBGL_EXP_CONV")){let e=m?mapActivationToShaderProgram(m,!0):null,r=new Conv2DPackedProgram(x,v,e,w,C),a=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]],i=prepareInputs();t=n.runWebGLProgram(r,i,"float32",a)}else if((0,o.OBj)().getBool("WEBGL_CONV_IM2COL"))t=conv2dWithIm2Row({x:i,filter:s,convInfo:x,backend:n,bias:u,activation:m,preluActivationWeights:l,leakyreluAlpha:g});else{let e=m?mapActivationToShaderProgram(m,!1):null,r=new Conv2DProgram(x,v,e,w,C),a=prepareInputs();t=n.runWebGLProgram(r,a,"float32")}let S=reshape({inputs:{x:t},backend:n,attrs:{shape:x.outShape}});return b.push(t),b.forEach(e=>n.disposeIntermediateTensorInfo(e)),S}},tP={kernelName:o.luS,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t;let{inputs:r,backend:n,attrs:a}=e,{x:i,filter:s,bias:u,preluActivationWeights:l}=r,{strides:d,pad:h,dilations:c,dimRoundingMode:p,activation:f,leakyreluAlpha:m}=a,g=[],y=c;null==y&&(y=[1,1]),o.D5U.assert(o.backend_util.eitherStridesOrDilationsAreOne(d,y),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${d} and dilations '${y}'`);let x=o.backend_util.computeConv2DInfo(i.shape,s.shape,d,y,h,p,!0),b=(0,o.OBj)().getBool("WEBGL_PACK_DEPTHWISECONV")&&x.strideWidth<=2&&x.outChannels/x.inChannels==1,v=f?mapActivationToShaderProgram(f,b):null,w=[i,s],C=null!=u,S=null!=l,I="leakyrelu"===f;if(C&&w.push(u),S&&w.push(l),I){let e=n.makeTensorInfo([],"float32",o.D5U.createScalarValue(m,"float32"));w.push(e),g.push(e)}t=b?new DepthwiseConvPacked2DProgram(x,C,v,S,I):new DepthwiseConv2DProgram(x,C,v,S,I);let k=[[x.padInfo.top,x.padInfo.left],[x.strideHeight,x.strideWidth],[x.dilationHeight,x.dilationWidth],[x.inHeight,x.inWidth]],R=n.runWebGLProgram(t,w,"float32",k);return g.forEach(e=>n.disposeIntermediateTensorInfo(e)),R}};let GatherNDProgram=class GatherNDProgram{constructor(e,t,r,n){this.sliceDim=e,this.strides=t,this.paramsShape=n,this.variableNames=["x","indices"],this.outputShape=r;let a=(0,h.kW)(r.length),i=`
    int index;`;for(let e=0;e<this.sliceDim;e++)i+=`
          index = round(getIndices(coords[0], ${e}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[e]};
          flattenIndex += index * ${this.strides[e]};`;this.userCode=`
         void main() {
          ${a} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};let t_={kernelName:o.q1x,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r}=e,{params:n,indices:a}=t,i=a.shape,s=i[i.length-1],u=o.D5U.sizeFromShape(n.shape),[l,d,h,c]=o.backend_util.prepareAndValidate(n,a),p=reshape({inputs:{x:a},backend:r,attrs:{shape:[d,s]}}),f=reshape({inputs:{x:n},backend:r,attrs:{shape:[o.D5U.sizeFromShape(n.shape)/h,h]}});if(r.shouldExecuteOnCPU([n,a])||"string"===n.dtype){let e=r.readSync(a.dataId),t=r.bufferSync(n),i=(0,k.TD)(e,t,n.dtype,d,s,h,c,n.shape,u);return r.makeTensorInfo(l,n.dtype,i.values)}let m=new GatherNDProgram(s,c,[d,h],n.shape),g=r.runWebGLProgram(m,[f,p],f.dtype),y=reshape({inputs:{x:g},backend:r,attrs:{shape:l}});return r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(g),y}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let GatherProgram=class GatherProgram{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let r=(0,h.kW)(this.rank),n=function(e,t){let r=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let t=0;t<e.length;t++)2===t?n.push("index"):n.push(`${r[t]}`);return n.join()}(e,0);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${n}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gatherV2(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,indices:i}=t,{axis:s,batchDims:u}=n,l=o.D5U.parseAxisParam(s,a.shape)[0];if((0,o.OBj)().get("DEBUG")){let e=r.readSync(i.dataId),t=a.shape[l];for(let r=0;r<e.length;++r){let n=e[r];o.D5U.assert(n<=t-1&&n>=0,()=>`GatherV2: the index value ${n} is not in [0, ${t-1}]`)}}let d=o.backend_util.segment_util.collectGatherOpShapeInfo(a,i,l,u),h=o.D5U.sizeFromShape(i.shape),c=[],p=reshape({inputs:{x:a},backend:r,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),f=reshape({inputs:{x:i},backend:r,attrs:{shape:[d.batchSize,h/d.batchSize]}});c.push(p),c.push(f);let m=[d.batchSize,d.outerSize,h/d.batchSize,d.sliceSize];if(r.shouldExecuteOnCPU([a,i])||"string"===a.dtype){let e=r.bufferSync(f),t=r.bufferSync(p),n=(0,k.m$)(t,e,m);return c.forEach(e=>r.disposeIntermediateTensorInfo(e)),r.makeTensorInfo(d.outputShape,n.dtype,n.values)}let g=new GatherProgram(p.shape,m),y=r.runWebGLProgram(g,[p,f],p.dtype);c.push(y);let x=reshape({inputs:{x:y},backend:r,attrs:{shape:d.outputShape}});return c.forEach(e=>r.disposeIntermediateTensorInfo(e)),x}let tN={kernelName:o.qi_,backendName:"webgl",kernelFunc:gatherV2},tF=`
  return vec4(greaterThan(a, b));
`,tO=binaryKernelFunc({opSnippet:"return float(a > b);",packedOpSnippet:tF,cpuKernelImpl:k.B_,dtype:"bool"}),tB={kernelName:o.iZT,backendName:"webgl",kernelFunc:tO},tL=`
  return vec4(greaterThanEqual(a, b));
`,tM=binaryKernelFunc({opSnippet:"return float(a >= b);",packedOpSnippet:tL,dtype:"bool",cpuKernelImpl:k.ji}),tU={kernelName:o.Acj,backendName:"webgl",kernelFunc:tM},tz={kernelName:o.Qg5,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r}=e,{input:n}=t;return fftImpl(n,!0,r)}},tW=unaryKernelFunc({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),tV={kernelName:o.avt,backendName:"webgl",kernelFunc:tW},tG=unaryKernelFunc({opSnippet:"return float(isinf(x));",dtype:"bool"}),tH={kernelName:o.iWB,backendName:"webgl",kernelFunc:tG},tK=unaryKernelFunc({opSnippet:"return float(isnan(x));",dtype:"bool"}),tj={kernelName:o.r7n,backendName:"webgl",kernelFunc:tK},tX=`
  return vec4(lessThan(a, b));
`,tq=binaryKernelFunc({opSnippet:"return float(a < b);",packedOpSnippet:tX,cpuKernelImpl:k.kY,dtype:"bool"}),tY={kernelName:o.vtC,backendName:"webgl",kernelFunc:tq},tQ=`
  return vec4(lessThanEqual(a, b));
`,tZ=binaryKernelFunc({opSnippet:"return float(a <= b);",packedOpSnippet:tQ,cpuKernelImpl:k.Rn,dtype:"bool"}),tJ={kernelName:o.CAk,backendName:"webgl",kernelFunc:tZ},t0={kernelName:o.e7N,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{backend:t,attrs:r}=e,{start:n,stop:a,num:i}=r,o=(0,k.PQ)(n,a,i);return t.makeTensorInfo([o.length],"float32",o)}},t1=S+`
  return x < 0.0 ? 0./0. : log(x);
`,t2=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,t3=unaryKernelFunc({opSnippet:t1,packedOpSnippet:t2,cpuKernelImpl:k.Sd}),t4={kernelName:o.ZbH,backendName:"webgl",kernelFunc:t3},t5=S+`
  return log(1.0 + x);
`,t6=unaryKernelFunc({opSnippet:t5}),t8={kernelName:o.kU,backendName:"webgl",kernelFunc:t6},t7=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,t9=binaryKernelFunc({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:t7,dtype:"bool"}),re={kernelName:o.PYm,backendName:"webgl",kernelFunc:t9},rt=unaryKernelFunc({opSnippet:"return float(!(x >= 1.0));"}),rr={kernelName:o.VfG,backendName:"webgl",kernelFunc:rt},rn=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,ra=binaryKernelFunc({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:rn,dtype:"bool"}),ri={kernelName:o.MZg,backendName:"webgl",kernelFunc:ra};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let LRNProgram=class LRNProgram{constructor(e,t,r,n,a){let i;this.variableNames=["x"],this.outputShape=[];let o=e[3]-1;this.outputShape=e;let s=`float(${r}) + float(${n}) * sum`;i=.5===a?`inversesqrt(${s})`:1===a?`1.0/(${s})`:`exp(log(${s}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${t}; j <= ${t}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${o}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${i};
        setOutput(val);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let LRNPackedProgram=class LRNPackedProgram{constructor(e,t,r,n,a){let i;this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let o=e[3]-1;this.outputShape=e;let s=`float(${r}) + float(${n}) * sum`;i=.5===a?`inversesqrt(${s})`:1===a?`1.0/(${s})`:`exp(log(${s}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${t};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${t}; j <= ${t}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${i};
        setOutput(result);
      }
    `}};let ro={kernelName:o.eZ0,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{depthRadius:i,bias:s,alpha:u,beta:l}=n,d=(0,o.OBj)().getBool("WEBGL_PACK_NORMALIZATION")?new LRNPackedProgram(a.shape,i,s,u,l):new LRNProgram(a.shape,i,s,u,l);return r.runWebGLProgram(d,[a],a.dtype)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let LRNGradProgram=class LRNGradProgram{constructor(e,t,r,n,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=r,this.alpha=n,this.beta=a,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${n}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${n})
                * float(${a})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${a});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};let rs={kernelName:o.Hhh,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:r,attrs:n}=e,{x:a,y:i,dy:o}=t,{depthRadius:s,bias:u,alpha:l,beta:d}=n,h=new LRNGradProgram(a.shape,s,u,l,d);return r.runWebGLProgram(h,[a,i,o],a.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function max(e){let t;let{inputs:r,backend:n,attrs:a}=e,{x:i}=r,{reductionIndices:s,keepDims:u}=a,l=i.shape.length,d=o.D5U.parseAxisParam(s,i.shape),h=d,c=o.backend_util.getAxesPermutation(h,l),p=null!=c,f=n.shouldExecuteOnCPU([i]),m=i;if(p){if(f){let e=n.texData.get(m.dataId),t=e.values,r=Array(l);for(let e=0;e<r.length;e++)r[e]=i.shape[c[e]];let a=(0,k.Fv)(t,i.shape,i.dtype,c,r);m=n.makeTensorInfo(r,i.dtype);let o=n.texData.get(m.dataId);o.values=a}else m=transposeImpl(i,c,n);h=o.backend_util.getInnerMostAxes(h.length,l)}o.backend_util.assertAxesAreInnerMostDims("max",h,l);let[g,y]=o.backend_util.computeOutAndReduceShapes(m.shape,h),x=g;if(u&&(x=o.backend_util.expandShapeToKeepDim(g,d)),f){let e=n.texData.get(m.dataId),r=e.values,a=(0,k.$O)(r,o.D5U.sizeFromShape(y),x,i.dtype);t=n.makeTensorInfo(x,i.dtype);let s=n.texData.get(t.dataId);s.values=a}else t=/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t,r,n){let a=o.D5U.sizeFromShape(t),i=o.D5U.sizeFromShape(e.shape),s=i/a,u=reshape({inputs:{x:e},attrs:{shape:[s,a]},backend:n}),l=reduce(u,e.dtype,"max",n),d=reshape({inputs:{x:l},attrs:{shape:r},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(l),d}(m,y,x,n);return p&&n.disposeIntermediateTensorInfo(m),t}let ru={kernelName:o.YoZ,backendName:"webgl",kernelFunc:max},rl=l+`
  return max(a, b);
`,rd=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+c+`
  return result;
`,rh=binaryKernelFunc({opSnippet:rl,packedOpSnippet:rd,cpuKernelImpl:k.nL}),rc={kernelName:o.BMI,backendName:"webgl",kernelFunc:rh},rp={kernelName:o.mTV,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t;(0,D.HS)(a,"maxPool");let{filterSize:i,strides:s,pad:u,dimRoundingMode:l}=n;o.D5U.assert(o.backend_util.eitherStridesOrDilationsAreOne(s,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '1'`);let d=o.backend_util.computePool2DInfo(a.shape,i,s,1,u,l);if(1===d.filterWidth&&1===d.filterHeight&&o.D5U.arraysEqual(d.inShape,d.outShape))return identity({inputs:{x:a},backend:r});let h=new Pool2DProgram(d,"max",!1);return r.runWebGLProgram(h,[a],a.dtype)}},rf={kernelName:o.OAf,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{filterSize:i,strides:s,pad:u,dataFormat:l,dimRoundingMode:d}=n,h=o.backend_util.computePool3DInfo(a.shape,i,s,[1,1,1],u,d,l),c=new Pool3DProgram(h,"max",!1);return r.runWebGLProgram(c,[a],a.dtype)}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let MaxPool2DBackpropProgram=class MaxPool2DBackpropProgram{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,r=e.strideWidth,n=e.dilationHeight,a=e.effectiveFilterHeight,i=e.effectiveFilterWidth,o=a-1-e.padInfo.top,s=i-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${s});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${a};
          wR += ${n}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${a*i-1} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}};let MaxPool3DBackpropProgram=class MaxPool3DBackpropProgram{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,r=e.strideHeight,n=e.strideWidth,a=e.dilationDepth,i=e.dilationHeight,o=e.dilationWidth,s=e.effectiveFilterDepth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,d=s-1-e.padInfo.front,h=u-1-e.padInfo.top,c=l-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${d}, ${h}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${s};
           wD += ${a}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${l};
                wC += ${o}) {
              float dyC = float(dyCCorner + wC) / ${n}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${s*u*l-1} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${l} +
                  wR * ${l} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};let rm={kernelName:o.OU7,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,input:i}=t,{filterSize:s,strides:u,pad:l,dimRoundingMode:d}=n,h=o.backend_util.computePool3DInfo(i.shape,s,u,[1,1,1],l,d),c=new Pool3DProgram(h,"max",!0),p=r.runWebGLProgram(c,[i],i.dtype),f=new MaxPool3DBackpropProgram(h),m=r.runWebGLProgram(f,[a,p],i.dtype);return r.disposeIntermediateTensorInfo(p),m}},rg={kernelName:o.OV7,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,input:i,output:s}=t;(0,D.HS)([i,s],"maxPoolGrad");let{filterSize:u,strides:l,pad:d,dimRoundingMode:h}=n,c=o.backend_util.computePool2DInfo(i.shape,u,l,1,d,h),p=new Pool2DProgram(c,"max",!0),f=r.runWebGLProgram(p,[i],i.dtype),m=new MaxPool2DBackpropProgram(c),g=r.runWebGLProgram(m,[a,f],i.dtype);return r.disposeIntermediateTensorInfo(f),g}},ry={kernelName:o.vFR,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:r})=>{let{x:n}=e,{filterSize:a,strides:i,pad:s,includeBatchInIndex:u}=t;o.D5U.assert(4===n.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${n.shape.length}.`);let l=[1,1];o.D5U.assert(o.backend_util.eitherStridesOrDilationsAreOne(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let d=o.backend_util.computePool2DInfo(n.shape,a,i,l,s),[h,c]=/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t,r,n){let a=new Pool2DProgram(r,"max",!1),i=n.runWebGLProgram(a,[e],"float32");a=new Pool2DProgram(r,"max",!0,!0,t);let o=n.runWebGLProgram(a,[e],"float32");return[i,o]}(n,u,d,r);return[h,c]}},rx={kernelName:o.q2K,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:r})=>{let{x:n}=e,{keepDims:a,axis:i}=t,s=n.shape.length,u=o.D5U.parseAxisParam(i,n.shape),l=u,d=o.backend_util.getAxesPermutation(l,s),h=null!=d,c=r.shouldExecuteOnCPU([n]),p=[],f=n;if(h){if(c){let e=r.texData.get(f.dataId),t=e.values,a=Array(s);for(let e=0;e<a.length;e++)a[e]=n.shape[d[e]];let i=(0,k.Fv)(t,n.shape,n.dtype,d,a);f=r.makeTensorInfo(a,n.dtype);let o=r.texData.get(f.dataId);o.values=i}else f=transposeImpl(n,d,r);p.push(f),l=o.backend_util.getInnerMostAxes(l.length,s)}o.backend_util.assertAxesAreInnerMostDims("sum",l,s);let[m,g]=o.backend_util.computeOutAndReduceShapes(f.shape,l),y=m;a&&(y=o.backend_util.expandShapeToKeepDim(m,u));let x=/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t,r,n){let a=o.D5U.sizeFromShape(t),i=o.D5U.sizeFromShape(e.shape),s=i/a,u=reshape({inputs:{x:e},attrs:{shape:[s,a]},backend:n}),l=reduce(u,"float32","mean",n),d=reshape({inputs:{x:l},attrs:{shape:r},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(l),d}(f,g,y,r);for(let e of p)r.disposeIntermediateTensorInfo(e);return x}},rb={kernelName:o.c17,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t;let{inputs:r,backend:n,attrs:a}=e,{x:i}=r,{axis:s,keepDims:u}=a,l=i.shape.length,d=o.D5U.parseAxisParam(s,i.shape),h=d,c=o.backend_util.getAxesPermutation(h,l),p=i;null!=c&&(p=transpose({inputs:{x:i},backend:n,attrs:{perm:c}}),h=o.backend_util.getInnerMostAxes(h.length,i.shape.length)),o.backend_util.assertAxesAreInnerMostDims("min",h,l);let[f,m]=o.backend_util.computeOutAndReduceShapes(p.shape,h),g=o.D5U.sizeFromShape(m),y=reshape({inputs:{x:p},backend:n,attrs:{shape:[-1,g]}}),x=reduce(y,y.dtype,"min",n);if(u){let e=o.backend_util.expandShapeToKeepDim(f,d);t=reshape({inputs:{x:x},backend:n,attrs:{shape:e}})}else t=reshape({inputs:{x:x},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(x),null!=c&&n.disposeIntermediateTensorInfo(p),t}},rv=l+`
  return min(a, b);
`,rw=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+c+`
  return result;
`,rC=binaryKernelFunc({opSnippet:rv,packedOpSnippet:rw,cpuKernelImpl:k.r}),rS={kernelName:o.q8u,backendName:"webgl",kernelFunc:rC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let MirrorPadProgram=class MirrorPadProgram{constructor(e,t,r){this.variableNames=["x"],this.outputShape=t.map((t,r)=>t[0]+e[r]+t[1]);let n=e.length,a=(0,h.kW)(n),i=t.map(e=>e[0]).join(","),o=t.map((t,r)=>t[0]+e[r]).join(","),s=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n),u="reflect"===r?0:1;if(1===n){this.userCode=`
        int start = ${i};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${i});
      ${a} end = ${a}(${o});

      void main() {
        ${a} outC = getOutputCoords();
        for (int i = 0; i < ${n}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${a} coords = outC - start;
        setOutput(getX(${s}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let MirrorPadPackedProgram=class MirrorPadPackedProgram{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((t,r)=>t[0]+e[r]+t[1]);let n=e.length,a=(0,h.kW)(n),i=t.map(e=>e[0]).join(","),o=t.map((t,r)=>t[0]+e[r]).join(","),s=(0,d.Ky)("rc",n),u=(0,d.Ky)("source",n),l=`${s[n-1]} < ${this.outputShape[n-1]}`,c=1===n?"source":`vec2(${u.slice(-2).join()})`,p="reflect"===r?0:1,f="";if(1===n){let e=`
        ${a} source = rc;
        if (source < start) {
          source = start * 2 - source - ${p};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${p};
        }
        source -= start;
      `;f=`
        ${a} rc = outputLoc;
        ${e}
        result[0] = getChannel(getX(${u.join()}), ${c});
        ${s[n-1]} += 1;
        if(${l}) {
          ${e}
          result[1] = getChannel(getX(${u.join()}), ${c});
        }
      `}else{let e=`
        ${a} source = rc;
        ${a} lt = ${a}(lessThan(source, start));
        ${a} gte = ${a}(greaterThanEqual(source, end));
        ${a} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${p}) +
                gte * ((end - 1) * 2 - source + ${p});
        source -= start;
      `;f=`
        ${a} rc = outputLoc;
        ${e}
        result[0] = getChannel(getX(${u.join()}), ${c});
        ${s[n-1]} += 1;
        if(${l}) {
          ${e}
          result[1] = getChannel(getX(${u.join()}), ${c});
        }
        rc = outputLoc;
        ${s[n-2]} += 1;
        if(${s[n-2]} < ${this.outputShape[n-2]}) {
          ${e}
          result[2] = getChannel(getX(${u.join()}), ${c});
          ${s[n-1]} += 1;
          if(${l}) {
            ${e}
            result[3] = getChannel(getX(${u.join()}), ${c});
          }
        }
      `}this.userCode=`
      const ${a} start = ${a}(${i});
      const ${a} end = ${a}(${o});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}};let rI={kernelName:o.jQs,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:r})=>{let{x:n}=e,{paddings:a,mode:i}=r,s=(0,o.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new MirrorPadPackedProgram(n.shape,a,i):new MirrorPadProgram(n.shape,a,i),u=t.runWebGLProgram(s,[n],n.dtype);return u}},rk=`if (b == 0.0) return NAN;
  return mod(a, b);`,rR=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+c+`
  return result;
`,r$=binaryKernelFunc({opSnippet:rk,packedOpSnippet:rR}),rT={kernelName:o.Vbg,backendName:"webgl",kernelFunc:r$};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let MultinomialProgram=class MultinomialProgram{constructor(e,t,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rD=`
if (a == b) {
  return 1.0;
};
return a / b;`,rE=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,rA=binaryKernelFunc({opSnippet:rD,packedOpSnippet:rE,checkOutOfBounds:!0}),rP={kernelName:o.oHH,backendName:"webgl",kernelFunc:rA},r_="return a - b;",rN=binaryKernelFunc({opSnippet:r_,packedOpSnippet:r_,supportsComplex:!0,cpuKernelImpl:k.kI}),rF={kernelName:o.Tr8,backendName:"webgl",kernelFunc:rN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function softmax(e){let{inputs:t,backend:r,attrs:n}=e,{logits:a}=t,{dim:i}=n,s=o.D5U.parseAxisParam([i],a.shape),u=max({inputs:{x:a},backend:r,attrs:{reductionIndices:s,keepDims:!1}}),l=o.backend_util.expandShapeToKeepDim(u.shape,s),d=reshape({inputs:{x:u},backend:r,attrs:{shape:l}}),h=rN({inputs:{a:a,b:d},backend:r}),c=tc({inputs:{x:h},backend:r}),p=sum({inputs:{x:c},backend:r,attrs:{axis:s,keepDims:!1}}),f=reshape({inputs:{x:p},backend:r,attrs:{shape:l}}),m=rA({inputs:{a:c,b:f},backend:r});return r.disposeIntermediateTensorInfo(u),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(c),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(f),m}let rO={kernelName:o.Gcp,backendName:"webgl",kernelFunc:softmax},rB={kernelName:o.NZg,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{logits:a}=t,{numSamples:i,seed:o,normalized:s}=n,u=s?a:softmax({inputs:{logits:a},backend:r,attrs:{dim:a.shape.length-1}}),l=u.shape[0],d=u.shape[1],h=new MultinomialProgram(l,d,i),c=r.runWebGLProgram(h,[u],"int32",[[o]]);return s||r.disposeIntermediateTensorInfo(u),c}},rL=w.D1+`
  return -x;
`,rM=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,rU={kernelName:o.kuV,backendName:"webgl",kernelFunc:function(e){let t;let{inputs:r,backend:n}=e,{x:a}=r;if(n.shouldExecuteOnCPU([a])){let e=n.texData.get(a.dataId),[t,r]=(0,k.Bo)(e.values,a.shape,a.dtype);return n.makeTensorInfo(r,a.dtype,t)}return t=(0,o.OBj)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new C.cc(a.shape,rM):new w.l(a.shape,rL),n.runWebGLProgram(t,[a],a.dtype)}},rz=o.GDt.nonMaxSuppressionV3Impl,rW={kernelName:o.uv1,backendName:"webgl",kernelFunc:function(e){o.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:r,attrs:n}=e,{boxes:a,scores:i}=t,{maxOutputSize:s,iouThreshold:u,scoreThreshold:l}=n,d=r.readSync(a.dataId),h=r.readSync(i.dataId),{selectedIndices:c}=rz(d,h,s,u,l);return r.makeTensorInfo([c.length],"int32",new Int32Array(c))}},rV=o.GDt.nonMaxSuppressionV4Impl,rG={kernelName:o.cye,backendName:"webgl",kernelFunc:function(e){o.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:r,attrs:n}=e,{boxes:a,scores:i}=t,{maxOutputSize:s,iouThreshold:u,scoreThreshold:l,padToMaxOutputSize:d}=n,h=r.readSync(a.dataId),c=r.readSync(i.dataId),{selectedIndices:p,validOutputs:f}=rV(h,c,s,u,l,d);return[r.makeTensorInfo([p.length],"int32",new Int32Array(p)),r.makeTensorInfo([],"int32",new Int32Array([f]))]}},rH=o.GDt.nonMaxSuppressionV5Impl,rK={kernelName:o.W0H,backendName:"webgl",kernelFunc:function(e){o.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:r,attrs:n}=e,{boxes:a,scores:i}=t,{maxOutputSize:s,iouThreshold:u,scoreThreshold:l,softNmsSigma:d}=n,h=r.readSync(a.dataId),c=r.readSync(i.dataId),{selectedIndices:p,selectedScores:f}=rH(h,c,s,u,l,d);return[r.makeTensorInfo([p.length],"int32",new Int32Array(p)),r.makeTensorInfo([f.length],"float32",new Float32Array(f))]}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let OneHotProgram=class OneHotProgram{constructor(e,t,r,n){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${n}), float(${r}),
                      float(index == coords.y)));
      }
    `}};let rj={kernelName:o.we_,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:r,attrs:n}=e,{indices:a}=t,{dtype:i,depth:s,onValue:u,offValue:l}=n,d=o.D5U.sizeFromShape(a.shape),h=new OneHotProgram(d,s,u,l),c=reshape({inputs:{x:a},backend:r,attrs:{shape:[d]}}),p=r.runWebGLProgram(h,[c],i);r.disposeIntermediateTensorInfo(c);let f=[...a.shape,s],m=reshape({inputs:{x:p},backend:r,attrs:{shape:f}});return r.disposeIntermediateTensorInfo(p),m}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zerosLike(e){let{inputs:t,backend:r}=e,{x:n}=t;if("complex64"!==n.dtype)return fill({attrs:{shape:n.shape,dtype:n.dtype,value:"string"===n.dtype?"":0},backend:r});{let e=real({inputs:{input:n},backend:r}),t=zerosLike({inputs:{x:e},backend:r}),a=imag({inputs:{input:n},backend:r}),i=zerosLike({inputs:{x:a},backend:r}),o=complex({inputs:{real:t,imag:i},backend:r});return r.disposeIntermediateTensorInfo(e),r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}}let rX={kernelName:o.RuY,backendName:"webgl",kernelFunc:zerosLike},rq={kernelName:o.qWM,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function onesLike(e){let{inputs:t,backend:r}=e,{x:n}=t;if("string"===n.dtype)throw Error("onesLike is not supported under string dtype");if("complex64"!==n.dtype)return fill({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:r});{let e=real({inputs:{input:n},backend:r}),t=onesLike({inputs:{x:e},backend:r}),a=imag({inputs:{input:n},backend:r}),i=zerosLike({inputs:{x:a},backend:r}),o=complex({inputs:{real:t,imag:i},backend:r});return r.disposeIntermediateTensorInfo(e),r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}}},rY={kernelName:o.QiL,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{axis:a}=n;if(1===t.length)return expandDims({inputs:{input:t[0]},backend:r,attrs:{dim:a}});let i=t[0].shape,s=t[0].dtype;t.forEach(e=>{o.D5U.assertShapesMatch(i,e.shape,"All tensors passed to stack must have matching shapes"),o.D5U.assert(s===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});let u=[],l=t.map(e=>{let t=expandDims({inputs:{input:e},backend:r,attrs:{dim:a}});return u.push(t),t}),d=concat({inputs:l,backend:r,attrs:{axis:a}});return u.forEach(e=>r.disposeIntermediateTensorInfo(e)),d}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let PadProgram=class PadProgram{constructor(e,t,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((t,r)=>t[0]+e[r]+t[1]);let n=e.length,a=(0,h.kW)(n),i=t.map(e=>e[0]).join(","),o=t.map((t,r)=>t[0]+e[r]).join(","),s=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n);if(1===n){this.userCode=`
        int start = ${i};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${i});
      ${a} end = ${a}(${o});

      void main() {
        ${a} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${a} coords = outC - start;
          setOutput(getX(${s}));
        }
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let PadPackedProgram=class PadPackedProgram{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((t,r)=>t[0]+e[r]+t[1]);let n=e.length,a=(0,h.kW)(n),i=t.map(e=>e[0]).join(","),o=t.map((t,r)=>t[0]+e[r]).join(","),s=(0,d.Ky)("rc",n),u=(0,d.Ky)("source",n),l=`${s[n-1]} < ${this.outputShape[n-1]}`,c=1===n?"source":`vec2(${u.slice(-2).join()})`,p=[`${a} rc = outputLoc;`,`${s[n-1]} += 1;
       if(${l}) {
      `,1===n?"":`}
       rc = outputLoc;
       ${s[n-2]} += 1;
       if(${s[n-2]} < ${this.outputShape[n-2]}) {`,1===n?"":`  ${s[n-1]} += 1;
         if(${l}) {`],f=1===n?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",m="";for(let e=0,t=1===n?2:4;e<t;e++)m+=`
        ${p[e]}
        if (${f}) {
          result[${e}] = float(value);
        } else {
          ${a} source = rc - start;
          result[${e}] = getChannel(getX(${u.join()}), ${c});
        }
      `;m+=1===n?"} ":"}}",this.userCode=`
      const ${a} start = ${a}(${i});
      const ${a} end = ${a}(${o});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${m}
        setOutput(result);
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let padV2=e=>{let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{paddings:i,constantValue:s}=n;if(0===o.D5U.sizeFromShape(a.shape)){let e=i.map((e,t)=>e[0]+a.shape[t]+e[1]);return fill({backend:r,attrs:{shape:e,value:s,dtype:a.dtype}})}let u=(0,o.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new PadPackedProgram(a.shape,i,s):new PadProgram(a.shape,i,s),l=[[s]];return r.runWebGLProgram(u,[a],a.dtype,l)},rQ={kernelName:o.lyA,backendName:"webgl",kernelFunc:padV2},rZ=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,rJ=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+c+`
  return result;
`,r0=binaryKernelFunc({opSnippet:rZ,packedOpSnippet:rJ}),r1={kernelName:o.pe_,backendName:"webgl",kernelFunc:r0},r2={kernelName:o.DlI,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t;let{inputs:r,backend:n,attrs:a}=e,{x:i}=r,{axis:s,keepDims:u}=a,l=i.shape.length,d=[],h=o.D5U.parseAxisParam(s,i.shape),c=h,p=o.backend_util.getAxesPermutation(c,l),f=i;if(null!=p&&(f=transpose({inputs:{x:i},backend:n,attrs:{perm:p}}),c=o.backend_util.getInnerMostAxes(c.length,l),d.push(f)),o.backend_util.assertAxesAreInnerMostDims("prod",c,l),n.shouldExecuteOnCPU([f])){let e=n.texData.get(f.dataId).values,{outVals:r,outShape:a,outDtype:i}=(0,k.Tg)(f.shape,f.dtype,e,c);t=n.makeTensorInfo(a,i,r)}else{let[e,r]=o.backend_util.computeOutAndReduceShapes(f.shape,c),a=o.D5U.sizeFromShape(r),s=reshape({inputs:{x:f},backend:n,attrs:{shape:[-1,a]}}),u=(0,o.z4k)(i.dtype),l=reduce(s,u,"prod",n);t=reshape({inputs:{x:l},backend:n,attrs:{shape:e}}),d.push(s),d.push(l)}if(u){d.push(t);let e=o.backend_util.expandShapeToKeepDim(t.shape,h);t=reshape({inputs:{x:t},backend:n,attrs:{shape:e}})}return d.forEach(e=>n.disposeIntermediateTensorInfo(e)),t}},r3={kernelName:o.dDz,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{paramsNestedSplits:a,paramsDenseValues:i,indices:o}=t,{outputRaggedRank:s}=n,u=a.map(e=>r.readSync(e.dataId)),l=a.map(e=>e.shape),d=r.readSync(i.dataId),h=r.readSync(o.dataId),[c,p,f]=(0,k.Qs)(u,l,d,i.shape,i.dtype,h,o.shape,s),m=c.map(e=>r.makeTensorInfo([e.length],"int32",e)),g=r.makeTensorInfo(f,i.dtype,p);return m.concat([g])}},r4={kernelName:o.CQl,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r}=e,{starts:n,limits:a,deltas:i}=t,o=r.readSync(n.dataId),s=r.readSync(a.dataId),u=r.readSync(i.dataId),[l,d]=(0,k.M8)(o,n.shape,n.dtype,s,a.shape,u,i.shape),h=r.makeTensorInfo([l.length],"int32",l),c=r.makeTensorInfo([d.length],n.dtype,d);return[h,c]}},r5={kernelName:o.BiW,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{shape:a,values:i,defaultValue:o,rowPartitionTensors:s}=t,{rowPartitionTypes:u}=n,l=r.readSync(a.dataId),d=r.readSync(i.dataId),h=r.readSync(o.dataId),c=s.map(e=>r.readSync(e.dataId)),p=s.map(e=>e.shape),[f,m]=(0,k.fy)(l,a.shape,d,i.shape,i.dtype,h,o.shape,c,p,u);return r.makeTensorInfo(f,i.dtype,m)}},range=e=>{let{backend:t,attrs:r}=e,{start:n,stop:a,step:i,dtype:o}=r,s=(0,k.hO)(n,a,i,o);return t.makeTensorInfo([s.length],o,s)},r6={kernelName:o.e6w,backendName:"webgl",kernelFunc:range},r8=unaryKernelFunc({opSnippet:"return 1.0 / x;"}),r7={kernelName:o.$HU,backendName:"webgl",kernelFunc:r8},r9=w.D1+`
  return (x < 0.0) ? 0.0 : x;
`,ne=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,nt=unaryKernelFunc({opSnippet:r9,packedOpSnippet:ne}),nr={kernelName:o.qkr,backendName:"webgl",kernelFunc:nt},nn=w.D1+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,na=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ni=unaryKernelFunc({opSnippet:nn,packedOpSnippet:na}),no={kernelName:o.SbG,backendName:"webgl",kernelFunc:ni};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ResizeBilinearProgram=class ResizeBilinearProgram{constructor(e,t,r,n,a){this.variableNames=["A"],this.outputShape=[];let[i,o,s,u]=e;this.outputShape=[i,t,r,u];let l=[n&&t>1?o-1:o,n&&r>1?s-1:s],d=[n&&t>1?t-1:t,n&&r>1?r-1:r];this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${l[0]/d[0]},
          ${l[1]/d[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${s}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC"};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ResizeBilinearPackedProgram=class ResizeBilinearPackedProgram{constructor(e,t,r,n,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,o,s,u]=e;this.outputShape=[i,t,r,u];let l=[n&&t>1?o-1:o,n&&r>1?s-1:s],d=[n&&t>1?t-1:t,n&&r>1?r-1:r];this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${l[0]/d[0]},
          ${l[1]/d[1]},
          ${l[1]/d[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${s}.0,
                                     ${s}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC"};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};let ns={kernelName:o._Yw,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{images:a}=t,{alignCorners:i,halfPixelCenters:s,size:u}=n,[l,d]=u,h=(0,o.OBj)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ResizeBilinearPackedProgram(a.shape,l,d,i,s):new ResizeBilinearProgram(a.shape,l,d,i,s);return r.runWebGLProgram(h,[a],"float32")}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ResizeBilinearBackpropProgram=class ResizeBilinearBackpropProgram{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,n,a]=t,[,i,o]=e,s=[r&&i>1?n-1:n,r&&o>1?a-1:a],u=[r&&i>1?i-1:i,r&&o>1?o-1:o],l=s[0]/u[0],d=s[1]/u[1],h=1/l,c=1/d,p=2*Math.ceil(h)+2,f=2*Math.ceil(c)+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${l});
        const float widthScale = float(${d});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${c});

        const int winHeight = int(${p});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${n-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};let nu={kernelName:o.zbQ,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{images:a,dy:i}=t,{alignCorners:o}=n,s=new ResizeBilinearBackpropProgram(i.shape,a.shape,o);return r.runWebGLProgram(s,[i],i.dtype)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ResizeNearestNeighborProgram=class ResizeNearestNeighborProgram{constructor(e,t,r,n,a){this.variableNames=["A"],this.outputShape=[];let[i,o,s,u]=e;this.outputShape=[i,t,r,u];let l=[n&&t>1?o-1:o,n&&r>1?s-1:s],d=[n&&t>1?t-1:t,n&&r>1?r-1:r];this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${l[0]/d[0]},
          ${l[1]/d[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${s}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC"};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${n?"0.5":"0.0"})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ResizeNearestNeighborPackedProgram=class ResizeNearestNeighborPackedProgram{constructor(e,t,r,n,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[i,o,s,u]=e;this.outputShape=[i,t,r,u];let l=[n&&t>1?o-1:o,n&&r>1?s-1:s],d=[n&&t>1?t-1:t,n&&r>1?r-1:r];this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${l[0]/d[0]},
          ${l[1]/d[1]},
          ${l[1]/d[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${s}.0,
                                     ${s}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC"};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${n?"0.5":"0.0"})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};let nl={kernelName:o.dpD,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{images:a}=t,{alignCorners:i,halfPixelCenters:s,size:u}=n,[l,d]=u,h=(0,o.OBj)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new ResizeNearestNeighborPackedProgram(a.shape,l,d,i,s):new ResizeNearestNeighborProgram(a.shape,l,d,i,s);return r.runWebGLProgram(h,[a],a.dtype)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ResizeNearestNeigborBackpropProgram=class ResizeNearestNeigborBackpropProgram{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,n,a]=t,[,i,o]=e,s=[r&&i>1?n-1:n,r&&o>1?a-1:a],u=[r&&i>1?i-1:i,r&&o>1?o-1:o],l=s[0]/u[0],d=s[1]/u[1],h=1/l,c=1/d,p=2*Math.ceil(h)+2,f=2*Math.ceil(c)+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${l});
        const float widthScale = float(${d});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${c});

        const int winHeight = int(${p});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float sourceFracRow =
              float(${s[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${s[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${n}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${a}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};let nd={kernelName:o.Hmb,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{images:a,dy:i}=t,{alignCorners:o}=n,s=new ResizeNearestNeigborBackpropProgram(i.shape,a.shape,o);return r.runWebGLProgram(s,[i],i.dtype)}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ReverseProgram=class ReverseProgram{constructor(e,t){this.variableNames=["x"];let r=e.length;if(r>4)throw Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=e,1===r){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let getInCoord=r=>-1!==t.indexOf(r)&&1!==e[r]?`${e[r]} - coords[${r}] - 1`:`coords[${r}]`,n=e.map((e,t)=>getInCoord(t)).join(","),a=(0,h.kW)(r);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${n}));
      }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ReversePackedProgram=class ReversePackedProgram{constructor(e,t){var r,n,a;this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let i=e.length;if(i>4)throw Error(`WebGL backend: Reverse of rank-${i} tensor is not yet supported`);this.outputShape=e;let o=(0,d.Ky)("rc",i),s=`${o[i-1]} + 1 < ${this.outputShape[i-1]}`,u=`${o[i-2]} + 1 < ${this.outputShape[i-2]}`,l=(0,h.kW)(i);function getChannel(r){let n=e.map((n,a)=>-1!==t.indexOf(a)&&1!==e[a]?`${e[a]} - ${r[a]} - 1`:`${r[a]}`),a=n.join(","),i=n.slice(-2).join(",");return`getChannel(getX(${a}), vec2(${i}))`}1===i?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${l} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${getChannel(o.slice())};
          if(${s}){
            result.g = ${(r=o.slice())[i-1]="("+r[i-1]+" + 1)",getChannel(r)};
          }
          if(${u}) {
            result.b = ${(n=o.slice())[i-2]="("+n[i-2]+" + 1)",getChannel(n)};
            if(${s}) {
              result.a = ${(a=o.slice())[i-1]="("+a[i-1]+" + 1)",a[i-2]="("+a[i-2]+" + 1)",getChannel(a)};
            }
          }
          setOutput(result);
        }
    `}};let nh={kernelName:o.mKl,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{dims:i}=n,s=a.shape.length,u=o.D5U.parseAxisParam(i,a.shape);if(0===s)return identity({inputs:{x:a},backend:r});let l=(0,o.OBj)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ReversePackedProgram(a.shape,u):new ReverseProgram(a.shape,u);return r.runWebGLProgram(l,[a],a.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let RotateProgram=class RotateProgram{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let r=e[1],n=e[2];this.outputShape=e;let a="";a="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${a}
          if(coordX >= 0 && coordX < ${n} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nc={kernelName:o.b9H,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:r})=>{let{image:n}=e,{radians:a,fillValue:i,center:s}=t,u=new RotateProgram(n.shape,i),[l,d]=o.backend_util.getImageCenter(s,n.shape[1],n.shape[2]),h=[[l,d,Math.sin(a),Math.cos(a)]],c=r.runWebGLProgram(u,[n],n.dtype,h);return c}},np=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,nf=unaryKernelFunc({opSnippet:np}),nm={kernelName:o.e07,backendName:"webgl",kernelFunc:nf},ng=unaryKernelFunc({opSnippet:"return inversesqrt(x);",cpuKernelImpl:k.St}),ny={kernelName:o.bV0,backendName:"webgl",kernelFunc:ng};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ScatterProgram=class ScatterProgram{constructor(e,t,r,n,a,i,o=!0,s=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;let u=(0,h.kW)(a.length),l=(0,h.kW)(i.length),d="";1===r?d="i":2===r&&(d="i, j");let c=`getIndices(${d})`,p="";1===n?p="i":2===n&&(p="i, coords[1]");let f=`getUpdates(${p})`,m="";s&&(m="coords[0], coords[1]");let g=`getDefaultValue(${m})`;this.userCode=`
        ${u} strides = ${u}(${a});

        void main() {
          ${l} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${c});
              flattenedIndex += index * ${t>1?"strides[j]":"strides"};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(${g}, sum, float(found)));
        }
      `}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ScatterPackedProgram=class ScatterPackedProgram{constructor(e,t,r,n,a,i,o=!0,s=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;let u=(0,h.kW)(a.length),l=(0,h.kW)(i.length),d="";1===r?d="i":2===r&&(d="i, j");let c=`getIndices(${d})`,p="";1===n?p="i":2===n&&(p="i, coords[1]");let f=`getUpdates(${p})`,m="";s&&(m="coords[0], coords[1]");let g=`getDefaultValue(${m})`;this.userCode=`
        ${u} strides = ${u}(${a});

        void main() {
          ${l} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${c});
              flattenedIndex += index.xz * ${t>1?"strides[j]":"strides"};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${t>1?"strides[j + 1]":"strides"};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${f};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${g}, sum, found));
        }
      `}};let nx={kernelName:o.xQA,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t;let{inputs:r,backend:n,attrs:a}=e,{indices:i,updates:s}=r,{shape:u}=a,{sliceRank:l,numUpdates:d,sliceSize:h,strides:c,outputSize:p}=o.backend_util.calculateShapes(s,i,u),f=[p/h,h];if(0===p)return n.makeTensorInfo(u,i.dtype);let m=reshape({inputs:{x:i},backend:n,attrs:{shape:[d,l]}}),g=reshape({inputs:{x:s},backend:n,attrs:{shape:[d,h]}}),y=n.makeTensorInfo([],"float32",new Float32Array([0]));t=(0,o.OBj)().getBool("WEBGL_PACK")?new ScatterPackedProgram(d,l,m.shape.length,g.shape.length,c,f):new ScatterProgram(d,l,m.shape.length,g.shape.length,c,f);let x=n.runWebGLProgram(t,[g,m,y],g.dtype),b=reshape({inputs:{x:x},backend:n,attrs:{shape:u}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(y),b}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SearchSortedProgram=class SearchSortedProgram{constructor(e,t,r,n){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,r];let a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=2===(0,o.OBj)().getNumber("WEBGL_VERSION")?"while (left < right) {":a;this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${"left"===n?"<":"<="} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};let nb={kernelName:o.nr8,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{sortedSequence:a,values:i}=t,{side:o}=n,s=new SearchSortedProgram(a.shape[0],a.shape[1],i.shape[1],o),u=[[a.shape[1]]];return r.runWebGLProgram(s,[a,i],"int32",u)}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SelectProgram=class SelectProgram{constructor(e,t,r){let n,a;if(this.variableNames=["c","a","b"],this.outputShape=t,r>4)throw Error(`Where for rank ${r} is not yet supported`);if(1===r)a="resRC",n="resRC";else{let r=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],o=[];for(let n=0;n<t.length;n++)o.push(`${r[n]}`),n<e&&i.push(`${r[n]}`);n=i.join(),a=o.join()}let i=(0,h.kW)(r);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${n});
        if (cVal >= 1.0) {
          setOutput(getA(${a}));
        } else {
          setOutput(getB(${a}));
        }
      }
    `}};let nv={kernelName:o.PhF,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r}=e,{condition:n,t:a,e:i}=t,s=new SelectProgram(n.shape.length,a.shape,a.shape.length);return r.runWebGLProgram(s,[n,a,i],(0,o.x8V)(a.dtype,i.dtype))}},nw=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${o.backend_util.SELU_SCALEALPHA};
  float scale = ${o.backend_util.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,nC=unaryKernelFunc({opSnippet:nw}),nS={kernelName:o.oFR,backendName:"webgl",kernelFunc:nC},nI=S+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,nk=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,nR=unaryKernelFunc({opSnippet:nI,packedOpSnippet:nk,cpuKernelImpl:k.UN}),n$={kernelName:o.a5O,backendName:"webgl",kernelFunc:nR},nT=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,nD=unaryKernelFunc({opSnippet:nT}),nE={kernelName:o.i5y,backendName:"webgl",kernelFunc:nD},nA=S+`
  return sin(x);
`,nP=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${c}
  return result;
`,n_=unaryKernelFunc({opSnippet:nA,packedOpSnippet:nP}),nN={kernelName:o.RQH,backendName:"webgl",kernelFunc:n_},nF=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,nO=unaryKernelFunc({opSnippet:nF}),nB={kernelName:o.wYB,backendName:"webgl",kernelFunc:nO},nL=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,nM=unaryKernelFunc({opSnippet:nL}),nU={kernelName:o.MRv,backendName:"webgl",kernelFunc:nM},nz={kernelName:o.TQc,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{blockShape:i,paddings:s}=n;o.D5U.assert(a.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let u=i.reduce((e,t)=>e*t),l=[[0,0]];l.push(...s);for(let e=1+i.length;e<a.shape.length;++e)l.push([0,0]);let d=[],h=padV2({inputs:{x:a},backend:r,attrs:{paddings:l,constantValue:0}}),c=o.backend_util.getReshaped(h.shape,i,u,!1),p=o.backend_util.getPermuted(c.length,i.length,!1),f=o.backend_util.getReshapedPermuted(h.shape,i,u,!1),m=reshape({inputs:{x:h},backend:r,attrs:{shape:c}}),g=transpose({inputs:{x:m},backend:r,attrs:{perm:p}}),y=reshape({inputs:{x:g},backend:r,attrs:{shape:f}});return d.push(h),d.push(m),d.push(g),d.forEach(e=>r.disposeIntermediateTensorInfo(e)),y}},nW={kernelName:o.O3z,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r}=e,{indices:n,values:a,denseShape:i,defaultValue:o}=t;if(1!==i.shape.length)throw Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(2!==n.shape.length)throw Error(`Indices must be a matrix, saw:
         ${n.shape}`);if(1!==a.shape.length)throw Error(`Values must be a vector, saw:
         ${a.shape}`);if(0!==o.shape.length)throw Error(`Default value must be a scalar, saw:
        ${o.shape}`);let s=r.readSync(n.dataId),u=r.readSync(a.dataId),l=r.readSync(i.dataId),d=r.readSync(o.dataId)[0],[h,c,p,f,m]=(0,k.X8)(s,n.shape,n.dtype,u,a.dtype,l,d);return[r.makeTensorInfo(c,n.dtype,h),r.makeTensorInfo([c[0]],a.dtype,p),r.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),r.makeTensorInfo([m.length],n.dtype,new Int32Array(m))]}},nV={kernelName:o.nhH,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r}=e,{inputIndices:n,inputShape:a,newShape:i}=t;if(2!==n.shape.length)throw Error(`Input indices should be a matrix but received shape ${n.shape}`);if(1!==a.shape.length)throw Error(`Input shape should be a vector but received shape ${a.shape}`);if(1!==i.shape.length)throw Error(`Target shape should be a vector but received shape ${i.shape}`);let o=Array.from(r.readSync(a.dataId)),s=r.readSync(n.dataId),u=Array.from(r.readSync(i.dataId)),[l,d,h]=(0,k.LS)(s,n.shape,n.dtype,o,u);return[r.makeTensorInfo(d,n.dtype,l),r.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}},nG={kernelName:o.w3H,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r}=e,{data:n,indices:a,segmentIds:i}=t;if(n.shape.length<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw Error(`Indices should be a vector but received shape
              ${a.shape}`);if(1!==i.shape.length)throw Error(`Segment ids should be a vector but received shape
              ${i.shape}`);let o=r.readSync(n.dataId),s=r.readSync(a.dataId),u=r.readSync(i.dataId),[l,d]=(0,k.AR)(o,n.shape,n.dtype,s,u,!0);return r.makeTensorInfo(d,n.dtype,l)}},nH={kernelName:o.ZjV,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r}=e,{data:n,indices:a,segmentIds:i}=t;if(n.shape.length<1)throw Error("Data should be at least 1 dimensional but received scalar");if(1!==a.shape.length)throw Error(`Indices should be a vector but received shape
             ${a.shape}`);if(1!==i.shape.length)throw Error(`Segment ids should be a vector but received shape
             ${i.shape}`);let o=r.readSync(n.dataId),s=r.readSync(a.dataId),u=r.readSync(i.dataId),[l,d]=(0,k.AR)(o,n.shape,n.dtype,s,u);return r.makeTensorInfo(d,n.dtype,l)}},nK={kernelName:o.D2d,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{sparseIndices:a,sparseValues:i,defaultValue:s}=t,{outputShape:u}=n,{sliceRank:l,numUpdates:d,sliceSize:h,strides:c,outputSize:p}=o.backend_util.calculateShapes(i,a,u);if("string"===i.dtype){let e=r.bufferSync(a),t=r.bufferSync(i),n=o.D5U.decodeString(r.readSync(s.dataId)[0]),f=(0,k.Y1)(e,t,u,p,h,d,l,c,n,!1);return r.makeTensorInfo(u,f.dtype,f.values)}let f=new ScatterProgram(d,l,a.shape.length,i.shape.length,c,[p,1],!1),m=r.runWebGLProgram(f,[i,a,s],i.dtype),g=reshape({inputs:{x:m},backend:r,attrs:{shape:u}});return r.disposeIntermediateTensorInfo(m),g}},nj={kernelName:o.L8s,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{numOrSizeSplits:i,axis:s}=n,u=o.D5U.parseAxisParam(s,a.shape)[0],l=o.backend_util.prepareSplitSize(a,i,u),d=a.shape.length,h=Array(d).fill(0),c=a.shape.slice();return l.map(e=>{let t=[...c];t[u]=e;let n=slice({inputs:{x:a},backend:r,attrs:{begin:h,size:t}});return h[u]+=e,n})}},nX="return sqrt(x);",nq=unaryKernelFunc({opSnippet:nX,packedOpSnippet:nX,cpuKernelImpl:k.Bk}),nY={kernelName:o.FKq,backendName:"webgl",kernelFunc:nq},nQ=unaryKernelFunc({opSnippet:"return x * x;"}),nZ={kernelName:o.bK0,backendName:"webgl",kernelFunc:nQ},nJ="return (a - b) * (a - b);",n0=binaryKernelFunc({opSnippet:nJ,packedOpSnippet:nJ}),n1={kernelName:o._tC,backendName:"webgl",kernelFunc:n0},n2={kernelName:o.e0R,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t;if("string"!==a.dtype)throw Error("Input must be of datatype string");let i=r.readSync(a.dataId),s=o.backend_util.fromUint8ToStringArray(i),u=(0,k.F1)(s,"string",n);return r.makeTensorInfo(a.shape,"string",u)}},n3={kernelName:o.h8e,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function({inputs:e,attrs:t,backend:r}){let{x:n}=e,a=w.D1+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,i=new w.l(n.shape,a);return r.runWebGLProgram(i,[n],n.dtype)}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let StridedSliceProgram=class StridedSliceProgram{constructor(e,t,r){this.variableNames=["x"],this.outputShape=r;let n=r.length,a=(0,h.kW)(r.length),i=(0,h.kW)(r.length),o="";if(1===n)o="coords * strides + begin";else{let e=0;o=r.map((t,n)=>(e++,1===r.length?`coords * strides[${n}] + begin[${n}]`:`coords[${e-1}] * strides[${n}] + begin[${n}]`)).join(",")}this.userCode=`
      ${a} begin = ${a}(${e});
      ${a} strides = ${a}(${t});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}};let n4={kernelName:o.jQk,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t;let{inputs:r,backend:n,attrs:a}=e,{x:i}=r,{begin:s,end:u,strides:l,beginMask:d,endMask:h,ellipsisMask:c,newAxisMask:p,shrinkAxisMask:f}=a,{finalShapeSparse:m,finalShape:g,isIdentity:y,sliceDim0:x,isSimpleSlice:b,begin:v,end:w,strides:C}=o.kuN.sliceInfo(i.shape,s,u,l,d,h,c,p,f);if(y)t=reshape({inputs:{x:i},backend:n,attrs:{shape:g}});else if(x||b){o.D5U.assert(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);let e=o.kuN.computeOutShape(v,w,C),r=slice({inputs:{x:i},backend:n,attrs:{begin:v,size:e}});t=reshape({inputs:{x:r},backend:n,attrs:{shape:g}}),n.disposeIntermediateTensorInfo(r)}else{let e=n.shouldExecuteOnCPU([i]);if(e){let e=n.readSync(i.dataId),r=(0,o.f3b)(i.shape,i.dtype,e),a=(0,k.$u)(m,r,C,v);t=n.makeTensorInfo(g,i.dtype,a.values)}else{let e=new StridedSliceProgram(v,C,m);t=n.runWebGLProgram(e,[i],i.dtype)}}let S=reshape({inputs:{x:t},backend:n,attrs:{shape:g}});return n.disposeIntermediateTensorInfo(t),S}},n5={kernelName:o._JP,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{separator:a,nGramWidths:i,leftPad:o,rightPad:s,padWidth:u,preserveShortSequences:l}=n,{data:d,dataSplits:h}=t,c=r.readSync(d.dataId),p=r.readSync(h.dataId),[f,m]=(0,k.$j)(c,p,a,i,o,s,u,l);return[r.makeTensorInfo([f.length],"string",f),r.makeTensorInfo(h.shape,"int32",m)]}},n6={kernelName:o.s1s,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{skipEmpty:a}=n,{input:i,delimiter:o}=t;if("string"!==i.dtype)throw Error("Input must be of datatype string");if(1!==i.shape.length)throw Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==o.shape.length)throw Error(`Delimiter must be a scalar, got shape: ${o.shape}`);let s=r.readSync(i.dataId),u=r.readSync(o.dataId)[0],[l,d,h]=(0,k.A0)(s,u,a),c=d.length;return[r.makeTensorInfo([c,2],"int32",l),r.makeTensorInfo([c],"string",d),r.makeTensorInfo([2],"int32",new Int32Array(h))]}},n8={kernelName:o.XkS,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{numBuckets:a}=n,{input:i}=t;if("string"!==i.dtype)throw Error("Input must be of datatype string");if(a<=0)throw Error("Number of buckets must be at least 1");let o=r.readSync(i.dataId),s=(0,k._9)(o,a);return r.makeTensorInfo(i.shape,"int32",s)}},n7=unaryKernelFunc({opSnippet:"return tan(x);"}),n9={kernelName:o.sEM,backendName:"webgl",kernelFunc:n7},ae=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,at=unaryKernelFunc({opSnippet:ae}),ar={kernelName:o.MIZ,backendName:"webgl",kernelFunc:at},an={kernelName:o.SIB,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{tensor:a,indices:i,updates:s}=t,{}=n,{sliceRank:u,numUpdates:l,sliceSize:d,strides:h,outputSize:c}=o.backend_util.calculateShapes(s,i,a.shape),p=[c/d,d];if(0===c)return r.makeTensorInfo(a.shape,i.dtype);let f=reshape({inputs:{x:i},backend:r,attrs:{shape:[l,u]}}),m=reshape({inputs:{x:s},backend:r,attrs:{shape:[l,d]}}),g=reshape({inputs:{x:a},backend:r,attrs:{shape:p}}),y=new ScatterProgram(l,u,f.shape.length,m.shape.length,h,p,!1,!0),x=r.runWebGLProgram(y,[m,f,g],g.dtype),b=reshape({inputs:{x:x},backend:r,attrs:{shape:a.shape}});return r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(x),b}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TileProgram=class TileProgram{constructor(e,t){this.variableNames=["A"];let r=Array(e.length);for(let n=0;n<r.length;n++)r[n]=e[n]*t[n];this.outputShape=r,this.rank=r.length;let n=(0,h.kW)(this.rank),a=function(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;let r=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],n=[];for(let t=0;t<e.length;t++)n.push(`imod(${r[t]}, ${e[t]})`);return n.join()}(e);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        setOutput(getA(${a}));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tile(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{reps:i}=n;if("string"===a.dtype||a.shape.length>5){let e=r.readSync(a.dataId),t="string"===a.dtype?e.map(e=>o.D5U.decodeString(e)):e,n=(0,o.f3b)(a.shape,a.dtype,t),s=(0,k.KX)(n,i);return r.makeTensorInfo(s.shape,s.dtype,s.values)}let s=new TileProgram(a.shape,i),u=r.runWebGLProgram(s,[a],a.dtype);return u}let aa={kernelName:o.n9L,backendName:"webgl",kernelFunc:tile};let SwapProgram=class SwapProgram{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}};let MergeProgram=class MergeProgram{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function disposeIntermediateTensorInfoOrNull(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function roundUpToPow2(e){let t=1;for(;t<e;)t*=2;return t}let ai={kernelName:o.cWu,backendName:"webgl",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{k:i,sorted:s}=n,u=(0,o.OBj)().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=(0,o.OBj)().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),d=a.shape,h=d[d.length-1];if(r.shouldExecuteOnCPU([a])||h<u||i>l){let e=r.readSync(a.dataId),[t,n]=(0,k.oC)(e,d,a.dtype,i,s);return[r.makeTensorInfo(t.shape,t.dtype,t.values),r.makeTensorInfo(n.shape,n.dtype,n.values)]}if(0===i)return d[d.length-1]=0,[r.makeTensorInfo(d,a.dtype,[]),r.makeTensorInfo(d,"int32",[])];if(1===h)return[a,fill({attrs:{shape:d,dtype:"int32",value:0},backend:r})];let c=r.texData.get(a.dataId),p=null!==c&&c.isPacked,f=p?r.unpackTensor(a):a,m=o.D5U.sizeFromShape(d),g=m/h,y=reshape({inputs:{x:f},attrs:{shape:[g,h]},backend:r});p&&disposeIntermediateTensorInfoOrNull(r,f);let x=roundUpToPow2(i),b=roundUpToPow2(h),v=null,getInputs=()=>null===v?[y,y]:[y,v],runSwap=(e,t,n)=>{let a=getInputs(),i=new SwapProgram(n),o=null===v?1:0,s=[[h],[o],[Number.NEGATIVE_INFINITY],[e],[t]],u=v;v=r.runWebGLProgram(i,a,"int32",s),disposeIntermediateTensorInfoOrNull(r,u)};for(let e=1;e<x;e*=2){let t=2*e;for(let r=e;r>=1;r/=2)runSwap(t,r,[g,b])}for(let e=b;e>x;e/=2){let t=getInputs(),n=new MergeProgram([g,e/2]),a=null===v?1:0,i=[[h],[a],[x]],o=v;v=r.runWebGLProgram(n,t,"int32",i),disposeIntermediateTensorInfoOrNull(r,o);let s=x/2,u=2*s;for(let e=s;e>=1;e/=2)runSwap(u,e,v.shape)}let w=v;v=slice({inputs:{x:v},backend:r,attrs:{begin:0,size:[g,i]}}),disposeIntermediateTensorInfoOrNull(r,w);let C=gatherV2({inputs:{x:y,indices:v},backend:r,attrs:{axis:1,batchDims:1}});disposeIntermediateTensorInfoOrNull(r,y);let S=d.slice(0,-1);S.push(i),w=v,v=reshape({inputs:{x:v},attrs:{shape:S},backend:r}),disposeIntermediateTensorInfoOrNull(r,w);let I=C;return C=reshape({inputs:{x:C},attrs:{shape:S},backend:r}),disposeIntermediateTensorInfoOrNull(r,I),[C,v]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TransformProgram=class TransformProgram{constructor(e,t,r,n,a,i){let o;switch(this.variableNames=["Image","Transforms"],this.outputShape=i,n){case"constant":default:o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${o} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${a});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${a});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${"nearest"===r?1:2} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};let ao={kernelName:o.wx7,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{image:a,transforms:i}=t,{interpolation:o,fillMode:s,fillValue:u,outputShape:l}=n,[d,h,c,p]=a.shape,[f,m]=null!=l?l:[h,c],g=new TransformProgram(h,c,o,s,u,[d,f,m,p]);return r.runWebGLProgram(g,[a,i],"float32")}},as={kernelName:o.kpP,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,attrs:r,backend:n}=e,{axis:a}=r,{x:i}=t;(0,D.HS)(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let o=n.readSync(i.dataId),{outputValues:s,outputShape:u,indices:l}=(0,k.CV)(o,a,i.shape,i.dtype);return[n.makeTensorInfo(u,i.dtype,s),n.makeTensorInfo([l.length],"int32",l)]}},au={kernelName:o.ToN,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{value:a}=t,{axis:i}=n;i<0&&(i+=a.shape.length);let o=a.shape.length,s=a.shape[i],u=Array(o-1),l=0;for(let e=0;e<o;e++)e!==i&&(u[l++]=a.shape[e]);let d=[],h=Array(o).fill(0),c=a.shape.slice();c[i]=1;let p=Array(s);for(let e=0;e<p.length;e++){h[i]=e;let t=slice({inputs:{x:a},backend:r,attrs:{begin:h,size:c}}),n=reshape({inputs:{x:t},backend:r,attrs:{shape:u}});p[e]=n,d.push(t)}return d.forEach(e=>r.disposeIntermediateTensorInfo(e)),p}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SegmentOpProgram=class SegmentOpProgram{constructor(e,t){this.variableNames=["x","segmentIds"];let r=e.windowSize,n=e.batchSize,a=e.inSize,i=e.numSegments,o=i*Math.ceil(a/r);this.outputShape=[n,o];let s=4*Math.floor(r/4),u=r%4,l=`
        sumValue += dot(values, segFilter);
    `,d="";a%r>0&&(d=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `);let h="";a%r>0&&(h=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = 0.0;

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${h}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${s}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${l}
        }

        int inIdx = inOffset + ${s};
        if (${1===u}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${l}
        } else if (${2===u}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${l}
        } else if (${3===u}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${l}
        }
        setOutput(sumValue);
      }
    `}};let al={kernelName:o.Qvg,backendName:"webgl",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,segmentIds:i}=t,{numSegments:s}=n,u=a.shape.length,l=[],d=0,h=o.backend_util.getAxesPermutation([d],u),c=a;null!=h&&(c=transpose({inputs:{x:a},backend:r,attrs:{perm:h}}),l.push(c),d=o.backend_util.getInnerMostAxes(1,u)[0]);let p=o.backend_util.segment_util.computeOutShape(c.shape,d,s),f=o.D5U.sizeFromShape([c.shape[d]]),m=reshape({inputs:{x:c},backend:r,attrs:{shape:[-1,f]}});l.push(m);let g=(0,o.z4k)(a.dtype),segOpCompute=(e,t,n,a,i)=>{let s=e.shape[0],u=e.shape[1],d=o.backend_util.segment_util.segOpComputeOptimalWindowSize(u,i),h=new SegmentOpProgram({windowSize:d,inSize:u,batchSize:s,numSegments:i},t),c=r.compileAndRun(h,[e,n],a);if(l.push(c),c.shape[1]===i)return c;let p=range({backend:r,attrs:{start:0,stop:i,step:1,dtype:"float32"}}),f=tile({inputs:{x:p},backend:r,attrs:{reps:[u/d]}});l.push(p),l.push(f);let m=segOpCompute(c,t,f,a,i);return m},y=segOpCompute(m,"unsortedSegmentSum",i,g,s),x=reshape({inputs:{x:y},backend:r,attrs:{shape:p}}),b=x;if(null!=h){l.push(x);let e=o.backend_util.getUndoAxesPermutation(h);b=transpose({inputs:{x:b},backend:r,attrs:{perm:e}})}return l.forEach(e=>r.disposeIntermediateTensorInfo(e)),b}};for(let e of[N,O,M,W,H,K,j,X,q,Y,J,er,ei,el,ec,ep,ef,em,eg,ey,ex,ew,eC,ek,eR,eE,e_,eN,f,eF,eB,eM,eU,ez,eW,eV,eG,eX,eQ,eZ,eJ,e0,e1,e2,e3,e4,e5,e6,e8,e7,tt,tn,to,tl,tp,tf,ty,tx,tb,tv,tS,t$,tD,tA,tP,t_,tN,tB,tU,p,tz,eO,tV,tH,tj,y,tY,tJ,t0,t4,t8,re,rr,ri,ro,rs,ru,rc,rp,rf,rm,rg,ry,rx,rb,rS,rI,rT,rB,$,rU,rW,rG,rK,eT,rj,rq,rY,rQ,r1,v,r2,r3,r4,r5,r6,eD,rP,r7,nr,no,A,ns,nu,nl,nd,nh,nc,nm,ny,nx,nb,nv,nS,n$,nE,nN,nB,ev,rO,nU,nz,nW,nV,nG,nH,nK,nj,nY,nZ,n1,n2,n3,n4,n5,n6,n8,rF,P,n9,ar,an,aa,ai,ao,_,as,au,al,rX])(0,o.wCN)(e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */},48816:function(e,t,r){"use strict";r.d(t,{$O:function(){return S},$j:function(){return K},$u:function(){return H},A0:function(){return j},AR:function(){return W},B_:function(){return y},Bk:function(){return V},Bo:function(){return $},CJ:function(){return L},CV:function(){return J},F1:function(){return G},Fv:function(){return Z},KX:function(){return Y},LS:function(){return z},M8:function(){return P},MZ:function(){return f},PQ:function(){return w},Qs:function(){return A},Rn:function(){return v},Sd:function(){return C},St:function(){return F},TD:function(){return m},Tg:function(){return D},Th:function(){return R},UN:function(){return B},X8:function(){return U},XM:function(){return s},Y1:function(){return O},_9:function(){return X},aX:function(){return c},cK:function(){return a},cZ:function(){return T},cm:function(){return u},cx:function(){return o},fy:function(){return _},gv:function(){return h},hO:function(){return N},ji:function(){return x},kI:function(){return q},kY:function(){return b},m$:function(){return g},n7:function(){return d},nL:function(){return I},nT:function(){return M},oC:function(){return Q},pk:function(){return l},qO:function(){return i},r:function(){return k},tx:function(){return p}});var n=r(40300);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let{addImpl:a,bincountImpl:i,bincountReduceImpl:o,bitwiseAndImpl:s,castImpl:u,ceilImpl:l,concatImpl:d,equalImpl:h,expImpl:c,expm1Impl:p,floorImpl:f,gatherNdImpl:m,gatherV2Impl:g,greaterImpl:y,greaterEqualImpl:x,lessImpl:b,lessEqualImpl:v,linSpaceImpl:w,logImpl:C,maxImpl:S,maximumImpl:I,minimumImpl:k,multiplyImpl:R,negImpl:$,notEqualImpl:T,prodImpl:D,raggedGatherImpl:A,raggedRangeImpl:P,raggedTensorToTensorImpl:_,rangeImpl:N,rsqrtImpl:F,scatterImpl:O,sigmoidImpl:B,simpleAbsImpl:L,sliceImpl:M,sparseFillEmptyRowsImpl:U,sparseReshapeImpl:z,sparseSegmentReductionImpl:W,sqrtImpl:V,staticRegexReplaceImpl:G,stridedSliceImpl:H,stringNGramsImpl:K,stringSplitImpl:j,stringToHashBucketFastImpl:X,subImpl:q,tileImpl:Y,topKImpl:Q,transposeImpl:Z,uniqueImpl:J}=n},20344:function(e,t,r){"use strict";r.d(t,{U:function(){return PackProgram}});var n=r(58257),a=r(4573),i=r(10058);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let PackProgram=class PackProgram{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=(0,n.C9)(this.outputShape.length),0===this.rank)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let e=(0,a.Ky)("rc",this.rank),t=(0,i.kW)(this.rank),r=this.getOutOfBoundsCondition(e),n=this.getSetup(e),o=this.getOutput(e);this.userCode=`
        void main() {
          ${t} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${n}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let r=0;r<=1;r++)for(let n=0;n<=1;n++){let a=`${0===r?"r":"rp1"}, ${0===n?"c":"cp1"}`;for(let t=2;t<this.rank;t++)a=`${e[e.length-1-t]},`+a;t.push(a)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let r=this.rank-2;r<this.rank;r++)t+=`${e[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";let t=e.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],n=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${n};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);if(1===this.rank){let e=this.enableShapeUniforms?"outShape":this.outputShape[0];return`getA(rc), (rc + 1 >= ${e} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}},4573:function(e,t,r){"use strict";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getVecChannels(e,t){return["x","y","z","w","u","v"].slice(0,t).map(t=>`${e}.${t}`)}function getChannels(e,t){return 1===t?[e]:getVecChannels(e,t)}function getSourceCoords(e,t){if(1===e)return"rc";let r="";for(let n=0;n<e;n++)r+=t[n],n<e-1&&(r+=",");return r}r.d(t,{Ky:function(){return getChannels},Qc:function(){return getSourceCoords},k6:function(){return getVecChannels}})},68588:function(e,t,r){"use strict";r.d(t,{v:function(){return ReshapePackedProgram}});var n=r(58257),a=r(37589);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ReshapePackedProgram=class ReshapePackedProgram{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=(0,n.C9)(this.outputShape.length);let r="";for(let e=0;e<4;e++){let t="thisRC = rc;";e%2==1&&(t+="thisRC.z += 1;"),e>1&&(t+="thisRC.y += 1;"),r+=`
        ${t}
        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${e}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${e>0?"}":""}
      `}this.userCode=`
      ${function(e,t){let r=t?a.al(["r","c","d"],"inputShape"):a.RW(["r","c","d"],e);return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${r}
      return ivec3(r, c, d);
    }
  `}(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?a.nc():a.ku(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${r}

        setOutput(result);
      }
    `}}},37589:function(e,t,r){"use strict";r.d(t,{Kn:function(){return getOutputLogicalCoordinatesFromFlatIndexByUniform},RW:function(){return getLogicalCoordinatesFromFlatIndex},al:function(){return getLogicalCoordinatesFromFlatIndexByUniform},ku:function(){return getFlatIndexFrom3D},nc:function(){return getFlatIndexFrom3DOutput},ye:function(){return a}});var n=r(82783);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getLogicalCoordinatesFromFlatIndex(e,t,r="index"){let a=n.D5U.computeStrides(t);return a.map((t,n)=>{let i=`int ${e[n]} = ${r} / ${t}`,o=n===a.length-1?`int ${e[n+1]} = ${r} - ${e[n]} * ${t}`:`index -= ${e[n]} * ${t}`;return`${i}; ${o};`}).join("")}function getOutputLogicalCoordinatesFromFlatIndexByUniform(e,t,r="index"){let a=n.D5U.computeStrides(t);return a.map((t,n)=>{let i=`int ${e[n]} = ${r} / outShapeStrides[${n}]`,o=n===a.length-1?`int ${e[n+1]} = ${r} - ${e[n]} * outShapeStrides[${n}]`:`index -= ${e[n]} * outShapeStrides[${n}]`;return`${i}; ${o};`}).join("")}function getLogicalCoordinatesFromFlatIndexByUniform(e,t,r="index"){let n=e.map((e,t)=>t),a=function(e,t){let r=e.length,n=e.map(e=>`${t}[${e}]`),a=Array(r-1);a[r-2]=n[r-1];for(let e=r-3;e>=0;--e)a[e]=`(${a[e+1]} * ${n[e+1]})`;return a}(n,t);return a.map((t,n)=>{let i=`int ${e[n]} = ${r} / ${a[n]}`,o=n===a.length-1?`int ${e[n+1]} = ${r} - ${e[n]} * ${a[n]}`:`index -= ${e[n]} * ${a[n]}`;return`${i}; ${o};`}).join("")}function getFlatIndexFrom3D(e){let t=n.D5U.computeStrides(e).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function getFlatIndexFrom3DOutput(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}let a=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`},15389:function(e,t,r){"use strict";r.d(t,{Se:function(){return getPackedRGBAArraySizeFromMatrixShape},Sq:function(){return getTextureConfig},V9:function(){return u},Yz:function(){return getDenseTexShape},kk:function(){return getUnpackedMatrixTextureShapeWidthHeight},m1:function(){return o},qe:function(){return getPackedMatrixTextureShapeWidthHeight},v2:function(){return s},yb:function(){return getUnpackedArraySizeFromMatrixSize}});var n,a,i,o,s,u,l=r(82783);function getUnpackedMatrixTextureShapeWidthHeight(e,t){return[t,e]}function getUnpackedArraySizeFromMatrixSize(e,t){return e*t}function getDenseTexShape(e){let t=l.D5U.sizeFromShape(e),r=Math.ceil(t/4);return l.D5U.sizeToSquarishShape(r)}function getPackedMatrixTextureShapeWidthHeight(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function getPackedRGBAArraySizeFromMatrixShape(e,t){let[r,n]=getPackedMatrixTextureShapeWidthHeight(e,t);return r*n*4}function getTextureConfig(e,t){let r,n,a,i,o,s,u,d,h,c;return 2===(0,l.OBj)().getNumber("WEBGL_VERSION")?(r=e.R32F,n=e.R16F,a=e.RGBA16F,i=e.RGBA32F,o=e.RED,u=4,d=1,h=e.HALF_FLOAT,c=e.FLOAT,s=e.RGBA8):(r=e.RGBA,n=e.RGBA,a=e.RGBA,i=e.RGBA,o=e.RGBA,u=4,d=4,h=null!=t?t.HALF_FLOAT_OES:null,c=e.FLOAT,s=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:n,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:s,downloadUnpackNumChannels:u,defaultNumChannels:d,textureTypeHalfFloat:h,textureTypeFloat:c}}(n=o||(o={}))[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH",(a=s||(s={}))[a.RENDER=0]="RENDER",a[a.UPLOAD=1]="UPLOAD",a[a.PIXELS=2]="PIXELS",a[a.DOWNLOAD=3]="DOWNLOAD",(i=u||(u={}))[i.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",i[i.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",i[i.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",i[i.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",i[i.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"},31089:function(e,t,r){"use strict";r.d(t,{I:function(){return TextureManager}});var n=r(82783),a=r(25121),i=r(15389);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TextureManager=class TextureManager{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,r){let n;let a=getPhysicalFromLogicalTextureType(t,r),o=getKeyFromTextureShape(e,a,r);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);let s=computeBytes(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();let e=this.freeTextures[o].pop();return this.usedTextures[o].push(e),e}return a===i.V9.PACKED_2X2_FLOAT32?n=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):a===i.V9.PACKED_2X2_FLOAT16?n=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):a===i.V9.UNPACKED_FLOAT32?n=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):a===i.V9.UNPACKED_FLOAT16?n=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):a===i.V9.PACKED_4X1_UNSIGNED_BYTE&&(n=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[o].push(n),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),n}releaseTexture(e,t,r,a){if(null==this.freeTextures)return;let i=getPhysicalFromLogicalTextureType(r,a),o=getKeyFromTextureShape(t,i,a);o in this.freeTextures||(this.freeTextures[o]=[]);let s=computeBytes(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,a),u=(0,n.OBj)().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==u&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=s):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=s),this.numUsedTextures--;let l=this.usedTextures[o],d=l&&l.indexOf(e);if(null==d||d<0)throw Error("Cannot release a texture that was never provided by this texture manager");l[d]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(let e in this.freeTextures)this.freeTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function computeBytes(e,t,r,n,o){let s;let u=function(e,t){switch(e){case i.V9.PACKED_2X2_FLOAT32:return(0,a.gl)(t);case i.V9.PACKED_2X2_FLOAT16:return(0,a.hf)(t);case i.V9.UNPACKED_FLOAT32:return(0,a.q3)(t);case i.V9.UNPACKED_FLOAT16:return(0,a.m8)(t);case i.V9.PACKED_4X1_UNSIGNED_BYTE:return(0,a.NQ)(t);default:throw Error(`Unknown physical texture type ${e}`)}}(t,n);if(o){let[t,r]=(0,i.qe)(e[0],e[1]);s=t*r}else{let[t,r]=(0,i.kk)(e[0],e[1]);s=t*r}let l=function(e,t){if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F||t===e.RGBA)return 16;if(t===e.RGBA16F)return 8;if(t===e.RGBA8)return 4;throw Error(`Unknown internal format ${t}`)}(r,u);return s*l}function getPhysicalFromLogicalTextureType(e,t){if(e===i.v2.UPLOAD)return i.V9.PACKED_2X2_FLOAT32;if(e===i.v2.RENDER||null==e)return(0,n.OBj)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?i.V9.PACKED_2X2_FLOAT32:i.V9.UNPACKED_FLOAT32:t?i.V9.PACKED_2X2_FLOAT16:i.V9.UNPACKED_FLOAT16;if(e===i.v2.DOWNLOAD||e===i.v2.PIXELS)return i.V9.PACKED_4X1_UNSIGNED_BYTE;throw Error(`Unknown logical texture type ${e}`)}function getKeyFromTextureShape(e,t,r){return`${e[0]}_${e[1]}_${t}_${r}`}},13150:function(e,t,r){"use strict";r.d(t,{Cv:function(){return s},D1:function(){return a},Et:function(){return o},RX:function(){return u},Tq:function(){return h},bl:function(){return d},eW:function(){return l},l:function(){return UnaryOpProgram},t$:function(){return i}});var n=r(58257);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let UnaryOpProgram=class UnaryOpProgram{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=(0,n.C9)(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}};let a="if (isnan(x)) return x;",i="return x;",o="return abs(x);",s="return (x >= 0.0) ? x : (exp(x) - 1.0);",u=a+`
  return (x < 0.0) ? 0.0 : x;
`,l=a+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,d="return x;",h="return 1.0 / (1.0 + exp(-1.0 * x));"},38595:function(e,t,r){"use strict";r.d(t,{Cv:function(){return i},RX:function(){return o},Tq:function(){return u},cc:function(){return UnaryOpPackedProgram},eW:function(){return s},t$:function(){return a}});var n=r(58257);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let a="return x;",i=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,o=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,s=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,u="return 1.0 / (1.0 + exp(-1.0 * x));";let UnaryOpPackedProgram=class UnaryOpPackedProgram{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=(0,n.C9)(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}},28063:function(e,t,r){"use strict";r.d(t,{W:function(){return UnpackProgram}});var n=r(58257),a=r(4573),i=r(10058);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let UnpackProgram=class UnpackProgram{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=(0,n.C9)(this.outputShape.length);let t=e.length,r=(0,a.Ky)("rc",t),o=(0,i.kW)(t),s=(0,a.Qc)(t,r),u=r.slice(-2),l=t<=1?"rc":`vec2(${u.join(",")})`;this.userCode=`
      void main() {
        ${o} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${l}));
      }
    `}}},67818:function(e,t,r){"use strict";let n,a;r.d(t,{B:function(){return bindTextureToProgramUniformSampler},BH:function(){return isDownloadFloatTextureEnabled},Cp:function(){return getBatchDim},ED:function(){return createStaticVertexBuffer},HH:function(){return getExtensionOrThrow},HO:function(){return createProgram},HS:function(){return assertNotComplex},Hg:function(){return getProgramUniformLocation},JG:function(){return bindColorTextureToFramebuffer},Jj:function(){return createVertexShader},KP:function(){return getMaxTexturesInShader},O7:function(){return callAndCheck},Qd:function(){return isWebGLFenceEnabled},W8:function(){return getRowsCols},XE:function(){return getProgramUniformLocationOrThrow},Yf:function(){return getTextureShapeFromLogicalShape},aj:function(){return linkProgram},ax:function(){return unbindColorTextureFromFramebuffer},b6:function(){return validateTextureSize},cU:function(){return createTexture},cu:function(){return validateFramebuffer},d8:function(){return createFramebuffer},ih:function(){return getShapeAs3D},lo:function(){return getWebGLMaxTextureSize},mZ:function(){return createStaticIndexBuffer},nr:function(){return getWebGLDisjointQueryTimerVersion},oT:function(){return isReshapeFree},qF:function(){return canBeRepresented},sb:function(){return bindVertexBufferToProgramAttribute},uH:function(){return isWebGLVersionEnabled},vu:function(){return validateProgram},w4:function(){return logShaderSourceAndInfoLog},wb:function(){return isCapableOfRenderingToFloatTexture},xc:function(){return createFragmentShader},y_:function(){return hasExtension}});var i=r(82783),o=r(58876),s=r(15389);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function callAndCheck(e,t){let r=t();return(0,i.OBj)().getBool("DEBUG")&&function(e){let t=e.getError();if(t!==e.NO_ERROR)throw Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),r}function canBeRepresented(e){return!!((0,i.OBj)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||596e-10<Math.abs(e)&&65504>Math.abs(e))}function getExtensionOrThrow(e,t){return throwIfNull(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function createVertexShader(e,t){let r=throwIfNull(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(callAndCheck(e,()=>e.shaderSource(r,t)),callAndCheck(e,()=>e.compileShader(r)),!1===e.getShaderParameter(r,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(r)),Error("Failed to compile vertex shader.");return r}function createFragmentShader(e,t){let r=throwIfNull(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(callAndCheck(e,()=>e.shaderSource(r,t)),callAndCheck(e,()=>e.compileShader(r)),(0,i.OBj)().get("ENGINE_COMPILE_ONLY"))return r;if(!1===e.getShaderParameter(r,e.COMPILE_STATUS))throw logShaderSourceAndInfoLog(t,e.getShaderInfoLog(r)),Error("Failed to compile fragment shader.");return r}let u=/ERROR: [0-9]+:([0-9]+):/g;function logShaderSourceAndInfoLog(e,t){let r=u.exec(t);if(null==r){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}let n=+r[1],a=e.split("\n"),o=a.length.toString().length+2,s=a.map((e,t)=>i.D5U.rightPad((t+1).toString(),o)+e),l=0;for(let e=0;e<s.length;e++)l=Math.max(s[e].length,l);let d=s.slice(0,n-1),h=s.slice(n-1,n),c=s.slice(n);console.log(d.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${i.D5U.rightPad(h[0],l)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function createProgram(e){return throwIfNull(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function linkProgram(e,t){if(callAndCheck(e,()=>e.linkProgram(t)),!(0,i.OBj)().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),Error("Failed to link vertex and fragment shaders.")}function validateProgram(e,t){if(callAndCheck(e,()=>e.validateProgram(t)),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),Error("Shader program validation failed.")}function createStaticVertexBuffer(e,t){let r=throwIfNull(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return callAndCheck(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),callAndCheck(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),r}function createStaticIndexBuffer(e,t){let r=throwIfNull(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return callAndCheck(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,r)),callAndCheck(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),r}function createTexture(e){return throwIfNull(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function validateTextureSize(e,t){let r=(0,i.OBj)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){let r=`[${e}x${t}]`;throw Error("Requested texture size "+r+" is invalid.")}if(e>r||t>r){let n=`[${e}x${t}]`,a=`[${r}x${r}]`;throw Error("Requested texture size "+n+" greater than WebGL maximum on this browser / GPU "+a+".")}}function createFramebuffer(e){return throwIfNull(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function bindVertexBufferToProgramAttribute(e,t,r,n,a,i,o){let s=e.getAttribLocation(t,r);return -1!==s&&(callAndCheck(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),callAndCheck(e,()=>e.vertexAttribPointer(s,a,e.FLOAT,!1,i,o)),callAndCheck(e,()=>e.enableVertexAttribArray(s)),!0)}function getProgramUniformLocationOrThrow(e,t,r){return throwIfNull(e,()=>e.getUniformLocation(t,r),'uniform "'+r+'" not present in program.')}function getProgramUniformLocation(e,t,r){return e.getUniformLocation(t,r)}function bindTextureToProgramUniformSampler(e,t,r,n){callAndCheck(e,()=>{(function(e,t){let r=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,n=t+e.TEXTURE0;if(n<e.TEXTURE0||n>r){let e=`[gl.TEXTURE0, gl.TEXTURE${r}]`;throw Error(`textureUnit must be in ${e}.`)}})(e,n),callAndCheck(e,()=>e.activeTexture(e.TEXTURE0+n)),callAndCheck(e,()=>e.bindTexture(e.TEXTURE_2D,t))}),callAndCheck(e,()=>e.uniform1i(r,n))}function bindColorTextureToFramebuffer(e,t,r){callAndCheck(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,r)),callAndCheck(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function unbindColorTextureFromFramebuffer(e,t){callAndCheck(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),callAndCheck(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function validateFramebuffer(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function throwIfNull(e,t,r){let n=callAndCheck(e,()=>t());if(null==n)throw Error(r);return n}function getBatchDim(e,t=2){return i.D5U.sizeFromShape(e.slice(0,e.length-t))}function getRowsCols(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function getShapeAs3D(e){let t=[1,1,1],r=0===e.length||1===e.length&&1===e[0];return r||(t=[getBatchDim(e),...getRowsCols(e)]),t}function getTextureShapeFromLogicalShape(e,t=!1){let r=(0,i.OBj)().getNumber("WEBGL_MAX_TEXTURE_SIZE"),n=(0,i.OBj)().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(n===1/0&&(0,i.OBj)().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(n=r/2),t&&(r*=2,n*=2,1===(e=e.map((t,r)=>r>=e.length-2?i.D5U.nearestLargerEven(e[r]):e[r])).length&&(e=[2,e[0]])),2!==e.length){let t=i.D5U.squeezeShape(e);e=t.newShape}let a=i.D5U.sizeFromShape(e),o=null;e.length<=1&&a<=r?o=[1,a]:2===e.length&&e[0]<=r&&e[1]<=r?o=e:3===e.length&&e[0]*e[1]<=r&&e[2]<=r?o=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=r&&e[1]*e[2]<=r?o=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=r&&e[3]<=r?o=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=r&&e[1]*e[2]*e[3]<=r&&(o=[e[0],e[1]*e[2]*e[3]]);let s=null!=o&&Math.max(...o)>n&&Math.min(...o)<=(t?2:1)&&Math.min(...o)>0;if(null==o||s){if(t){let t=getBatchDim(e),r=2,n=2;e.length&&([r,n]=getRowsCols(e)),a=t*(r/2)*(n/2),o=i.D5U.sizeToSquarishShape(a).map(e=>2*e)}else o=i.D5U.sizeToSquarishShape(a)}return o}function isReshapeFree(e,t){if(e=e.slice(-2),t=t.slice(-2),i.D5U.arraysEqual(e,t)||!e.length||!t.length||0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){let r=e[e.length-1],n=t[t.length-1];if(r===n||r%2==0&&n%2==0&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&e[0]%2==0&&t[0]%2==0}function getWebGLMaxTextureSize(e){if(null==n){let t=(0,o.jl)(e);n=t.getParameter(t.MAX_TEXTURE_SIZE)}return n}function getMaxTexturesInShader(e){if(null==a){let t=(0,o.jl)(e);a=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,a)}function getWebGLDisjointQueryTimerVersion(e){if(0===e)return 0;let t=(0,o.jl)(e);return hasExtension(t,"EXT_disjoint_timer_query_webgl2")&&2===e?2:hasExtension(t,"EXT_disjoint_timer_query")?1:0}function hasExtension(e,t){let r=e.getExtension(t);return null!=r}function isWebGLVersionEnabled(e){try{let t=(0,o.jl)(e);if(null!=t)return!0}catch(e){console.log("Error when getting WebGL context: ",e)}return!1}function isCapableOfRenderingToFloatTexture(e){if(0===e)return!1;let t=(0,o.jl)(e);if(1===e){if(!hasExtension(t,"OES_texture_float"))return!1}else if(!hasExtension(t,"EXT_color_buffer_float"))return!1;let r=createFloatTextureAndBindToFramebuffer(t);return r}function isDownloadFloatTextureEnabled(e){if(0===e)return!1;let t=(0,o.jl)(e);if(1===e){if(!hasExtension(t,"OES_texture_float")||!hasExtension(t,"WEBGL_color_buffer_float"))return!1}else{if(hasExtension(t,"EXT_color_buffer_float"))return createFloatTextureAndBindToFramebuffer(t);let e="EXT_color_buffer_half_float";if(hasExtension(t,e)){let r=t.getExtension(e);return function(e,t){let r=(0,s.Sq)(e,t),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,r.internalFormatHalfFloat,1,1,0,r.textureFormatFloat,r.textureTypeHalfFloat,null);let a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),i}(t,r)}return!1}let r=createFloatTextureAndBindToFramebuffer(t);return r}function createFloatTextureAndBindToFramebuffer(e){let t=(0,s.Sq)(e),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let n=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,n),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(n),a}function isWebGLFenceEnabled(e){if(2!==e)return!1;let t=(0,o.jl)(e),r=null!=t.fenceSync;return r}function assertNotComplex(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&i.D5U.assert("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}},17754:function(e,t,r){"use strict";let n;var a,i,o,s,u,l,d,h,c,p,f=r(82783);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let m=(0,f.OBj)();m.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15),m.registerFlag("WEBGPU_CPU_FORWARD",()=>!0),m.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1),m.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0),m.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1),m.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3),m.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1),m.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0),m.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1),m.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1),m.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1),m.registerFlag("WEBGPU_PRINT_SHADER",()=>""),m.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let AdapterInfo=class AdapterInfo{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return"intel"===this.vendor}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let BufferManager=class BufferManager{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,t,r=!1,n=!0){let a;let i=`${e}_${t}`;return n?(this.freeBuffers.has(i)||this.freeBuffers.set(i,[]),this.freeBuffers.get(i).length>0?(a=this.freeBuffers.get(i).pop(),this.numFreeBuffers--):(a=this.device.createBuffer({size:e,usage:t,mappedAtCreation:r}),this.numBytesAllocated+=e)):(a=this.device.createBuffer({size:e,usage:t,mappedAtCreation:r}),this.numBytesAllocated+=e),this.usedBuffers.has(i)||this.usedBuffers.set(i,[]),this.usedBuffers.get(i).push(a),this.numUsedBuffers++,this.numBytesUsed+=e,a}releaseBuffer(e,t=!0){if(0===this.freeBuffers.size)return;let r=e.size,n=e.usage,a=`${r}_${n}`,i=this.usedBuffers.get(a),o=i.indexOf(e);if(o<0)throw Error("Cannot find the buffer in buffer manager");i[o]=i[i.length-1],i.pop(),this.numUsedBuffers--,this.numBytesUsed-=r,t?(this.freeBuffers.get(a).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=r)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,t)=>{e.forEach(e=>{e.destroy()})}),this.usedBuffers.forEach((e,t)=>{e.forEach(e=>{e.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TextureManager=class TextureManager{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,r,n){let a=getBytesPerElement(r),i=e*t*a,o=getTextureKey(e,t,r,n);if(this.freeTextures.has(o)||this.freeTextures.set(o,[]),this.usedTextures.has(o)||this.usedTextures.set(o,[]),this.numBytesUsed+=i,this.numUsedTextures++,this.freeTextures.get(o).length>0){this.numFreeTextures--;let e=this.freeTextures.get(o).shift();return this.usedTextures.get(o).push(e),e}this.numBytesAllocated+=i;let s=this.device.createTexture({size:[e,t],format:r,usage:n});return this.usedTextures.get(o).push(s),s}releaseTexture(e){if(0===this.freeTextures.size)return;let t=e.width,r=e.height,n=e.format,a=e.usage,i=getTextureKey(t,r,n,a);this.freeTextures.has(i)||this.freeTextures.set(i,[]),this.freeTextures.get(i).push(e),this.numFreeTextures++,this.numUsedTextures--;let o=this.usedTextures.get(i),s=o.indexOf(e);if(s<0)throw Error("Cannot release a texture that was never provided by this texture manager");o.splice(s,1);let u=getBytesPerElement(n),l=t*r*u;this.numBytesUsed-=l}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,t)=>{e.forEach(e=>{e.destroy()})}),this.usedTextures.forEach((e,t)=>{e.forEach(e=>{e.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}};function getTextureKey(e,t,r,n){return`${e}_${t}_${r}_${n}`}function getBytesPerElement(e){if("rgba8unorm"===e)return 16;throw Error(`${e} is not supported!`)}let atomicAddSnippet=(e,t,r)=>"int32"===r?`atomicAdd(${e}, bitcast<i32>(${t}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${t});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${e}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;(a=l||(l={}))[a.FROM_PIXELS=0]="FROM_PIXELS",a[a.DRAW=1]="DRAW";let compileProgram=(e,t,r,n,a)=>{let i={dtype:n.dtype,shape:n.shape},o=function(e,t,r){var n;let a;let i=[],o=r.workgroupSize[0]*r.workgroupSize[1]*r.workgroupSize[2];if(r.outputComponent=r.outputComponent?r.outputComponent:1,i.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${isFlatDispatch(r)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${o}u +
                localIndex);
        `}
      }
    `),null!=r.pixelsOpType){let n=r.pixelsOpType===l.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${dataTypeToGPUType(t.dtype,r.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${dataTypeToGPUType(e[0].dtype,r.outputComponent)}>;`,a=3===t.shape.length?"vec2<i32>":"i32";i.push(`
        struct Uniform {
          outShapeStrides : ${a},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${n}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);let o=isFlatDispatchLayout(r);return[g,i.join("\n"),getCoordsFromIndexSnippet(t.shape),r.getUserCode(),getStartHeaderString(o,r)].join("\n")}let s="struct Uniforms { NAN : f32, INFINITY : f32, ";r.variableNames.forEach((t,r)=>{let n=getCoordsDataType(e[r].shape.length);s+=`${t.charAt(0).toLowerCase()+t.slice(1)}Shape : ${n}, `,a=getCoordsDataType(e[r].shape.length-1),s+=`${t.charAt(0).toLowerCase()+t.slice(1)}ShapeStrides: ${a}, `});let u=getCoordsDataType(t.shape.length);s+=`outShape : ${u}, `,a=getCoordsDataType(t.shape.length-1),s+=`
         outShapeStrides: ${a}, `,r.size&&(s+="size : i32, "),r.uniforms&&(s+=r.uniforms),s+="};",s=s.replace(/(\w+)\s*:\s*vec(5|6)/g,e=>"@align(16) "+e).replace(/vec(5|6)\s*,\s*(\w+)/g,(e,t,r)=>`vec${t}, @align(16) ${r}`),i.push(s),r.atomic?i.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):i.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${dataTypeToGPUType(t.dtype,r.outputComponent)}>;
    `),r.variableNames.forEach((t,n)=>{i.push(`
      @group(0) @binding(${1+n}) var<storage, read> ${t}: array<${r.variableComponents?dataTypeToGPUType(e[n].dtype,r.variableComponents[n]):dataTypeToGPUType(e[n].dtype,r.outputComponent)}>;
        `)}),""!==s&&i.push(`
      @group(0) @binding(${1+r.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);let d=function(e,t){let{x:r,y:n=[],z:a=[]}=t,i=e.length,o=r.length+n.length+a.length;if(o!==i)return"";if(r.length===i){let e=getCoordsDataType(i),t=`fn getOutputCoords() -> ${e}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;return t}let s="",u=[r,n,a];for(let e=0;e<u.length;e++){let t=u[e];if(0!==t.length){if(1===t.length)s+=`let d${t[0]} = i32(globalId[${e}]);`;else{let r=/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t){if(Math.max(...e)>5)throw Error("Cannot symbolically compute strides for rank > 6 tensor.");let r=e.length,n=e.map(e=>`${t}.${"xyzwuv"[e]}`),a=Array(r-1);a[r-2]=n[r-1];for(let e=r-3;e>=0;--e)a[e]=`(${a[e+1]} * ${n[e+1]})`;return a}(t,"uniforms.outShape");s+=`var index${e} = i32(globalId[${e}]);`;for(let n=0;n<r.length;n++)s+=`let d${t[n]} = index${e} / ${r[n]};`,n===r.length-1?s+=`let d${t[n+1]} = index${e} - d${t[n]} * ${r[n]};`:s+=`index${e} = index${e} - d${t[n]} * ${r[n]};`}}}let l=[];for(let e=0;e<o;e++)l.push(`d${e}`);let d=getCoordsDataType(o),h=`fn getOutputCoords() -> ${d} {
  ${s}
`;return 0===l.length?h+=`return ${d}(0); }`:h+=`return ${d}(${l.join(",")}); }`,h}(t.shape,r.dispatchLayout),h=[g,i.join("\n")+y,getCoordsFromIndexSnippet(t.shape),d,function(e){let t="";switch(e){case 0:case 1:t+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:t+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:t+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:t+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:t+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:t+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:f.D5U.assert(!1,()=>`Unsupported ${e}D shape`)}return t}(t.shape.length)];r.atomic||h.push(function(e,t,r){let n=e.length,a=dataTypeToGPUType(t,r),i=`fn setOutputAtIndex(flatIndex : i32, value : ${typeSnippet(r)}) {
      result[flatIndex] = ${a}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${typeSnippet(r,"i32")}) {
      result[flatIndex] = ${a}(value);
    }
    `;if(n>=2){let e=["d0","d1","d2","d3","d4","d5"].slice(0,n),t=getCoordsDataType(n);i+=`
      fn setOutputAtCoords(${e.map(e=>`${e} : i32`).join(", ")}, value : ${typeSnippet(r)}) {
        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));
        setOutputAtIndex(flatIndex${1===r?"":` / ${r}`}, value);
      }
      fn setOutputAtCoordsI32(${e.map(e=>`${e} : i32`).join(", ")}, value : ${typeSnippet(r,"i32")}) {
        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));
        setOutputAtIndexI32(flatIndex${1===r?"":` / ${r}`}, value);
      }
    `}return i}(t.shape,t.dtype,r.outputComponent)),r.variableNames.forEach((t,r)=>{h.push(`${getCoordsFromIndexSnippet(e[r].shape,t)}`)});let c=e.map((e,n)=>(function(e,t,r,n){let a=function(e,t){let r=e.name,n=e.shape.length,a=getCoordsDataType(n),i="get"+r.charAt(0).toUpperCase()+r.slice(1),o=["d0","d1","d2","d3","d4","d5"].slice(0,n),s=o.map(e=>`${e} : i32`).join(", ");if(n<1)return`
      fn ${i}() -> ${typeSnippet(t)} {
        return ${typeSnippet(t)}(${r}[0]);
      }
    `;let u=`uniforms.${r.charAt(0).toLowerCase()+r.slice(1)}Shape`,l=`${n}D`;return 0===n&&(l="1D"),`
    fn ${i}(${s}) -> ${typeSnippet(t)} {
      return ${typeSnippet(t)}(${r}[getIndexFromCoords${l}(${a}(${o.join(",")}),
        ${u})${1===t?"":` / ${t}`}]);
    }
   `}(e,r),i=e.shape;return i.length<=t.length&&(a+=function(e,t,r,n){let a=e.name,i=a.charAt(0).toUpperCase()+a.slice(1),o="get"+i+"ByOutput",s=e.shape.length,u=t.length,l=getCoordsDataType(u);if(f.D5U.arraysEqual(e.shape,t)&&n)return`
    fn ${o}Index(globalIndex : i32) -> ${typeSnippet(r)} {
      return ${typeSnippet(r)}(${a}[globalIndex]);
    }

    fn ${o}Coords(coords : ${l}) -> ${typeSnippet(r)} {
      return ${typeSnippet(r)}(${a}[${u>1?"getOutputIndexFromCoords(coords)":"coords"}${1===r?"":` / ${r}`}]);
    }
    `;let d=f.backend_util.getBroadcastDims(e.shape,t),h=u-s,c="";if(0===s)return`
    fn ${o}Index(globalIndex : i32) -> ${typeSnippet(r)}{
      return get${i}();
    }

    fn ${o}Coords(coords : ${l}) -> ${typeSnippet(r)}{
      return get${i}();
    }
  `;c=u<2&&d.length>=1?"coords = 0;":d.map(e=>`coords.${getCoordsXYZ(e+h)} = 0;`).join("\n");let p="";if(u<2&&s>0)p="coords";else if(u>1){let t=getCoordsDataType(s),r=e.shape.map((e,t)=>`coords.${getCoordsXYZ(t+h)}`).join(", ");p=`${t}(${r})`}else p="coords";let m=`uniforms.${a.charAt(0).toLowerCase()+a.slice(1)}Shape`,g=`${s}D`;return`
  fn ${o}Index(globalIndex : i32) -> ${typeSnippet(r)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${c}
    return ${typeSnippet(r)}(${a}[getIndexFromCoords${g}(${p}, ${m})${1===r?"":` / ${r}`}]);
  }

  fn ${o}Coords(coordsIn : ${l}) -> ${typeSnippet(r)} {
    var coords = coordsIn;
    ${c}
    return ${typeSnippet(r)}(${a}[getIndexFromCoords${g}(${p}, ${m})${1===r?"":` / ${r}`}]);
  }
`}(e,t,r,n)),a})(e,t.shape,r.variableComponents?r.variableComponents[n]:r.outputComponent,r.dispatchLayout.x.length===t.shape.length)).join("\n");h.push(c),h.push(r.getUserCode());let p=isFlatDispatchLayout(r);h.push(getStartHeaderString(p,r));let m=h.join("\n");return m}(r,i,t),s=e.createShaderModule({code:o,label:t.constructor.name}),u=(0,f.OBj)().get("WEBGPU_PRINT_SHADER");if(""!==u){u=u.toLowerCase();let e=u.split(",");("all"===u||e.some(e=>t.shaderKey.toLowerCase().includes(e)))&&(console.group(t.shaderKey),console.debug(o),console.groupEnd())}return a?e.createComputePipelineAsync({compute:{module:s,entryPoint:"_start"},label:t.constructor.name,layout:"auto"}):e.createComputePipeline({compute:{module:s,entryPoint:"_start"},label:t.constructor.name,layout:"auto"})},typeSnippet=(e,t="f32")=>{switch(e){case 1:return`${t}`;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw Error(`${e}-component ${t} is not supported.`)}};function getCoordsDataType(e){if(e<=1)return"i32";if(2===e)return"vec2<i32>";if(3===e)return"vec3<i32>";if(4===e)return"vec4<i32>";if(5===e)return"vec5";if(6===e)return"vec6";throw Error(`GPU for rank ${e} is not yet supported`)}function getCoordsXYZ(e){if(0===e)return"x";if(1===e)return"y";if(2===e)return"z";if(3===e)return"w";if(4===e)return"u";if(5===e)return"v";throw Error(`Index ${e} is not yet supported`)}function getMainHeaderString(...e){let t;switch(e.length){case 0:t=`
        fn main()
      `;break;case 1:t=`
        fn main(${e[0]} : i32)
      `;break;default:throw Error("Unreachable")}return t}function getStartHeaderString(e,t){return`
     
  @compute @workgroup_size(${t.workgroupSize[0]}, ${t.workgroupSize[1]}, ${t.workgroupSize[2]})

      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${e?"main(getGlobalIndex());":"main();"};
      }
    `}let g=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,y=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function getCoordsFromIndexSnippet(e,t=""){let r;let n=e.length,a=""!==t?`get${t.charAt(0).toUpperCase()+t.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",i=""!==t?`${t.charAt(0).toLowerCase()+t.slice(1)}ShapeStrides`:"outShapeStrides";if(n<=1)return`fn ${a}(index : i32) -> i32 { return index; }`;let o=f.D5U.computeStrides(e),s=getCoordsDataType(n),u=[];for(let e=0;e<n;e++)u.push(`d${e}`);return 1===o.length?`    fn ${a}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${i}; let d1 = index - d0 * uniforms.${i};
      return vec2<i32>(d0, d1);
    }`:(r="var index2 = index;"+o.map((e,t)=>{let r=`let ${u[t]} = index2 / uniforms.${i}.${getCoordsXYZ(t)}`,n=t===o.length-1?`let ${u[t+1]} = index2 - ${u[t]} * uniforms.${i}.${getCoordsXYZ(t)}`:`index2 = index2 - ${u[t]} * uniforms.${i}.${getCoordsXYZ(t)}`;return`${r}; ${n};`}).join(""),`
    fn ${a}(index : i32) -> ${s} {
      ${r}
      return ${s}(${u.join(",")});
    }
  `)}function isFlatDispatch(e){return 1===e.dispatch[1]&&1===e.dispatch[2]}function dataTypeToGPUType(e,t=1){if("float32"===e)return typeSnippet(t,"f32");if("int32"===e||"bool"===e)return typeSnippet(t,"i32");throw Error(`type ${e} is not supported.`)}function isFlatDispatchLayout(e){return!(e.dispatchLayout.hasOwnProperty("y")&&0!==e.dispatchLayout.y.length||e.dispatchLayout.hasOwnProperty("z")&&0!==e.dispatchLayout.z.length)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let arrayProduct=e=>{let t=1;for(let r=0;r<e.length;r++)t*=e[r];return t};function computeDispatch(e,t,r=[1,1,1],n=[1,1,1]){let[a,i,o]=[Math.ceil(arrayProduct(e.x.map(e=>t[e]))/(r[0]*n[0])),e.y?Math.ceil(arrayProduct(e.y.map(e=>t[e]))/(r[1]*n[1])):1,e.z?Math.ceil(arrayProduct(e.z.map(e=>t[e]))/(r[2]*n[2])):1];return[a,i,o]}function computeWorkgroupSizeForConv2d(e,t,r=!1){if(r)return[8,8,1];let n=arrayProduct(e.x.map(e=>t[e])),a=arrayProduct(e.y.map(e=>t[e]));return n<=4?[4,16,1]:a<=4?[16,4,1]:[16,16,1]}function computeWorkPerThreadForConv2d(e,t,r=!1){if(r)return[4,4,1];let n=arrayProduct(e.x.map(e=>t[e])),a=arrayProduct(e.y.map(e=>t[e]));return n<=4?[1,2,1]:a<=4?[2,1,1]:[2,2,1]}function flatDispatchLayout(e){return{x:e.map((e,t)=>t)}}function GPUBytesPerElement(e){if("float32"===e||"int32"===e||"bool"===e||"string"===e)return 4;if("complex64"===e)return 8;throw Error(`Unknown dtype ${e}`)}function isWebGPUSupported(){return!!("undefined"!=typeof globalThis&&globalThis.navigator&&globalThis.navigator.gpu)}function assertNotComplex(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&f.D5U.assert("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGPU backend.`)})}(i=d||(d={}))[i.MatMulReduceProgram=0]="MatMulReduceProgram",i[i.MatMulSplitKProgram=1]="MatMulSplitKProgram",i[i.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",i[i.MatMulPackedProgram=3]="MatMulPackedProgram",i[i.MatMulMax=4]="MatMulMax";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let x=(0,f.OBj)().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),reshapeDispatch=(e,t)=>{let r=e.limits.maxComputeWorkgroupsPerDimension,n=t.dispatchLayout,a=t.dispatch;if(a.every(e=>e<=r))return a;f.D5U.assert(a[0]>r&&void 0===n.y&&void 0===n.z,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let i=Math.ceil(Math.sqrt(a[0]));return i>r?(i=Math.ceil(Math.cbrt(a[0])),f.D5U.assert(i<=r,()=>"Total dispatch size exceeds WebGPU maximum."),[i,i,i]):[i,i,1]};let WebGPUBackend=class WebGPUBackend extends f.Zuw{nextDataId(){return WebGPUBackend.nextDataId++}constructor(e,t){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!isWebGPUSupported())throw Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new AdapterInfo(t),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new BufferManager(this.device),this.textureManager=new TextureManager(this.device),this.tensorMap=new f.JLz(this,(0,f.SRH)()),(0,f.OBj)().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e,t=!1){if(!this.tensorMap.has(e))return!0;let r=this.tensorMap.get(e);return t?r.refCount=0:r.refCount--,!(r.refCount>0)&&((null!=r.complexTensorInfos&&(this.disposeData(r.complexTensorInfos.real.dataId),this.disposeData(r.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e))?this.tensorDataPendingDisposal.push(e):(this.releaseResource(e),this.tensorMap.delete(e)),!0)}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){let t=this.tensorMap.get(e);if(t&&t.resource){if(t.external){t.resource=null;return}t.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(t.resource):t.resource instanceof GPUTexture&&this.textureManager.releaseTexture(t.resource),t.resource=null}}refCount(e){if(this.tensorMap.has(e)){let t=this.tensorMap.get(e);return t.refCount}return 0}incRef(e){let t=this.tensorMap.get(e);t.refCount++}decRef(e){if(this.tensorMap.has(e)){let t=this.tensorMap.get(e);t.refCount--}}write(e,t,r){if("complex64"===r&&null!=e)throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let n={id:this.nextDataId()};return this.tensorMap.set(n,{dtype:r,shape:t,values:e,refCount:1}),n}move(e,t,r,n,a){if("complex64"===n)throw Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:n,shape:r,values:t,refCount:a})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let e;try{e=await Promise.all(Object.values(this.pipelineCache))}catch(e){throw Error(e.message)}Object.keys(this.pipelineCache).map((t,r)=>{this.pipelineCache[t]=e[r]})}async getBufferData(e){if((0,f.OBj)().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;let t=e.size,r=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,r,0,t),this.submitQueue(),await r.mapAsync(GPUMapMode.READ);let n=r.getMappedRange().slice(0);return r.unmap(),null!=r&&this.bufferManager.releaseBuffer(r),(0,f.OBj)().getBool("WEBGPU_USE_PROFILE_TOOL")&&(f.D5U.assert(void 0!==this.dummyContext,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),n}convertAndCacheOnCPU(e,t){let r=this.tensorMap.get(e);return r.values=t,r.values}readSync(e){let t=this.tensorMap.get(e),{values:r,complexTensorInfos:n}=t;if(null!=r||"string"===t.dtype)return r;if("complex64"===t.dtype){let t=this.readSync(n.real.dataId),r=this.readSync(n.imag.dataId),a=f.D5U.convertBackendValuesAndArrayBuffer(f.backend_util.mergeRealAndImagArrays(t,r).buffer,"float32");return this.convertAndCacheOnCPU(e,a),a}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));let a=["opaque","premultiplied"],i=t.resource,o=i.size;f.D5U.assert(o%4==0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");let s=o/4,u=new ArrayBuffer(o),l=a.map(e=>new OffscreenCanvas(256,256)),d=new OffscreenCanvas(256,256);this.endComputePassEncoder(),l.map((e,t)=>{let r=e.getContext("webgpu");return r.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:a[t]}),r.getCurrentTexture()}).map((e,t)=>{let readDataGPUToCPU=(r,n,o)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:i,bytesPerRow:1024,offset:o},{texture:e},{width:r,height:n}),this.submitQueue();let s=d.getContext("2d",{willReadFrequently:!0});s.clearRect(0,0,r,n),s.drawImage(l[t],0,0);let h=s.getImageData(0,0,r,n).data,c=a[t],p=new Uint8ClampedArray(u,o,r*n*4);for(let e=0;e<p.length;e+=4)if("premultiplied"===c)p[e+3]=h[e+3];else{let t=h[e];p[e]=h[e+2],p[e+1]=h[e+1],p[e+2]=t}},r=Math.floor(s/65536),n=256,o=256,h=0;for(let e=0;e<r;e++)readDataGPUToCPU(n,o,h),h+=262144;let c=s%65536;(o=Math.floor(c/256))>0&&(readDataGPUToCPU(n,o,h),h+=1024*o),(n=c%256)>0&&readDataGPUToCPU(n,1,h)});let h=f.D5U.convertBackendValuesAndArrayBuffer(u,t.dtype);return this.convertAndCacheOnCPU(e,h),h}async read(e){let t;if(!this.tensorMap.has(e))throw Error(`Tensor ${e} was not registered!`);let r=this.tensorMap.get(e),{values:n}=r;if(null!=n)return n;if("complex64"===r.dtype){let e=await Promise.all([this.read(r.complexTensorInfos.real.dataId),this.read(r.complexTensorInfos.imag.dataId)]),n=e[0],a=e[1];t=f.backend_util.mergeRealAndImagArrays(n,a)}else{let e=await this.getBufferData(r.resource);t=f.D5U.convertBackendValuesAndArrayBuffer(e,r.dtype)}return this.convertAndCacheOnCPU(e,t),t}copyBuffer(e){let t=e.size,r=e.usage,n=this.bufferManager.acquireBuffer(t,r);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,n,0,t),this.submitQueue(),n}createTensorFromGPUData(e,t,r){let n=e.buffer;if("complex64"===r)throw Error("Cannot write to a complex64 dtype. ");let a={id:this.nextDataId()};this.tensorMap.set(a,{dtype:r,shape:t,values:null,refCount:1,external:e.zeroCopy});let i=this.tensorMap.get(a),o=GPUBytesPerElement(i.dtype)*f.D5U.sizeFromShape(i.shape);if(e.buffer.size<o)throw Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${o})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!=(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return!0!==e.zeroCopy&&(n=this.copyBuffer(n)),i.resource=n,(0,f.SRH)().makeTensorFromDataId(a,t,r,this)}readToGPU(e){let t=this.tensorMap.get(e),{values:r,dtype:n,shape:a,resource:i}=t;if("complex64"===n)throw Error("Does not support reading buffer for complex64 dtype.");if(null==i){if(null!=r)throw Error("Data is not on GPU but on CPU.");throw Error("There is no data on GPU or CPU.")}let o=i.size,s=i.usage,u=this.bufferManager.acquireBuffer(o,s);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(i,0,u,0,o),this.submitQueue();let l=this.makeTensorInfo(a,n),d=(0,f.SRH)().makeTensorFromTensorInfo(l),h=this.tensorMap.get(l.dataId);return h.resource=u,{tensorRef:d,buffer:u}}bufferSync(e){let t=this.readSync(e.dataId);if("string"===e.dtype)try{let r=t.map(e=>f.D5U.decodeString(e));return(0,f.f3b)(e.shape,e.dtype,r)}catch(e){throw Error("Failed to decode encoded string bytes into utf-8")}return(0,f.f3b)(e.shape,e.dtype,t)}async time(e){this.supportTimestampQuery||this.hasTimestampQueryWarned||(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);let t=this.activeTimers,r=[],n=!1;null==this.programTimersStack?(this.programTimersStack=r,n=!0):this.activeTimers.push(r),this.activeTimers=r,e();let a=f.D5U.flatten(this.activeTimers.map(e=>e.query)).filter(e=>null!=e),i=f.D5U.flatten(this.activeTimers.map(e=>e.name)).filter(e=>null!=e);this.activeTimers=t,n&&(this.programTimersStack=null);let o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},s=await Promise.all(a);return o.kernelMs=f.D5U.sum(s),o.getExtraProfileInfo=()=>s.map((e,t)=>({name:i[t],ms:e})).map(e=>`${e.name}: ${e.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,o}makeTensorInfo(e,t,r){"string"===t&&null!=r&&r.length>0&&f.D5U.isString(r[0])&&(r=r.map(e=>f.D5U.encodeString(e)));let n=this.write(r,e,t);return{dataId:n,shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;let t=this.tensorMap.get(e.dataId),r=t.resource;return r instanceof GPUBuffer?{buffer:r}:r instanceof GPUTexture?r.createView():r}uploadToGPU(e){let t;let r=this.tensorMap.get(e);if(null!=r.resource)return;let n=GPUBytesPerElement(r.dtype)*f.D5U.sizeFromShape(r.shape),a=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(r.values){if("unmapped"===(t=this.bufferManager.acquireBuffer(n,a,!0)).mapState){let e=this.bufferManager.acquireBuffer(n,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),a=e.getMappedRange();"int32"===r.dtype||"bool"===r.dtype?new Int32Array(a).set(r.values):new Float32Array(a).set(r.values),e.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,t,0,n),this.stagingPendingDisposal.push(e)}else{let e=t.getMappedRange();"int32"===r.dtype||"bool"===r.dtype?new Int32Array(e).set(r.values):new Float32Array(e).set(r.values),t.unmap()}r.values=null}else t=this.bufferManager.acquireBuffer(n,a);r.resource=t}makeUniforms(e){let t=0,r=0,n=[],a=1;e.forEach(e=>{let i;switch(0===e.data.length&&(e.data=[1]),e.data.length){case 1:i=4;break;case 2:i=8;break;case 3:case 4:case 5:case 6:i=16;break;default:f.D5U.assert(!1,()=>`Unsupported ${e.data.length}D shape`)}(5===r||6===r)&&(i=16),i>a&&(a=i),t=Math.ceil(t/i)*i,r=e.data.length,n.push(t),t+=4*e.data.length}),t=Math.ceil(t/a)*a;let i=new ArrayBuffer(t);e.forEach((e,t)=>{let r=n[t];"int32"===e.type?new Int32Array(i,r,e.data.length).set(e.data):"uint32"===e.type?new Uint32Array(i,r,e.data.length).set(e.data):new Float32Array(i,r,e.data.length).set(e.data)});let o=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(o,0,i,0,t),this.uniformPendingDisposal.push(o),{offset:0,size:t,buffer:o}}runWebGPUProgram(e,t,r,n,a){if(a||(a=this.makeTensorInfo(e.outputShape,r)),0===f.D5U.sizeFromShape(a.shape))return this.tensorMap.get(a.dataId).values=f.D5U.getTypedArrayFromDType(a.dtype,0),a;this.uploadToGPU(a.dataId),e.dispatch=reshapeDispatch(this.device,e);let i=t.map((t,r)=>{if("complex64"===t.dtype)throw Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(t.dataId),{dtype:this.tensorMap.get(t.dataId).dtype,shape:t.shape,name:e.variableNames[r]}});e.shaderKey=function(e,t,r){let n=e.shaderKey;if(null!=e.pixelsOpType)return n;let a=[],i=[];t.forEach(e=>{a.push(e.shape),i.push(e.dtype)}),a.push(r.shape),i.push(r.dtype);let o=t.map(e=>f.backend_util.getBroadcastDims(e.shape,r.shape)),s=t.map(e=>f.D5U.arraysEqual(e.shape,r.shape)).join("_"),u=o.map(e=>e.join("_")).join(";"),l=isFlatDispatch(e)?"flatDispatch":"";return n+("_"+(e.workgroupSize?e.workgroupSize.join(","):"")+a.map(e=>e.length).join(",")+i.join(",")+e.variableNames.join(",")+u+s)+l}(e,i,a);let o=(0,f.OBj)().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=compileProgram(this.device,e,i,a,o)),e.pipeline=this.pipelineCache[e.shaderKey],o||this.recordAndSubmit(e,a,t,n),a}recordAndSubmit(e,t,r,n){if(e.pipeline instanceof Promise)throw Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let a=[],i=[],o="int32";if(null==e.pixelsOpType){a.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),i=r.concat(t).map(e=>e.shape);let e="int32";i.map(t=>{a.push({type:e,data:t});let r=f.D5U.computeStrides(t);a.push({type:e,data:r})})}else{let e=f.D5U.computeStrides(t.shape);a.push({type:o,data:e})}if(e.size){let t=f.D5U.sizeFromShape(e.outputShape);a.push({type:o,data:[e.outputComponent?t/e.outputComponent:t]})}n&&(a=[...a,...n]);let s=[this.tensorToBinding(t),...r.map(e=>this.tensorToBinding(e)),this.makeUniforms(a)];r.forEach(e=>{this.commandQueueOwnedIds.add(e.dataId)}),this.commandQueueOwnedIds.add(t.dataId);let u=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:s.map((e,t)=>({binding:t,resource:e}))}),d=null!=this.activeTimers;this.ensureCommandEncoderReady();let h={};d&&this.supportTimestampQuery?(this.endComputePassEncoder(),null==this.querySet&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),h.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},this.computePassEncoder=this.commandEncoder.beginComputePass(h)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(h)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,u),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(d||(0,f.OBj)().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===l.DRAW)&&(this.endComputePassEncoder(),d?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;null==this.queryResolveBuffer&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(8*this.querySetCount,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);let e=this.bufferManager.acquireBuffer(8*this.querySetCount,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,8*this.querySetCount),this.submitQueue(),await e.mapAsync(GPUMapMode.READ);let t=new BigUint64Array(e.getMappedRange()),r=Number(t[1]-t[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),r}shouldExecuteOnCPU(e,t=x){return(0,f.OBj)().getBool("WEBGPU_CPU_FORWARD")&&e.every(e=>null==this.tensorMap.get(e.dataId).resource&&f.D5U.sizeFromShape(e.shape)<t)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(null!=this.querySet&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}};WebGPUBackend.nextDataId=0,isWebGPUSupported()&&(0,f.jqO)("webgpu",async()=>{let e={powerPreference:(0,f.OBj)().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},t=await navigator.gpu.requestAdapter(e),r={},n=[];t.features.has("timestamp-query")&&n.push("timestamp-query"),t.features.has("bgra8unorm-storage")&&n.push(["bgra8unorm-storage"]),r.requiredFeatures=n;let a=t.limits;r.requiredLimits={maxComputeWorkgroupStorageSize:a.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:a.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:a.maxStorageBufferBindingSize,maxBufferSize:a.maxBufferSize,maxComputeWorkgroupSizeX:a.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:a.maxComputeInvocationsPerWorkgroup};let i=await t.requestDevice(r),o=await t.requestAdapterInfo();return new WebGPUBackend(i,o)},3),(o=h||(h={}))[o.ADD=0]="ADD",o[o.ATAN2=1]="ATAN2",o[o.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",o[o.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",o[o.DIV=4]="DIV",o[o.ELU_DER=5]="ELU_DER",o[o.EQUAL=6]="EQUAL",o[o.FLOOR_DIV=7]="FLOOR_DIV",o[o.GREATER=8]="GREATER",o[o.GREATER_EQUAL=9]="GREATER_EQUAL",o[o.LESS=10]="LESS",o[o.LESS_EQUAL=11]="LESS_EQUAL",o[o.LOGICAL_AND=12]="LOGICAL_AND",o[o.LOGICAL_OR=13]="LOGICAL_OR",o[o.MAX=14]="MAX",o[o.MIN=15]="MIN",o[o.MOD=16]="MOD",o[o.MUL=17]="MUL",o[o.NOT_EQUAL=18]="NOT_EQUAL",o[o.POW=19]="POW",o[o.PRELU=20]="PRELU",o[o.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",o[o.SUB=22]="SUB";let b=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`,v=`
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`,w=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`,C=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`,S=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`,I=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`,k=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,R=`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`,$=`
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`,T=`
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`,D=`
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`,A=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`,P=`
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`,_=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`,N=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`;function getBinaryOpString(e,t){let r;do{let n,a,i;switch(e){case h.ATAN2:r="let resultTemp = atan2(a, b);";break;case h.MAX:r="let resultTemp = max(a, b);";break;case h.MIN:r="let resultTemp = min(a, b);";break;case h.MOD:r=t?T:$;break;case h.NOT_EQUAL:r=t?A:D;break;case h.POW:r=t?_:P;break;default:continue}return t?(n="isnanVec4",a="vec4<f32>",i="vec4<bool>"):(n="isnan",a="f32",i="bool"),`
      let aIsNaN = ${n}(a);
      let aPostLegalization = select(a, ${a}(42), aIsNaN);
      let bIsNaN = ${n}(b);
      let bPostLegalization = select(b, ${a}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${r}
        return select(
            resultTemp, ${a}(valueForNaN),
            ${i}(isNaN) | aIsNaN | bIsNaN);
      }
    `}while(!1);switch(e){case h.ADD:r="let resultTemp = a + b;";break;case h.COMPLEX_MULTIPLY_IMAG:r="let resultTemp = areal * bimag + aimag * breal;";break;case h.COMPLEX_MULTIPLY_REAL:r="let resultTemp = areal * breal - aimag * bimag;";break;case h.DIV:r="let resultTemp = a / b;";break;case h.ELU_DER:r="let resultTemp = select(a * (b + 1.0), a, b >= b - b);";break;case h.EQUAL:r=b;break;case h.FLOOR_DIV:r=v;break;case h.GREATER:r=w;break;case h.GREATER_EQUAL:r=C;break;case h.LESS:r=S;break;case h.LESS_EQUAL:r=I;break;case h.LOGICAL_AND:return t?k:"return f32(a >= 1.0 && b >= 1.0);";case h.LOGICAL_OR:return t?R:"return f32(a >= 1.0 || b >= 1.0);";case h.MUL:r="let resultTemp = a * b;";break;case h.PRELU:return t?N:"if (a < 0.0) { return b * a; }  return a;";case h.SQUARED_DIFFERENCE:r="let resultTemp = (a - b) * (a - b);";break;case h.SUB:r="let resultTemp = a - b;"}return`
    ${r}
    return resultTemp;
  `}(s=c||(c={}))[s.ABS=0]="ABS",s[s.ACOS=1]="ACOS",s[s.ACOSH=2]="ACOSH",s[s.ASIN=3]="ASIN",s[s.ASINH=4]="ASINH",s[s.ATAN=5]="ATAN",s[s.ATANH=6]="ATANH",s[s.CEIL=7]="CEIL",s[s.COS=8]="COS",s[s.COSH=9]="COSH",s[s.ELU=10]="ELU",s[s.ERF=11]="ERF",s[s.EXP=12]="EXP",s[s.EXPM1=13]="EXPM1",s[s.FLOOR=14]="FLOOR",s[s.IS_FINITE=15]="IS_FINITE",s[s.IS_INF=16]="IS_INF",s[s.IS_NAN=17]="IS_NAN",s[s.LINEAR=18]="LINEAR",s[s.LOG=19]="LOG",s[s.LOG1P=20]="LOG1P",s[s.LOGICAL_NOT=21]="LOGICAL_NOT",s[s.NEG=22]="NEG",s[s.RELU=23]="RELU",s[s.RELU6=24]="RELU6",s[s.LEAKYRELU=25]="LEAKYRELU",s[s.RECIPROCAL=26]="RECIPROCAL",s[s.ROUND=27]="ROUND",s[s.RSQRT=28]="RSQRT",s[s.SELU=29]="SELU",s[s.SIGMOID=30]="SIGMOID",s[s.SIGN=31]="SIGN",s[s.SIN=32]="SIN",s[s.SINH=33]="SINH",s[s.SOFTPLUS=34]="SOFTPLUS",s[s.SQRT=35]="SQRT",s[s.SQUARE=36]="SQUARE",s[s.STEP=37]="STEP",s[s.TAN=38]="TAN",s[s.TANH=39]="TANH",s[s.TO_INT=40]="TO_INT";let F=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,O=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,B=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,L=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,M=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,U=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,z=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,W=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${f.backend_util.ERF_P};
  let a1 = ${f.backend_util.ERF_A1};
  let a2 = ${f.backend_util.ERF_A2};
  let a3 = ${f.backend_util.ERF_A3};
  let a4 = ${f.backend_util.ERF_A4};
  let a5 = ${f.backend_util.ERF_A5};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,V=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,G=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,H=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,K=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,j=`
  if (a >= 0.0) {
    return ${f.backend_util.SELU_SCALE} * a;
  } else {
    return ${f.backend_util.SELU_SCALEALPHA} * (exp(a) - 1.0);
  }
`,X=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,q=`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`,Y=`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`,Q=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`;function getUnaryOpString(e,t){switch(e){case c.ABS:return"return abs(a);";case c.ACOS:return F;case c.ACOSH:return O;case c.ASIN:return B;case c.ASINH:return"return asinh(a);";case c.ATAN:return L;case c.ATANH:return M;case c.COS:return"return cos(a);";case c.COSH:return U;case c.CEIL:return"return ceil(a);";case c.ELU:return t?z:"if (a >= 0.0) { return a; }  return (exp(a) - 1.0);";case c.ERF:return W;case c.EXP:return"return exp(a);";case c.EXPM1:return"return exp(a) - 1.0;";case c.FLOOR:return"return floor(a);";case c.IS_FINITE:return"return f32(!isnan(a) && !isinf(a));";case c.IS_INF:return"return f32(isinf(a));";case c.IS_NAN:return"return f32(isnan(a));";case c.LINEAR:return"return a;";case c.LOG:return V;case c.LOG1P:return G;case c.LOGICAL_NOT:return"return f32(!(a >= 1.0));";case c.NEG:return"return -a;";case c.LEAKYRELU:return t?H:"if (a < 0.0) { return uniforms.alpha * a; } return a;";case c.RECIPROCAL:return"return 1.0 / a;";case c.RELU:return t?K:"return select(a, 0.0, a < 0.0);";case c.RELU6:return t?"return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));":"return clamp(a, 0.0, 6.0);";case c.ROUND:return"return round(a);";case c.RSQRT:return"return inverseSqrt(a);";case c.SELU:return j;case c.SIGMOID:return"return 1.0 / (1.0 + exp(-1.0 * a));";case c.SIGN:return"return sign(a);";case c.SIN:return"return sin(a);";case c.SINH:return X;case c.SOFTPLUS:return q;case c.SQRT:return"return sqrt(a);";case c.SQUARE:return"return a * a;";case c.STEP:return Y;case c.TAN:return"return tan(a);";case c.TANH:return Q;case c.TO_INT:return"return f32(i32((a)));";default:throw Error(`BinaryType ${e} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function activationFnSnippet(e,t=!1,r=!1,n=3){if(null===e)return"";let a="";if("linear"===e)a=getUnaryOpString(c.LINEAR);else if("relu"===e)a=getUnaryOpString(c.RELU,r);else if("elu"===e)a=getUnaryOpString(c.ELU,r);else if("relu6"===e)a=getUnaryOpString(c.RELU6,r);else if("prelu"===e)a=getBinaryOpString(h.PRELU,r);else if("sigmoid"===e)a=getUnaryOpString(c.SIGMOID,r);else if("leakyrelu"===e)a=getUnaryOpString(c.LEAKYRELU,r);else throw Error(`Activation ${e} has not been implemented for the WebGPU backend.`);let i=r?4:1,o=typeSnippet(i);return t?`
      fn activation(a : ${o}, coords : vec${n}<i32>) -> ${o} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${a}
      }`:`
      fn activation(a : ${o}, coords : vec${n}<i32>) -> ${o} {
        ${a}
      }`}function biasActivationSnippet(e,t){return`
      ${e?"value = value + getBiasByOutputCoords(coords);":""}
      ${t?"value = activation(value, coords);":""}
      `}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function matMulReadFnSource(e,t,r=!1,n=!1,a=!1,i=1){f.D5U.assert(e&&1===i||!e,()=>`transposeA ${e} is not compatible with component size ${i}`);let o=`
      ${e?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `;return`
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${typeSnippet(i)} {
    var value = ${typeSnippet(i)}(0.0);
    ${r&&a?o:`
    ${e?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${o}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${typeSnippet(i)} {
    var value = ${typeSnippet(i)}(0.0);
    ${t?"value = getB(batch, col, row);":"value = getB(batch, row, col);"}
    return value;
  }
  `}function matMulReadWriteFnSource(e,t,r,n,a=!1,i=!1,o=!1,s=1){return`
  ${matMulReadFnSource(r,n,a,i,o,s)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${typeSnippet(s)}) {
    ${a&&i?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${biasActivationSnippet(e,t)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}let writeDataToSubAVec4Snippet=(e,t)=>e?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${t});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${t});
        `,calculateResultSnippet=(e,t,r,n)=>{if(e)return`
      for (var k = 0; k < ${n}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${r}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;{let e="",a="";for(let r=0;r<t;r++)e+=`let BCached${r} = mm_Bsub[k * ${t} + ${r}][tileCol];`,a+=`acc[i] = fma(BCached${r}, vec4<f32>(ACached[${r}]), acc[i]);`;return`
      for (var k = 0; k < ${n/t}; k++) {
        ${e}
        for (var i = 0; i < ${r}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${a}
        }
      }`}};function makeMatMulPackedVec4Source(e,t,r=!1,n=32,a=!1,i=32,o=!1){let s=t[1]*e[1],u=t[0]*e[0],l=r?s:n,d=r?n:s,h=l/t[0],c=n/t[1],p=e[1],m=e[0];return f.D5U.assert((r&&4===h&&4===e[1]||!r&&(3===h||4===h))&&l%t[0]==0&&n%t[1]==0&&4===e[0],()=>`If transposeA ${r} is true, innerElementSize ${h} and workPerThread[1] ${e[1]} must be 4.
          Otherwise, innerElementSize ${h} must be 3 or 4.
      tileAWidth ${l} must be divisible by workgroupSize[0]${t[0]}. tileInner ${n} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${h}<f32>, ${l/h}>, ${d}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${u/e[0]}>, ${n}>;

  ${getMainHeaderString()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${p};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${p};
    let globalCol = i32(globalId.x) * ${m};
    let batch = ${a?"0":"i32(globalId.z)"};
    let batchA = ${a||!o?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${a||!o?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${s};

    let numTiles = ${a?`${Math.ceil(i/n)}`:`(uniforms.dimInner - 1) / ${n} + 1`};
    var kStart = ${a?`i32(globalId.z) * ${i}`:"0"};

    var acc: array<vec4<f32>, ${p}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${c};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${p}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${writeDataToSubAVec4Snippet(r,h)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${c}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${n};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${calculateResultSnippet(r,h,p,n)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${p}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}let writeDataToSubASnippet=e=>e?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,readDataFromSubASnippet=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function makeMatMulPackedSource(e,t,r=!1,n=32,a=!1,i=32,o=!1,s=!1){let u=e[1]*t[1],l=e[0]*t[0],d=r?u:n,h=r?n:u;f.D5U.assert(h%t[1]==0&&d%t[0]==0&&n%t[1]==0,()=>`tileAHight ${h} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${d} must be divisible by workgroupSize[0]${t[0]}, tileInner ${n} must be divisible by workgroupSize[1]${t[1]}`);let c=h/t[1],p=d/t[0],m=n/t[1],g=e[1],y=e[0],x=o?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${u};
      let globalColStart = i32(workgroupId.x) * ${l};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${t[1]}) {
          for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${t[0]}) {
            ${writeDataToSubASnippet(r)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${t[1]}) {
              for (var inputCol = localCol; inputCol < ${l}; inputCol = inputCol + ${t[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${n};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${y}>;
        for (var k = 0; k < ${n}; k++) {
          for (var inner = 0; inner < ${y}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];
          }
          for (var innerRow = 0; innerRow < ${g}; innerRow++) {
            let ACached = ${r?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}
            for (var innerCol = 0; innerCol < ${y}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${t[1]};
        for (var innerCol = 0; innerCol < ${y}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${t[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${g};
  let tileCol = i32(localId.x) * ${y};

  let globalRow = i32(globalId.y) * ${g};
  let globalCol = i32(globalId.x) * ${y};
  let globalRowStart = i32(workgroupId.y) * ${u};

  let tileRowA = i32(localId.y) * ${c};
  let tileColA = i32(localId.x) * ${p};
  let tileRowB = i32(localId.y) * ${m};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${c}; innerRow++) {
      for (var innerCol = 0; innerCol < ${p}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${writeDataToSubASnippet(r)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${m}; innerRow++) {
      for (var innerCol = 0; innerCol < ${y}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${n};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${y}>;
    for (var k = 0; k < ${n}; k++) {
      for (var inner = 0; inner < ${y}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        ${readDataFromSubASnippet(r)}
        for (var innerCol = 0; innerCol < ${y}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${g}; innerRow++) {
    for (var innerCol = 0; innerCol < ${y}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${d}>, ${h}>;
    var<workgroup> mm_Bsub : array<array<f32, ${l}>, ${n}>;

    ${getMainHeaderString()} {
      let batch = ${a?"0":"i32(globalId.z)"};
      let batchA = ${a||!s?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${a||!s?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${a?`${Math.ceil(i/n)}`:`(uniforms.dimInner - 1) / ${n} + 1`};
      var kStart = ${a?`i32(globalId.z) * ${i}`:"0"};

      var acc : array<array<f32, ${y}>, ${g}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${g}; innerRow++) {
        for (var innerCol = 0; innerCol < ${y}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${x}
    }
  `}let readVectorASnippet=e=>e?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;let MatMulPackedProgram=class MatMulPackedProgram{constructor(e,t,r=!1,n=!1,a=null,i=null,o=null,s=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};let u=r?e[1]:e[2];if(this.isVec4=(u%4==0&&!r||t[1]%4==0&&r)&&t[2]%4==0&&!n,this.outputComponent=this.isVec4?4:1,this.isVectorA=1===t[1]&&!r,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{let e=function(e,t,r,n=!1){let a=[8,8,1],i=[4,4,1];return!n&&(e<=8&&(i[1]=1),t<=16&&r<=16&&(a[0]=4)),{workgroupSize:a,elementsPerThread:i}}(t[1],u,t[2],r);this.workgroupSize=e.workgroupSize,this.elementsPerThread=e.elementsPerThread}this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);let l=null!=a,d=null!=o;l&&this.variableNames.push("bias"),d&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=s,this.transposeA=r,this.transposeB=n,this.addBias=l,this.activation=i,this.hasPreluActivationWeights=d,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],u),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${r}_${n}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,r){let n=this.workgroupSize[1]*this.elementsPerThread[1],a=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=4*this.workgroupSize[0]:this.tileInner=a;let i=r%this.tileInner==0;return[e%n==0,t%a==0,i]}getUserCode(){let e=`
      ${activationFnSnippet(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${matMulReadWriteFnSource(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?makeMatMulPackedVec4Source(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?function(e,t=!1){f.D5U.assert(1===e[1]&&1===e[2],()=>`A linear work group size is required. But got ${e}.`);let r=4*e[0];return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${e[0]}>;

    ${getMainHeaderString()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${r} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${r} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${readVectorASnippet(t)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${r/4}; k++) {
          let rowB = t * ${r} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}(this.workgroupSize,this.transposeA):makeMatMulPackedSource(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `;return e}};let MatMulReduceProgram=class MatMulReduceProgram{constructor(e,t=!1,r=!1,n=null,a=null,i=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize);let o=null!=n,s=null!=i;o&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=r,this.addBias=o,this.activation=a,this.hasPreluActivationWeights=s,this.shaderKey=`matMulReduce_${this.activation}_${t}_${r}`}getUserCode(){var e;let t=`
      ${activationFnSnippet(this.activation,this.hasPreluActivationWeights)}
      ${matMulReadWriteFnSource(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${(e=this.workgroupSize[0],`
    var<workgroup> sumValues : array<f32, ${e}>;
    ${getMainHeaderString()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${e}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${e/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `)}
    `;return t}};let MatMulSmallOutputSizeProgram=class MatMulSmallOutputSizeProgram{constructor(e,t,r,n=!1,a=!1,i=null,o=null,s=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=r,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(r[2]/this.workgroupSize[0]),Math.ceil(r[1]/this.workgroupSize[1]),r[0]];let u=null!=i;u&&this.variableNames.push("bias");let l=null!=s;l&&this.variableNames.push("preluActivationWeights"),this.transposeA=n,this.transposeB=a,this.addBias=u,this.activation=o,this.hasPreluActivationWeights=l,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${n}_${a}`}getUserCode(){let e=`
      ${activationFnSnippet(this.activation,this.hasPreluActivationWeights)}
      ${matMulReadWriteFnSource(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t=e[1],r=e[0],n=t>r?t:r;return`
  var<workgroup> mm_Asub : array<array<f32, ${n}>, ${t}>;
  var<workgroup> mm_Bsub : array<array<f32, ${r}>, ${n}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${getMainHeaderString()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${n} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${n};
    globalRowB = globalRowB + ${n};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${n};
      globalRowB = globalRowB + ${n};

      for (var k = 0; k < ${n}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}(this.workgroupSize)}
    `;return e}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let MatMulSplitKProgram=class MatMulSplitKProgram{constructor(e,t,r=!1,n=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,f.D5U.assert(1===e[0],()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};let a=(r&&this.outputShape[1]%4==0||!r&&t%4==0)&&this.outputShape[2]%4==0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=a?4:1,!a&&(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=computeDispatch(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=r,this.transposeB=n,this.shaderKey=`matMulSplitK_${r}_${n}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){let e=this.outputComponent,t=`
      ${matMulReadFnSource(!1,this.transposeB,!1,!1,!1,e)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${typeSnippet(e)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e}; i = i + 1) {
            ${atomicAddSnippet("&result[flatIndex + i]",`${e>1?"value[i]":"value"}`,"float32")}
          }
        }
      }
      ${4===e?makeMatMulPackedVec4Source(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):makeMatMulPackedSource(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `;return t}};let BiasActivationProgram=class BiasActivationProgram{constructor(e,t=null,r=null,n=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=null!=t,this.hasPreluActivationWeights=null!=n,this.activation=r,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${r}`}getUserCode(){return`
    ${activationFnSnippet(this.activation,this.hasPreluActivationWeights)}
    ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${biasActivationSnippet(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let FillProgram=class FillProgram{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){let e=`
    ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `;return e}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fill(e){let{backend:t,attrs:r}=e,{shape:n,value:a}=r,{dtype:i}=r;if("string"===(i=i||f.D5U.inferDtype(a))){let e=f.D5U.getArrayFromDType(i,f.D5U.sizeFromShape(n));return e.fill(a),t.makeTensorInfo(n,i,e)}{let e=new FillProgram(n),r=[{type:"float32",data:[a]}];return t.runWebGPUProgram(e,[],i,r)}}let Z={kernelName:f.deh,backendName:"webgpu",kernelFunc:fill};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function reshape(e){let{inputs:t,attrs:r}=e,{x:n}=t,{shape:a}=r,i=f.D5U.sizeFromShape(n.shape),o=f.D5U.inferFromImplicitShape(a,i),s=f.D5U.sizeFromShape(o);return f.D5U.assert(i===s,()=>`The new shape (${o}) has ${s} elements and the old shape (${n.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),e.backend.incRef(n.dataId),{dataId:n.dataId,shape:o,dtype:n.dtype}}let J={kernelName:f.HZH,backendName:"webgpu",kernelFunc:reshape};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function batchMatMulImpl({a:e,b:t,transposeA:r,transposeB:n,backend:a,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:s=0,activation:u=null}){let l,h;let c=e.shape.length,p=t.shape.length,m=r?e.shape[c-2]:e.shape[c-1],g=n?t.shape[p-1]:t.shape[p-2],y=r?e.shape[c-1]:e.shape[c-2],x=n?t.shape[p-2]:t.shape[p-1],b=e.shape.slice(0,-2),v=t.shape.slice(0,-2),w=f.D5U.sizeFromShape(b),C=f.D5U.sizeFromShape(v),S=f.Jyw.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)),I=S.concat([y,x]);f.D5U.assert(m===g,()=>`Error in matMul: inner shapes (${m}) and (${g}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${r} and transposeB=${n} must match.`);let k=r?[w,m,y]:[w,y,m],R=n?[C,x,g]:[C,g,x],$=reshape({inputs:{x:e},backend:a,attrs:{shape:k}}),T=reshape({inputs:{x:t},backend:a,attrs:{shape:R}}),D=[$,T],A=Math.max(w,C),P=[$,T],_=[{type:"int32",data:[y]},{type:"int32",data:[x]},{type:"int32",data:[m]}],N=[A,y,x],F=(0,f.OBj)().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(F<0){let e=(0,f.OBj)().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),t=e>0?e:a.thresholdToIncreaseWorkgroups,r=A*Math.ceil(y/32)*Math.ceil(x/32),n=r<=t||y<=8&&r<=2*t;F=n?A*y*x<=128?d.MatMulReduceProgram:1===A&&g>=2e3?d.MatMulSplitKProgram:d.MatMulSmallOutputSizeProgram:d.MatMulPackedProgram}switch(F){case d.MatMulReduceProgram:l=new MatMulReduceProgram(N,r,n,i,u,o);break;case d.MatMulSplitKProgram:if(h=fill({backend:a,attrs:{shape:N,value:0,dtype:e.dtype}}),l=new MatMulSplitKProgram(N,g,r,n),i||u){h=a.runWebGPUProgram(l,P,e.dtype,_,h);let t=new BiasActivationProgram(h.shape,i,u,o),r=null,n=[h];i&&n.push(i),o&&n.push(o),"leakyrelu"===u&&(r=[{type:"float32",data:[s]}],t.uniforms+=" alpha : f32,");let d=a.runWebGPUProgram(t,n,h.dtype,r);D.push(h);let c=reshape({inputs:{x:d},backend:a,attrs:{shape:I}});for(let e of(D.push(d),D))a.disposeData(e.dataId);return c}break;case d.MatMulSmallOutputSizeProgram:l=new MatMulSmallOutputSizeProgram(k,R,N,r,n,i,u,o);break;case d.MatMulPackedProgram:let O=a.adapterInfo.isIntel();l=new MatMulPackedProgram(k,N,r,n,i,u,o,O);break;default:throw Error(`Unsupported MatMulProgramType ${F}.`)}i&&P.push(i),o&&P.push(o),"leakyrelu"===u&&(_.push({type:"float32",data:[s]}),l.uniforms+=" alpha : f32,"),h=a.runWebGPUProgram(l,P,e.dtype,_,h);let B=reshape({inputs:{x:h},backend:a,attrs:{shape:I}});for(let e of(D.push(h),D))a.disposeData(e.dataId);return B}let ee={kernelName:f.usg,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{a,b:i,bias:o,preluActivationWeights:s}=t,{transposeA:u,transposeB:l,activation:d,leakyreluAlpha:h}=n;return batchMatMulImpl({a,b:i,transposeA:u,transposeB:l,backend:r,bias:o,preluActivationWeights:s,leakyreluAlpha:h,activation:d})}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let BinaryOpComplexProgram=class BinaryOpComplexProgram{constructor(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=f.backend_util.assertAndGetBroadcastShape(t,r),this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){let e=getBinaryOpString(this.op,!1),t=`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${e}
      }

      ${getMainHeaderString("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `;return t}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let BinaryOpProgram=class BinaryOpProgram{constructor(e,t,r){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=f.backend_util.assertAndGetBroadcastShape(t,r),this.dispatchLayout=flatDispatchLayout(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&r.length>1&&t[0]<128,this.useSharedMemoryWithB=r.length<=1&&t.length>1&&r[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?r[0]:t[0],this.shaderKey=`binary_${e}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{let n=t.length>0&&t[t.length-1]%4==0,a=r.length>0&&r[r.length-1]%4==0;n&&a?(this.outputComponent=4,this.variableComponents=[4,4]):n&&(f.D5U.isScalarShape(r)||1===r[r.length-1])||a&&(f.D5U.isScalarShape(t)||1===t[t.length-1])?(this.outputComponent=4,this.variableComponents=n?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${e}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;let t=4===this.outputComponent?"vec4<f32>":"f32",r=`
    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {
      ${getBinaryOpString(this.op,4===this.outputComponent)}
    };
    `;if("shared"===this.type){let t=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",n=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${t}];`:`let a = sharedBuf[${t}];
          let b = getBByOutputIndex(index);`;e=`
        ${r}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${getMainHeaderString("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${n}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else e=`
       ${r}
       ${getMainHeaderString("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${t}(getAByOutputCoords(coords));
           let b = ${t}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return e}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function identity(e){let{inputs:t}=e,{x:r}=t;return e.backend.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}let et={kernelName:f.iJz,backendName:"webgpu",kernelFunc:identity};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function complex(e){let{inputs:t,backend:r}=e,{real:n,imag:a}=t,i=r.makeTensorInfo(n.shape,"complex64"),o=r.tensorMap.get(i.dataId),s=identity({inputs:{x:n},backend:r}),u=identity({inputs:{x:a},backend:r});return o.complexTensorInfos={real:s,imag:u},i}let er={kernelName:f.Zz9,backendName:"webgpu",kernelFunc:complex};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let UnaryOpProgram=class UnaryOpProgram{constructor(e,t,r=""){this.variableNames=["A"],this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,""!==r&&(this.uniforms=r),this.shaderKey=`unary_${t}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${getUnaryOpString(this.op,!1)}
      }
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function unaryKernelFunc({opType:e,cpuKernelImpl:t,dtype:r}){return({inputs:n,backend:a})=>{let{x:i}=n,o=r||i.dtype;if(a.shouldExecuteOnCPU([i])&&null!=t){let e=a.tensorMap.get(i.dataId),r=t(e.values,o);return a.makeTensorInfo(i.shape,o,r)}let s=new UnaryOpProgram(i.shape,e);return a.runWebGPUProgram(s,[i],o)}}function binaryKernelFunc({opType:e,cpuKernelImpl:t,supportsComplex:r=!1,dtype:n}){return({inputs:a,backend:i})=>{let{a:o,b:s}=a;if(r&&"complex64"===o.dtype){let t,r;let n=i.tensorMap.get(o.dataId),a=i.tensorMap.get(s.dataId);if(e!==h.MUL)[t,r]=[[n.complexTensorInfos.real,a.complexTensorInfos.real],[n.complexTensorInfos.imag,a.complexTensorInfos.imag]].map(t=>{let[r,n]=t,a={dataId:r.dataId,dtype:r.dtype,shape:o.shape},u={dataId:n.dataId,dtype:n.dtype,shape:s.shape},l=new BinaryOpProgram(e,o.shape,s.shape);return i.runWebGPUProgram(l,[a,u],(0,f.x8V)(r.dtype,n.dtype))});else{let e=new BinaryOpComplexProgram(h.COMPLEX_MULTIPLY_REAL,o.shape,s.shape),u=new BinaryOpComplexProgram(h.COMPLEX_MULTIPLY_IMAG,o.shape,s.shape),l=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:o.shape},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:s.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:s.shape}];t=i.runWebGPUProgram(e,l,"float32"),r=i.runWebGPUProgram(u,l,"float32")}let u=complex({inputs:{real:t,imag:r},backend:i});return i.disposeData(t.dataId),i.disposeData(r.dataId),u}let u=n||(0,f.x8V)(o.dtype,s.dtype);if(("string"===o.dtype||"string"===s.dtype||i.shouldExecuteOnCPU([o,s]))&&null!=t){let e=i.tensorMap.get(o.dataId).values,r=i.tensorMap.get(s.dataId).values,n="string"===o.dtype?f.backend_util.fromUint8ToStringArray(e):e,a="string"===o.dtype?f.backend_util.fromUint8ToStringArray(r):r,[l,d]=t(o.shape,s.shape,n,a,u);return i.makeTensorInfo(d,u,l)}let l=new BinaryOpProgram(e,o.shape,s.shape);return i.runWebGPUProgram(l,[o,s],u)}}var en=r(40300);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let{addImpl:ea,castImpl:ei,ceilImpl:eo,concatImpl:es,equalImpl:eu,expImpl:el,expm1Impl:ed,floorImpl:eh,floorDivImpl:ec,gatherNdImpl:ep,gatherV2Impl:ef,greaterEqualImpl:em,greaterImpl:eg,lessEqualImpl:ey,lessImpl:ex,logImpl:eb,maxImpl:ev,maximumImpl:ew,minimumImpl:eC,multiplyImpl:eS,negImpl:eI,notEqualImpl:ek,prodImpl:eR,rangeImpl:e$,rsqrtImpl:eT,scatterImpl:eD,simpleAbsImpl:eE,sliceImpl:eA,stridedSliceImpl:eP,stringNGramsImpl:e_,subImpl:eN,tileImpl:eF,topKImpl:eO,transposeImpl:eB,uniqueImpl:eL}=en,eM=unaryKernelFunc({opType:c.ABS,cpuKernelImpl:eE}),eU={kernelName:f.SYM,backendName:"webgpu",kernelFunc:eM},ez=unaryKernelFunc({opType:c.ACOS}),eW={kernelName:f.VGw,backendName:"webgpu",kernelFunc:ez},eV=unaryKernelFunc({opType:c.ACOSH}),eG={kernelName:f.SpW,backendName:"webgpu",kernelFunc:eV},eH=binaryKernelFunc({opType:h.ADD,cpuKernelImpl:ea,supportsComplex:!0}),eK={kernelName:f.mm_,backendName:"webgpu",kernelFunc:eH};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let AddNPackedProgram=class AddNPackedProgram{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((e,t)=>`T${t}`),this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){let e=[];this.variableNames.forEach(t=>{e.push(`let v${t} = get${t}ByOutputCoords(coords);`)});let t=this.variableNames.map(e=>`v${e}`).join(" + "),r=`
      ${getMainHeaderString("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join("\n        ")}
            setOutputAtIndex(flatIndex, ${t});
          }
        }
      }
    `;return r}};let ej={kernelName:f.Xze,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r}=e;if(1===t.length)return identity({inputs:{x:t[0]},backend:r});let n=t.map(e=>e.dtype).reduce((e,t)=>(0,f.x8V)(e,t)),a=t.map(e=>e.shape),i=new AddNPackedProgram(a);return r.runWebGPUProgram(i,t,n)}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TransposeSharedProgram=class TransposeSharedProgram{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];let r=Array(e.length);for(let n=0;n<r.length;n++)r[n]=e[t[n]];this.outputShape=r,this.dispatchLayout={x:[0],y:[1]},this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){f.D5U.assert(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);let e=this.workgroupSize[0],t=`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${getMainHeaderString()} {
        var x = i32(workgroupId.x) * ${e} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e} + i32(localId.x);
        y = i32(workgroupId.x) * ${e} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `;return t}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TransposeProgram=class TransposeProgram{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;let r=Array(e.length);for(let n=0;n<r.length;n++)r[n]=e[t[n]];this.outputShape=r,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){let e=getCoordsDataType(this.outputShape.length),t=getSwitchedCoords(this.newDim),r=`
      ${getMainHeaderString("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${t}), uniforms.aShape)]);
          }
        }
      }
    `;return r}};function getSwitchedCoords(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let r=Array(t);for(let t=0;t<e.length;t++)r[e[t]]=`coords.${getCoordsXYZ(t)}`;return r.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function transpose(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{perm:i}=n,o=a.shape.length,s=Array(o);for(let e=0;e<s.length;e++)s[e]=a.shape[i[e]];if(r.shouldExecuteOnCPU([a])){let e=r.tensorMap.get(a.dataId),t=e.values,n=eB(t,a.shape,a.dtype,i,s);return r.makeTensorInfo(s,a.dtype,n)}if(2===a.shape.length&&f.D5U.arraysEqual(i,[1,0])){let e=new TransposeSharedProgram(a.shape,i);return r.runWebGPUProgram(e,[a],a.dtype)}let u=new TransposeProgram(a.shape,i);return r.runWebGPUProgram(u,[a],a.dtype)}let eX={kernelName:f.G3Y,backendName:"webgpu",kernelFunc:transpose};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ReduceProgram=class ReduceProgram{constructor(e,t,r){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];let[n]=f.backend_util.computeOutAndReduceShapes(this.inputShape,[1]);this.outputShape=0===n.length?[1]:n,e.inSize>=32768&&r>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey=`reduce_${t}`}getUserCode(){let e="",t="0.0",r=this.workgroupSize[0];"min"===this.reduceType||"max"===this.reduceType?(e=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${"min"===this.reduceType?"<":">"} bestValue)
           {  bestValue = candidate; }`,t="f32(x[offset])"):"sum"===this.reduceType||"mean"===this.reduceType?e=" bestValue = bestValue + candidate; ":"prod"===this.reduceType?(e=" bestValue = bestValue * candidate; ",t="1.0"):"all"===this.reduceType?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):"any"===this.reduceType&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");let n="mean"===this.reduceType?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);",a=`
         var<workgroup> xBestValues : array<f32, ${r}>;
       `,i=`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${a}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${1===this.outputShape.length?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${getMainHeaderString("index")} {
         let outputIndex = index / ${r};
         let offset = getOffset(outputIndex);
         var bestValue = ${t};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${r}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${r}) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${r}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${n}
        }
       }
     `;return i}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let eq={mean:"float32",all:"bool",any:"bool"};function reduce(e,t,r,n,a){let i;let o=e.shape.length,s=[],u=f.D5U.parseAxisParam(t,e.shape),l=u,d=f.backend_util.getAxesPermutation(l,o),h=e;null!=d&&(h=transpose({inputs:{x:e},attrs:{perm:d},backend:a}),l=f.backend_util.getInnerMostAxes(l.length,o),s.push(h)),f.backend_util.assertAxesAreInnerMostDims(n,l,o);let[c,p]=f.backend_util.computeOutAndReduceShapes(h.shape,l),m=c;if(r&&(m=f.backend_util.expandShapeToKeepDim(c,u)),("max"===n||"prod"===n)&&a.shouldExecuteOnCPU([h])){let t=a.tensorMap.get(h.dataId).values;switch(n){case"max":let r=ev(t,f.D5U.sizeFromShape(p),m,e.dtype);i=a.makeTensorInfo(m,e.dtype,r);break;case"prod":let{outVals:o,outShape:s,outDtype:u}=eR(h.shape,h.dtype,t,l);i=a.makeTensorInfo(s,u,o);break;default:throw Error(`${n} CPU implementation is not yet supported.`)}}else{let t=f.D5U.sizeFromShape(p),r=f.D5U.sizeFromShape(h.shape),o=r/t,u=eq[n]||(0,f.z4k)(e.dtype),l=[{type:"int32",data:[t]}],d=new ReduceProgram({windowSize:t,inSize:t,batchSize:o,outSize:1},n,a.device.limits.maxComputeWorkgroupSizeX),c=a.runWebGPUProgram(d,[h],u,l);s.push(c),i=reshape({inputs:{x:c},attrs:{shape:m},backend:a})}return s.forEach(e=>a.disposeData(e.dataId)),i}let eY={kernelName:f.oT6,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{keepDims:i,axis:o}=n;return reduce(a,o,i,"all",r)}},eQ={kernelName:f.IKK,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{keepDims:i,axis:o}=n;return reduce(a,o,i,"any",r)}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ArgMinMaxProgram=class ArgMinMaxProgram{constructor(e,t,r){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;let n=[t];this.op="min"===r?"<":">";let[a,i]=f.backend_util.computeOutAndReduceShapes(e,n);this.outputShape=0===a.length?[1]:a,this.dispatchLayout=flatDispatchLayout(this.outputShape),32>f.D5U.sizeFromShape(i)?(this.type="plain",this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){let e=this.workgroupSize[0],getInputShapeLastDim=()=>1===this.inputShape.length?"uniforms.xShape":`uniforms.xShape.${getCoordsXYZ(this.inputShape.length-1)}`,splitOutputCoords=()=>{let e="";if(1===this.outputShape.length)1!==this.inputShape.length&&(e+="outputCoords,");else for(let t=0;t<this.outputShape.length;t++)e+=`outputCoords.${getCoordsXYZ(t)},`;return e};if("shared"===this.type){let t=`
      var<workgroup> xBestIndices : array<i32, ${e}>;
      var<workgroup> xBestValues : array<f32, ${e}>;
    `,r=`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${t}

      ${getMainHeaderString("index")} {
        let outputIndex = index / ${e};
        let reduceLength = ${getInputShapeLastDim()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e}) {
          let candidate = getX(${splitOutputCoords()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `;return r}{let e=`
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${splitOutputCoords()} 0);
          let reduceLength = ${getInputShapeLastDim()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${splitOutputCoords()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `;return e}}};let eZ={kernelName:f.sJF,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:i}=n,o=f.D5U.parseAxisParam(i,a.shape),s=f.backend_util.getAxesPermutation(o,a.shape.length),u=a,l=[];null!=s&&(l.push(u=transpose({inputs:{x:a},backend:r,attrs:{perm:s}})),o=f.backend_util.getInnerMostAxes(o.length,u.shape.length)),f.backend_util.assertAxesAreInnerMostDims("argMax",[o[0]],u.shape.length);let d=new ArgMinMaxProgram(u.shape,o[0],"max"),h=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],c=r.runWebGPUProgram(d,[u],"int32",h);return l.forEach(e=>r.disposeData(e.dataId)),c}},eJ={kernelName:f.aJk,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:i}=n,o=f.D5U.parseAxisParam(i,a.shape),s=f.backend_util.getAxesPermutation(o,a.shape.length),u=a,l=[];null!=s&&(l.push(u=transpose({inputs:{x:a},backend:r,attrs:{perm:s}})),o=f.backend_util.getInnerMostAxes(o.length,u.shape.length)),f.backend_util.assertAxesAreInnerMostDims("argMin",[o[0]],u.shape.length);let d=new ArgMinMaxProgram(u.shape,o[0],"min"),h=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],c=r.runWebGPUProgram(d,[u],"int32",h);return l.forEach(e=>r.disposeData(e.dataId)),c}},e0=unaryKernelFunc({opType:c.ASIN}),e1={kernelName:f.M2y,backendName:"webgpu",kernelFunc:e0},e2=unaryKernelFunc({opType:c.ASINH}),e3={kernelName:f.qw7,backendName:"webgpu",kernelFunc:e2},e4=unaryKernelFunc({opType:c.ATAN}),e5={kernelName:f.jMg,backendName:"webgpu",kernelFunc:e4},e6=binaryKernelFunc({opType:h.ATAN2}),e8={kernelName:f.QCc,backendName:"webgpu",kernelFunc:e6},e7=unaryKernelFunc({opType:c.ATANH}),e9={kernelName:f.Oyi,backendName:"webgpu",kernelFunc:e7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let PoolWithFilterSizeEqualsOneProgram=class PoolWithFilterSizeEqualsOneProgram{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){let e=`
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `;return e}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Pool2DProgram=class Pool2DProgram{constructor(e,t,r=!1,n=!1,a=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,"avg"===t&&r)throw Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=r,this.flattenPositions=n,this.includeBatchIndex=a,this.shaderKey=`pool2D_${t}_${r}_${n}_${a}`}getUserCode(){let e;if("avg"===this.poolType)e="resultValue = resultValue + value; count = count + 1.0;";else if(this.computePositions){let t=this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC";e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${t};
      }`}else e="resultValue = max(value, resultValue);";let t="resultValue";"avg"===this.poolType&&(t="resultValue / max(count, 1.0)");let r=`
      ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${"avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${e}
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `;return r}};let Pool3DProgram=class Pool3DProgram{constructor(e,t,r=!1,n=!1,a=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,"avg"===t&&r)throw Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=r,this.flattenPositions=n,this.includeBatchIndex=a,this.shaderKey=`pool3D_${t}_${r}_${n}_${a}`}getUserCode(){let e;if("avg"===this.poolType)e="resultValue += value; count += 1.0;";else if(this.computePositions){let t=this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC";e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${t};
      }`}else e="resultValue = max(value, resultValue);";let t="resultValue";"avg"===this.poolType&&(t="resultValue / max(count, 1.0)");let r=`
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${"avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${e}
              }
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `;return r}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function max(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{reductionIndices:i,keepDims:o}=n;return reduce(a,i,o,"max",r)}let te={kernelName:f.YoZ,backendName:"webgpu",kernelFunc:max};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mean(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{keepDims:i,axis:o}=n;return reduce(a,o,i,"mean",r)}let tt={kernelName:f.q2K,backendName:"webgpu",kernelFunc:mean};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function poolImpl(e,t,r,n){let a;if(1===t.filterWidth&&1===t.filterHeight&&f.D5U.arraysEqual(t.inShape,t.outShape))return identity({inputs:{x:e},backend:n});if(t.filterWidth===t.inWidth&&t.filterHeight===t.inHeight&&1===t.batchSize&&"VALID"===t.padInfo.type){let a;let i=e.shape.length,o=reshape({inputs:{x:e},backend:n,attrs:{shape:[e.shape[i-3]*e.shape[i-2],e.shape[i-1]]}});"avg"===r?a=mean({inputs:{x:o},backend:n,attrs:{axis:0,keepDims:!1}}):(f.D5U.assert("max"===r,()=>`Invalid pool type ${r}`),a=max({inputs:{x:o},backend:n,attrs:{reductionIndices:0,keepDims:!1}}));let s=reshape({inputs:{x:a},backend:n,attrs:{shape:t.outShape}});return n.disposeData(o.dataId),n.disposeData(a.dataId),s}let i=[{type:"int32",data:[t.strideHeight,t.strideWidth]}];return 1===t.filterHeight&&1===t.filterWidth?a=new PoolWithFilterSizeEqualsOneProgram(t):("avg"===r?a=new Pool2DProgram(t,"avg"):(f.D5U.assert("max"===r,()=>`Invalid pool type ${r}`),a=new Pool2DProgram(t,"max")),i.push({type:"int32",data:[t.padInfo.top,t.padInfo.left]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]},{type:"int32",data:[t.inHeight,t.inWidth]},{type:"int32",data:[t.effectiveFilterHeight,t.effectiveFilterWidth]})),n.runWebGPUProgram(a,[e],e.dtype,i)}let tr={kernelName:f.JhU,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{filterSize:i,strides:o,pad:s,dimRoundingMode:u}=n,l=f.backend_util.computePool2DInfo(a.shape,i,o,1,s,u);return poolImpl(a,l,"avg",r)}},tn={kernelName:f._k9,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{filterSize:i,strides:o,pad:s,dataFormat:u,dimRoundingMode:l}=n,d=f.backend_util.computePool3DInfo(a.shape,i,o,[1,1,1],s,l,u),h=new Pool3DProgram(d,"avg"),c=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.front,d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inDepth,d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]}];return r.runWebGPUProgram(h,[a],a.dtype,c)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let AvgPool2DBackpropProgram=class AvgPool2DBackpropProgram{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){let e=`
      ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;return e}};let AvgPool3DBackpropProgram=class AvgPool3DBackpropProgram{constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){let e=`
      ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;return e}};let ta={kernelName:f.IMb,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,input:i}=t,{filterSize:o,strides:s,pad:u,dimRoundingMode:l}=n,d=f.backend_util.computePool3DInfo(i.shape,o,s,1,u,l),h=new AvgPool3DBackpropProgram(d),c=1/(d.filterDepth*d.filterHeight*d.filterWidth),p=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterDepth-1-d.padInfo.front,d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outDepth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"float32",data:[c]}];return r.runWebGPUProgram(h,[a],i.dtype,p)}},ti={kernelName:f.ROF,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,input:i}=t;assertNotComplex([a,i],"avgPoolGrad");let{filterSize:o,strides:s,pad:u}=n,l=f.backend_util.computePool2DInfo(i.shape,o,s,1,u),d=new AvgPool2DBackpropProgram(l),h=1/(l.filterHeight*l.filterWidth),c=[{type:"int32",data:[l.strideHeight,l.strideWidth]},{type:"int32",data:[l.effectiveFilterHeight-1-l.padInfo.top,l.effectiveFilterWidth-1-l.padInfo.left]},{type:"int32",data:[l.dilationHeight,l.dilationWidth]},{type:"int32",data:[l.effectiveFilterHeight,l.effectiveFilterWidth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"float32",data:[h]}];return r.runWebGPUProgram(d,[a],i.dtype,c)}},to={kernelName:f.XLW,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{a,b:i}=t,{transposeA:o,transposeB:s}=n;return batchMatMulImpl({a,b:i,transposeA:o,transposeB:s,backend:r})}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SliceProgram=class SliceProgram{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${getCoordsDataType(e.length)}, `,this.shaderKey="slice"}getUserCode(){let e;let t=getCoordsDataType(this.rank),r=function(e){if(1===e)return"sourceLoc";if(e<=6)return ts.slice(0,e).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);e=1===this.start.length?this.outputShape.map((e,t)=>"sourceLoc = uniforms.start + coords;"):this.outputShape.map((e,t)=>`sourceLoc.${ts[t]} = uniforms.start.${getCoordsXYZ(t)} + coords.${ts[t]};`);let n=`
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${t};
          let coords = getCoordsFromIndex(index);
          ${e.join("\n")}
          setOutputAtIndex(index, getSource(${r}));
        }
      }
    `;return n}};let ts=["x","y","z","w","u","v"];/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function slice(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{begin:i,size:o}=n,[s,u]=f.kuN.parseSliceParams(a,i,o);if(f.kuN.assertParamsValid(a,s,u),r.shouldExecuteOnCPU([a])||"string"===a.dtype){let e=r.tensorMap.get(a.dataId),t=eA(e.values,s,u,a.shape,a.dtype);return r.makeTensorInfo(u,a.dtype,t)}if(0===f.D5U.sizeFromShape(u))return r.makeTensorInfo(u,a.dtype,[]);let l=new SliceProgram(s,u),d=[{type:"int32",data:s}];return r.runWebGPUProgram(l,[a],a.dtype,d)}let tu={kernelName:f.p2w,backendName:"webgpu",kernelFunc:slice},tl={kernelName:f.zws,backendName:"webgpu",kernelFunc:e=>{let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{blockShape:i,crops:o}=n;f.D5U.assert(a.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");let s=i.reduce((e,t)=>e*t),u=f.backend_util.getReshaped(a.shape,i,s),l=f.backend_util.getPermuted(u.length,i.length),d=f.backend_util.getReshapedPermuted(a.shape,i,s),h=f.backend_util.getSliceBeginCoords(o,i.length),c=f.backend_util.getSliceSize(d,o,i.length),p=[],m=reshape({inputs:{x:a},backend:r,attrs:{shape:u}}),g=transpose({inputs:{x:m},backend:r,attrs:{perm:l}}),y=reshape({inputs:{x:g},backend:r,attrs:{shape:d}}),x=slice({inputs:{x:y},backend:r,attrs:{begin:h,size:c}});return p.push(m),p.push(g),p.push(y),p.forEach(e=>r.disposeData(e.dataId)),x}},td=`
  fn bincount_write(index: i32, value: f32) {
    ${atomicAddSnippet("&result[index]","value","float32")}
  }
`,th=`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;let BincountProgram=class BincountProgram{constructor(e,t,r=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=r,r&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){let e=`
    ${this.binaryOutput?th:td}
  ${getMainHeaderString("index")} {
    ${1===this.rank?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `;return e}};let tc={kernelName:f.zvY,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,weights:i}=t,{size:o}=n,s=f.D5U.sizeFromShape(a.shape),u=f.D5U.sizeFromShape(i.shape),l=u>0,d=i.dtype,h=fill({backend:r,attrs:{shape:[o],value:0,dtype:d}}),c=new BincountProgram([s],l),p=l?[a,i]:[a],m=r.runWebGPUProgram(c,p,d,[{type:"int32",data:[o]}],h);return m}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let BroadcastArgsProgram=class BroadcastArgsProgram{constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){let e=`
  ${getMainHeaderString("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `;return e}};let tp={kernelName:f.eEB,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r}=e,{s0:n,s1:a}=t;if(r.shouldExecuteOnCPU([n,a])){let e=r.tensorMap.get(n.dataId),t=r.tensorMap.get(a.dataId),i=e.values,o=t.values,s=f.backend_util.assertAndGetBroadcastShape(Array.from(i),Array.from(o));return r.makeTensorInfo([s.length],"int32",Int32Array.from(s))}let i=f.D5U.sizeFromShape(n.shape),o=f.D5U.sizeFromShape(a.shape),s=Math.max(i,o),u=new BroadcastArgsProgram(s),l=[{type:"int32",data:[i]},{type:"int32",data:[o]}];return r.runWebGPUProgram(u,[n,a],"int32",l)}},tf=binaryKernelFunc({opType:h.NOT_EQUAL,dtype:"bool",cpuKernelImpl:ek}),tm={kernelName:f.yQU,backendName:"webgpu",kernelFunc:tf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function real(e){let{inputs:t,backend:r}=e,{input:n}=t,a=r.tensorMap.get(n.dataId);return identity({inputs:{x:a.complexTensorInfos.real},backend:r})}let tg={kernelName:f.xJR,backendName:"webgpu",kernelFunc:real},ty={kernelName:f.RFZ,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cast(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{dtype:i}=n;if("complex64"===i){if("complex64"===a.dtype)return identity({inputs:{x:a},backend:r});let e=f.lls(a.shape),t=cast({inputs:{x:a},backend:r,attrs:{dtype:"float32"}}),n=complex({inputs:{real:t,imag:e},backend:r});return e.dispose(),r.disposeData(t.dataId),n}if("complex64"===a.dtype){let e=real({inputs:{input:a},backend:r}),t=cast({inputs:{x:e},backend:r,attrs:{dtype:i}});return r.disposeData(e.dataId),t}if(!f.D5U.hasEncodingLoss(a.dtype,i)){let e=identity({inputs:{x:a},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(r.shouldExecuteOnCPU([a])){let e=r.tensorMap.get(a.dataId).values,[t,n,o]=ei(e,a.shape,a.dtype,i);return r.makeTensorInfo(t,n,o)}if("int32"===i)return(/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t){let r=new UnaryOpProgram(e.shape,c.TO_INT),n=t.runWebGPUProgram(r,[e],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}(a,r));if("bool"===i){let e=r.makeTensorInfo([],"bool",f.D5U.getTypedArrayFromDType("bool",1)),t=tf({inputs:{a:a,b:e},backend:r});return r.disposeData(e.dataId),t}throw Error(`Error in Cast: failed to cast ${a.dtype} to ${i}`)}},tx=unaryKernelFunc({opType:c.CEIL,cpuKernelImpl:eo}),tb={kernelName:f.gJX,backendName:"webgpu",kernelFunc:tx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ClipVec4Program=class ClipVec4Program{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){let e=`
      ${getMainHeaderString("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `;return e}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ClipProgram=class ClipProgram{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){let e=`
      ${getMainHeaderString("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `;return e}};let tv={kernelName:f.xnO,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t;let{inputs:r,backend:n,attrs:a}=e,{x:i}=r,{clipValueMin:o,clipValueMax:s}=a,u=[{type:"float32",data:[o]},{type:"float32",data:[s]}];return t=f.D5U.sizeFromShape(i.shape)%4==0?new ClipVec4Program(i.shape):new ClipProgram(i.shape),n.runWebGPUProgram(t,[i],i.dtype,u)}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ComplexAbsProgram=class ComplexAbsProgram{constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){let e=`
    ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `;return e}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function makeComplexComponentTensorInfo(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}let tw={kernelName:f.yj2,backendName:"webgpu",kernelFunc:function(e){let{inputs:t,backend:r}=e,{x:n}=t,a=r.tensorMap.get(n.dataId),i=new ComplexAbsProgram(n.shape),o=[makeComplexComponentTensorInfo(n,a.complexTensorInfos.real),makeComplexComponentTensorInfo(n,a.complexTensorInfos.imag)];return r.runWebGPUProgram(i,o,o[0].dtype)}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ConcatProgram=class ConcatProgram{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=f.backend_util.computeOutShape(e,1),this.variableNames=e.map((e,t)=>`T${t}`),this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let e=0;e<this.offsetLength;e++)this.uniforms+=`offset${e} : i32,`;this.shaderKey="concat"}getUserCode(){let e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let t=1;t<this.offsetLength;t++)e.push(`else if (yC < uniforms.offset${[t]}){ setOutputAtCoords(coords.x, coords.y, getT${t}(yR, yC - uniforms.offset${t-1})); }`);let t=this.offsetLength,r=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${t}(yR, yC - uniforms.offset${r})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");let t=`
      ${getMainHeaderString("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join("\n        ")}
          }
        }
      }
    `;return t}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function imag(e){let{inputs:t,backend:r}=e,{input:n}=t,a=r.tensorMap.get(n.dataId);return identity({inputs:{x:a.complexTensorInfos.imag},backend:r})}let tC={kernelName:f.J_u,backendName:"webgpu",kernelFunc:imag};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function concat(e){let{inputs:t,backend:r,attrs:n}=e,{axis:a}=n,i=f.D5U.parseAxisParam(a,t[0].shape)[0],o=t.map(e=>e.shape);f.backend_util.assertParamsConsistent(o,i);let s=f.backend_util.computeOutShape(t.map(e=>e.shape),i);if(0===f.D5U.sizeFromShape(s))return r.makeTensorInfo(s,t[0].dtype,[]);let u=t.filter(e=>f.D5U.sizeFromShape(e.shape)>0);return 1===u.length?identity({inputs:{x:u[0]},backend:r}):/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function concatImpl(e,t,r){let n=e[0].dtype;if("complex64"===n){let n=e.map(e=>real({inputs:{input:e},backend:r})),a=e.map(e=>imag({inputs:{input:e},backend:r})),i=concatImpl(n,t,r),o=concatImpl(a,t,r),s=complex({inputs:{real:i,imag:o},backend:r});return n.forEach(e=>r.disposeData(e.dataId)),a.forEach(e=>r.disposeData(e.dataId)),r.disposeData(i.dataId),r.disposeData(o.dataId),s}let a=r.shouldExecuteOnCPU(e);if("string"===n&&(a=!0),a){let a=e.map(e=>{let n=f.D5U.sizeFromShape(e.shape.slice(t));return reshape({inputs:{x:e},backend:r,attrs:{shape:[-1,n]}})}),i=a.map(e=>({vals:r.readSync(e.dataId),shape:e.shape})),o=f.backend_util.computeOutShape(a.map(e=>e.shape),1),s=1===a[0].shape[0],u=es(i,o,n,s),l=f.backend_util.computeOutShape(e.map(e=>e.shape),t),d=r.makeTensorInfo(l,n,u);return a.forEach(e=>r.disposeData(e.dataId)),d}let i=r.device.limits.maxStorageBuffersPerShaderStage-1;if(e.length>i){let n=[];for(let a=0;a<e.length;a+=i){let o=e.slice(a,a+i);n.push(concatImpl(o,t,r))}let a=concatImpl(n,t,r);for(let e of n)r.disposeData(e.dataId);return a}let{tensors2D:o,outShape:s}=function(e,t,r){let n=f.backend_util.computeOutShape(e.map(e=>e.shape),t),a=e.map(e=>reshape({inputs:{x:e},backend:r,attrs:{shape:[f.D5U.sizeFromShape(e.shape.slice(0,t)),f.D5U.sizeFromShape(e.shape.slice(t))]}}));return{tensors2D:a,outShape:n}}(e,t,r),u=o.map(e=>e.shape),l=new ConcatProgram(u),d=[],h=Array(u.length-1);if(h.length>0){h[0]=u[0][1],d.push({type:"int32",data:[h[0]]});for(let e=1;e<h.length;e++)h[e]=h[e-1]+u[e][1],d.push({type:"int32",data:[h[e]]})}let c=r.runWebGPUProgram(l,o,o[0].dtype,d);o.forEach(e=>r.disposeData(e.dataId));let p=reshape({inputs:{x:c},backend:r,attrs:{shape:s}});return r.disposeData(c.dataId),p}(u,i,r)}let tS={kernelName:f.Eh3,backendName:"webgpu",kernelFunc:concat};let Conv2DMMProgram=class Conv2DMMProgram{constructor(e,t,r,n,a=!1,i=null,o=!1,s=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=((e.inChannels%4==0||e.inChannels%3==0)&&this.isChannelsLast||e.outWidth%4==0&&!this.isChannelsLast)&&e.outChannels%4==0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=computeWorkgroupSizeForConv2d(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=computeWorkPerThreadForConv2d(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!=0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),a&&(this.variableNames.push("bias"),this.variableComponents.push(4)),o&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],a&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=s,this.addBias=a,this.activation=i,this.hasPreluActivationWeights=o,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter==0,this.fitBOuter=r%this.tileBOuter==0,this.fitInner=n%this.tileInner==0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){let e=this.isVec4?makeMatMulPackedVec4Source(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):makeMatMulPackedSource(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1],r=`
    ${/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t,r,n,a=!1,i=null,o=!1,s=4,u=4,l=4){let d=e?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,h=e?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,c=e?"row":"col",p=e?"col":"row",f=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${e?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${c} / outWidth;
      let outCol = ${c} % outWidth;

      let WRow = ${p} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${p} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${p} % inChannels;
      var resData = ${typeSnippet(s)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${e?"uniforms.xShape[1]":"uniforms.xShape[2]"} && xCol >= 0 && xCol < ${e?"uniforms.xShape[2]":"uniforms.xShape[3]"}) {
        ${d}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${(e=>{switch(e){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw Error(`innerElementSize ${e} is not supported.`)}})(s)}
      }
      return resData;`,m=e?t&&n?`
      ${f}`:`
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${f}
      }
      return ${typeSnippet(s)}(0.0);`:n&&r?`
      ${f}`:`
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${f}
      }
      return ${typeSnippet(s)}(0.0);`,g=`${(e=>{switch(e){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw Error(`innerElementSize ${e} is not supported.`)}})(u)}`,y=typeSnippet(l),x=e?typeSnippet(s):typeSnippet(u),b=e?typeSnippet(u):typeSnippet(s),v=`
      ${activationFnSnippet(i,o,4===l,4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${x} {
        ${e?m:g}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${b} {
        ${e?g:m}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${y}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${e?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${h}
        ${biasActivationSnippet(a,i)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`;return v}(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}
    ${e}
  `;return r}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Conv2DNaiveProgram=class Conv2DNaiveProgram{constructor(e,t=!1,r=null,n=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=r,this.hasPreluActivationWeights=n,t&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){let e=`
       ${activationFnSnippet(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${biasActivationSnippet(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${getMainHeaderString("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `;return e}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Im2ColProgram=class Im2ColProgram{constructor(e,t){this.variableNames=["x"],this.uniforms=`pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){let e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,r=this.isChannelsLast?"coords[1]":"coords[2]",n=this.isChannelsLast?"coords[2]":"coords[1]",a=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)",i=`
    ${getMainHeaderString("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${r};
        let col = ${n};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {
            value = ${a};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `;return i}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getShapeForBatchMatMul(e,t){let r=e.length;return r>=3?t?[...e.slice(0,-3),e[r-3]*e[r-2],e[r-1]]:[...e.slice(0,-3),e[r-3],e[r-2]*e[r-1]]:!t&&1===r&&e[0]>1?[e[0],1]:null}function conv2DImpl({x:e,filter:t,convInfo:r,backend:n,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:s=null}){let u;let l=null!=a,d=null!=i,h="channelsLast"===r.dataFormat,c=h&&r.filterHeight===r.inHeight&&r.filterWidth===r.inWidth&&"VALID"===r.padInfo.type,p=(0,f.OBj)().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!p&&(c||1===r.filterHeight&&1===r.filterWidth&&1===r.dilationHeight&&1===r.dilationWidth&&1===r.strideHeight&&1===r.strideWidth&&("SAME"===r.padInfo.type||"VALID"===r.padInfo.type)))return function({x:e,filter:t,convInfo:r,backend:n,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:s=null}){let u,l;let d="channelsLast"===r.dataFormat,h=!d,c=d&&r.filterHeight===r.inHeight&&r.filterWidth===r.inWidth&&"VALID"===r.padInfo.type,p=[];if(c){let a=r.inHeight*r.inWidth*r.inChannels;u=reshape({inputs:{x:e},backend:n,attrs:{shape:[1,r.batchSize,a]}}),l=reshape({inputs:{x:t},backend:n,attrs:{shape:[1,a,r.outChannels]}})}else u=reshape({inputs:{x:e},backend:n,attrs:{shape:d?[r.batchSize,r.inHeight*r.inWidth,r.inChannels]:[r.batchSize,r.inChannels,r.inHeight*r.inWidth]}}),l=reshape({inputs:{x:t},backend:n,attrs:{shape:[1,r.inChannels,r.outChannels]}});if(p.push(u),p.push(l),null!=i){let e=getShapeForBatchMatMul(i.shape,d);null!=e&&(i=reshape({inputs:{x:i},backend:n,attrs:{shape:e}}),p.push(i))}if(null!=a){let e=getShapeForBatchMatMul(a.shape,d);null!=e&&(a=reshape({inputs:{x:a},backend:n,attrs:{shape:e}}),p.push(a))}let f=batchMatMulImpl({a:d?u:l,b:d?l:u,transposeA:h,transposeB:!1,backend:n,bias:a,activation:s,preluActivationWeights:i,leakyreluAlpha:o}),m=reshape({inputs:{x:f},backend:n,attrs:{shape:r.outShape}});for(let e of(p.push(f),p))n.disposeData(e.dataId);return m}({x:e,filter:t,convInfo:r,backend:n,bias:a,activation:s,preluActivationWeights:i,leakyreluAlpha:o});let m=(0,f.OBj)().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),g=m>-1?m:n.thresholdToIncreaseWorkgroups,y=r.batchSize*Math.ceil(r.outHeight*r.outWidth/32)*Math.ceil(r.outChannels/32);if((0,f.OBj)().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||y<=g)return function({x:e,filter:t,convInfo:r,backend:n,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:s=null}){let{filterWidth:u,filterHeight:l,inChannels:d,strideWidth:h,strideHeight:c,padInfo:p,outWidth:f,outHeight:m,dilationWidth:g,dilationHeight:y,dataFormat:x}=r,b="channelsLast"===x,v=u*l*d,w=m*f,C=b?[r.batchSize,w,v]:[r.batchSize,v,w],S=new Im2ColProgram(C,b),I=[{type:"int32",data:[p.top,p.left]},{type:"int32",data:[c,h]},{type:"int32",data:[y,g]},{type:"int32",data:[f]},{type:"int32",data:[d*u]},{type:"int32",data:[d]}],k=n.runWebGPUProgram(S,[e],e.dtype,I),R=[];R.push(k);let $=reshape({inputs:{x:t},backend:n,attrs:{shape:[1,v,-1]}});if(R.push($),null!=i){let e=getShapeForBatchMatMul(i.shape,b);null!=e&&(i=reshape({inputs:{x:i},backend:n,attrs:{shape:e}}),R.push(i))}if(null!=a){let e=getShapeForBatchMatMul(a.shape,b);null!=e&&(a=reshape({inputs:{x:a},backend:n,attrs:{shape:e}}),R.push(a))}let T=!b,D=batchMatMulImpl({a:b?k:$,b:b?$:k,transposeA:T,transposeB:!1,backend:n,bias:a,activation:s,preluActivationWeights:i,leakyreluAlpha:o}),A=reshape({inputs:{x:D},backend:n,attrs:{shape:r.outShape}});for(let e of(R.push(D),R))n.disposeData(e.dataId);return A}({x:e,filter:t,convInfo:r,backend:n,bias:a,preluActivationWeights:i,leakyreluAlpha:o,activation:s});let x=[r.padInfo.top,r.padInfo.left],b=[{type:"int32",data:[r.filterHeight,r.filterWidth]},{type:"int32",data:[...x]},{type:"int32",data:[r.strideHeight,r.strideWidth]},{type:"int32",data:[r.dilationHeight,r.dilationWidth]}];if(p)u=new Conv2DNaiveProgram(r,l,s,d);else{let e=h?r.outHeight*r.outWidth:r.outChannels,t=h?r.outChannels:r.outHeight*r.outWidth,a=r.filterHeight*r.filterWidth*r.inChannels;b.push({type:"int32",data:[e]},{type:"int32",data:[t]},{type:"int32",data:[a]});let i=n.adapterInfo.isIntel();u=new Conv2DMMProgram(r,e,t,a,l,s,d,i)}let v=[],w=[e,t];l&&(h||1!==a.shape.length||v.push(a=reshape({inputs:{x:a},backend:n,attrs:{shape:[a.shape[0],1,1]}})),w.push(a)),d&&(h||1!==i.shape.length||v.push(i=reshape({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}})),w.push(i)),"leakyrelu"===s&&(b.push({type:"float32",data:[o]}),u.uniforms+=" alpha : f32,");let C=n.runWebGPUProgram(u,w,e.dtype,b);for(let e of v)n.disposeData(e.dataId);return C}let tI={kernelName:f.mhS,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,attrs:r,backend:n}=e,{x:a,filter:i}=t,{strides:o,pad:s,dataFormat:u,dilations:l,dimRoundingMode:d}=r,h=f.backend_util.convertConv2DDataFormat(u),c=f.backend_util.computeConv2DInfo(a.shape,i.shape,o,l,s,d,!1,h);return conv2DImpl({x:a,filter:i,convInfo:c,backend:n})}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Conv2DDerInputProgram=class Conv2DDerInputProgram{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=this.isChannelsLast&&e.outChannels%4==0&&e.inChannels%4==0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){let e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,r=this.isChannelsLast?3:1,n=`
    ${getMainHeaderString()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;return this.isVec4?`
    ${n}
    `:`
    ${getMainHeaderString("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${r}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}};let Conv2DDerFilterProgram=class Conv2DDerFilterProgram{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`
    ${getMainHeaderString("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}};let Conv3DDerFilterProgram=class Conv3DDerFilterProgram{constructor(e){this.variableNames=["x","dy"],this.uniforms=`pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`
    ${getMainHeaderString("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}};let Conv3DDerInputProgram=class Conv3DDerInputProgram{constructor(e){this.variableNames=["dy","W"],this.uniforms=`filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`
    ${getMainHeaderString("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}};let tk={kernelName:f.wUP,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,dy:i}=t,{strides:o,pad:s,dataFormat:u,dimRoundingMode:l,filterShape:d}=n,h=f.backend_util.convertConv2DDataFormat(u),c=f.backend_util.computeConv2DInfo(a.shape,d,o,1,s,l,!1,h),p=new Conv2DDerFilterProgram(c),m=[{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.batchSize]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.inHeight]},{type:"int32",data:[c.inWidth]}];return r.runWebGPUProgram(p,[a,i],a.dtype,m)}};let Conv2DDerInputMMProgram=class Conv2DDerInputMMProgram{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,f.D5U.assert("channelsLast"===e.dataFormat,()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4==0&&e.outChannels%4==0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=computeWorkgroupSizeForConv2d(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=computeWorkPerThreadForConv2d(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){let e=this.isVec4?makeMatMulPackedVec4Source(this.elementsPerThread,this.workgroupSize):makeMatMulPackedSource(this.elementsPerThread,this.workgroupSize),t=`
    ${/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e=4){let t=`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${typeSnippet(e)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${typeSnippet(e)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${e}];`,r=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${t}
      }
      return ${typeSnippet(e)}(0.0);`,n=`
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${typeSnippet(e)} {
    ${r}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${typeSnippet(e)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${(e=>{switch(e){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw Error(`innerElementSize ${e} is not supported.`)}})(e)}
    }
    return ${typeSnippet(e)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${typeSnippet(e)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${e}] = value;
    }
  }`;return n}(this.isVec4?4:1)}
    ${e}
    `;return t}};let tR={kernelName:f.wm,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t;let{inputs:r,backend:n,attrs:a}=e,{dy:i,filter:o}=r,{inputShape:s,strides:u,pad:l,dataFormat:d,dimRoundingMode:h}=a,c=f.backend_util.convertConv2DDataFormat(d),p=f.backend_util.computeConv2DInfo(s,o.shape,u,1,l,h,!1,c),m=[{type:"int32",data:[p.filterHeight,p.filterWidth]},{type:"int32",data:[p.filterHeight-1-p.padInfo.top,p.filterWidth-1-p.padInfo.left]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.batchSize,p.outHeight,p.outWidth,p.outChannels]}];if((0,f.OBj)().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||"channelsLast"!==p.dataFormat)t=new Conv2DDerInputProgram(p);else{t=new Conv2DDerInputMMProgram(p);let e=p.inHeight*p.inWidth,r=p.inChannels,n=p.filterHeight*p.filterWidth*p.outChannels;m.push({type:"uint32",data:[e]},{type:"uint32",data:[r]},{type:"uint32",data:[n]})}return n.runWebGPUProgram(t,[i,o],"float32",m)}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Conv3DNaiveProgram=class Conv3DNaiveProgram{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){let e=`
    ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`;return e}};let t$={kernelName:f.x12,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,filter:i}=t,{strides:o,pad:s,dilations:u}=n,l=f.backend_util.computeConv3DInfo(a.shape,i.shape,o,u,s),d=[l.padInfo.front,l.padInfo.top,l.padInfo.left],h=[{type:"int32",data:[l.filterDepth,l.filterHeight,l.filterWidth]},{type:"int32",data:[...d]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.dilationDepth,l.dilationHeight,l.dilationWidth]}],c=new Conv3DNaiveProgram(l),p=(0,f.x8V)(a.dtype,i.dtype);return r.runWebGPUProgram(c,[a,i],p,h)}},tT={kernelName:f.o2y,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,dy:i}=t,{strides:o,pad:s,filterShape:u}=n,l=f.backend_util.computeConv3DInfo(a.shape,u,o,1,s),d=new Conv3DDerFilterProgram(l),h=[{type:"int32",data:[l.padInfo.front,l.padInfo.top,l.padInfo.left]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.batchSize]},{type:"int32",data:[l.outDepth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.inDepth]},{type:"int32",data:[l.inHeight]},{type:"int32",data:[l.inWidth]}];return r.runWebGPUProgram(d,[a,i],i.dtype,h)}},tD={kernelName:f.ik2,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,filter:i}=t,{strides:o,pad:s,inputShape:u}=n,l=f.backend_util.computeConv3DInfo(u,i.shape,o,1,s),d=new Conv3DDerInputProgram(l),h=[{type:"int32",data:[l.filterDepth,l.filterHeight,l.filterWidth]},{type:"int32",data:[l.filterDepth-1-l.padInfo.front,l.filterHeight-1-l.padInfo.top,l.filterWidth-1-l.padInfo.left]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.outDepth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.outChannels]}];return r.runWebGPUProgram(d,[a,i],a.dtype,h)}},tE=unaryKernelFunc({opType:c.COS}),tA={kernelName:f.mc4,backendName:"webgpu",kernelFunc:tE},tP=unaryKernelFunc({opType:c.COSH}),t_={kernelName:f.TR1,backendName:"webgpu",kernelFunc:tP};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let CropAndResizeProgram=class CropAndResizeProgram{constructor(e,t,r,n){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;let[a]=t;this.outputShape=[a,r[0],r[1],e],this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId="bilinear"===n?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){let[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[r,n,a]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[i,o,s]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`],u=`
    ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${r});
        let width_ratio = f32(${i});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${n};
        let width_scale = ${o};
        let in_y = ${a};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${s};
        if( in_x < 0.0 || in_x > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `;return u}};let tN={kernelName:f.VcC,backendName:"webgpu",kernelFunc:e=>{let{inputs:t,backend:r,attrs:n}=e,{image:a,boxes:i,boxInd:o}=t,{cropSize:s,method:u,extrapolationValue:l}=n,d=new CropAndResizeProgram(a.shape[3],i.shape,s,u),h=[{type:"float32",data:[l]}];return r.runWebGPUProgram(d,[a,i,o],"float32",h)}};(u=p||(p={})).Prod="*",u.Sum="+";let CumProgram=class CumProgram{constructor(e,t,r,n){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=r,this.reverse=n,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){let e=this.outputShape.length,t=this.op===p.Prod?"1.0":"0.0",r=this.exclusive?t:`getX(${cum_webgpu_getCoords(e,"coords",this.op)})`,n=this.outputShape[this.outputShape.length-1],a="",i="";return this.exclusive?(a=this.reverse?`end != ${n-1}`:"end != 0",i=this.reverse?"end + 1":"end - 1"):(a=this.reverse?`end + pow2 < ${n}`:"end >= pow2",i=this.reverse?"end + pow2":"end - pow2"),`
      ${getMainHeaderString("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${getFinalCoord(e,"coords",this.op)};
         var val = ${r};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${a}) {
           let idx = ${i};
           ${getFinalCoord(e,"coords",this.op)} = idx;
           val ${this.op}= getX(${cum_webgpu_getCoords(e,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}};function cum_webgpu_getCoords(e,t,r){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative ${r} for rank ${e} is not yet supported`)}function getFinalCoord(e,t,r){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative ${r} for rank ${e} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cumImpl(e,t,r,n,a,i){let o=t.shape.length,s=f.backend_util.getAxesPermutation([n],o),u=t;null!=s&&(u=transpose({inputs:{x:t},backend:r,attrs:{perm:s}}));let l=f.backend_util.getInnerMostAxes(1,o)[0];if(l!==o-1)throw Error(`WebGPU cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${n}`);let d=u.shape[l],h=identity({inputs:{x:u},backend:r});for(let t=0;t<=Math.ceil(Math.log2(d))-1;t++){let n=new CumProgram(e,u.shape,!1,i),a=h,o=[{type:"float32",data:[t]}];h=r.runWebGPUProgram(n,[h],h.dtype,o),r.disposeData(a.dataId)}if(a){let t=new CumProgram(e,u.shape,a,i),n=h;h=r.runWebGPUProgram(t,[h],h.dtype,[{type:"float32",data:[0]}]),r.disposeData(n.dataId)}if(null!=s){let e=f.backend_util.getUndoAxesPermutation(s),t=transpose({inputs:{x:h},backend:r,attrs:{perm:e}});return r.disposeData(h.dataId),r.disposeData(u.dataId),t}return h}let tF={kernelName:f.Byc,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:i,exclusive:o,reverse:s}=n;return cumImpl(p.Prod,a,r,i,o,s)}},tO={kernelName:f.iHb,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:i,exclusive:o,reverse:s}=n;return cumImpl(p.Sum,a,r,i,o,s)}},tB={kernelName:f.QRR,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,weights:i}=t,{size:o,binaryOutput:s}=n,u=1===a.shape.length,l=f.D5U.sizeFromShape(i.shape),d=l>0,h=i.dtype,c=u?[a.shape[0]]:[a.shape[0],a.shape[1]],p=u?[o]:[a.shape[0],o],m=fill({backend:r,attrs:{shape:p,value:0,dtype:h}}),g=new BincountProgram(c,d,s),y=d?[a,i]:[a],x=r.runWebGPUProgram(g,y,h,[{type:"int32",data:[o]}],m);return x}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DepthToSpaceProgram=class DepthToSpaceProgram{constructor(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){let e=`
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`;return e}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};let tL={kernelName:f.T0n,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{blockSize:i,dataFormat:o}=n,s=a.shape[0],u="NHWC"===o?a.shape[1]:a.shape[2],l="NHWC"===o?a.shape[2]:a.shape[3],d="NHWC"===o?a.shape[3]:a.shape[1],h=u*i,c=l*i,p=d/(i*i),f="NHWC"===o?[s,h,c,p]:[s,p,h,c],m=[{type:"int32",data:[i]}],g=new DepthToSpaceProgram(f,o);return r.runWebGPUProgram(g,[a],a.dtype,m)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DepthwiseConv2DNCHWSharedProgram=class DepthwiseConv2DNCHWSharedProgram{constructor(e,t,r,n=!1,a=null,i=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),n&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.addBias=n,this.activation=a,this.hasPreluActivation=i,this.filterHeight=t,this.filterWidth=r,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){let e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],r=this.workgroupSize[1]+this.filterHeight-1,n=this.workgroupSize[0]+this.filterWidth-1,a=`
      ${activationFnSnippet(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${n}>, ${r}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${getMainHeaderString()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${n}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${biasActivationSnippet(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `;return a}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DepthwiseConv2DVec4Program=class DepthwiseConv2DVec4Program{constructor(e,t=!1,r=null,n=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;let a=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=flatDispatchLayout(a),this.dispatch=computeDispatch(this.dispatchLayout,a,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),f.D5U.assert("channelsLast"===e.dataFormat,()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=r,this.hasPreluActivation=n,this.shaderKey=`depthwiseVec4_${r}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){let e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,r=this.convInfo.strideWidth,n=`
      ${activationFnSnippet(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${getMainHeaderString("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t}, ${r}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${r} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${biasActivationSnippet(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `;return n}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DepthwiseConv2DProgram=class DepthwiseConv2DProgram{constructor(e,t=!1,r=null,n=!1){this.variableNames=["x","W"],this.uniforms=`pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,t&&this.variableNames.push("bias"),n&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=r,this.hasPreluActivation=n,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){let e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);",t=`
      ${activationFnSnippet(this.activation,this.hasPreluActivation,!1,4)}

      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${biasActivationSnippet(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `;return t}};let tM={kernelName:f.cie,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t;let{inputs:r,backend:n,attrs:a}=e,{x:i,filter:o}=r,{strides:s,pad:u,dataFormat:l,dilations:d,dimRoundingMode:h}=a,c=f.backend_util.convertConv2DDataFormat(l),p=d;null==p&&(p=[1,1]);let m=f.backend_util.computeConv2DInfo(i.shape,o.shape,s,p,u,h,!0,c),g=[{type:"int32",data:[m.padInfo.top,m.padInfo.left]},{type:"int32",data:[m.inHeight,m.inWidth]}],y="channelsLast"===m.dataFormat;return!y&&m.inHeight>16&&m.inWidth>16&&1===m.strideHeight&&1===m.strideWidth&&1===m.dilationWidth&&1===m.dilationHeight&&m.inChannels===m.outChannels?t=new DepthwiseConv2DNCHWSharedProgram(m.outShape,m.filterHeight,m.filterWidth):y&&m.outHeight>4&&m.outWidth>4&&m.strideWidth<=2&&m.inChannels===m.outChannels&&1===m.dilationHeight&&1===m.dilationWidth&&m.inChannels%4==0?(t=new DepthwiseConv2DVec4Program(m),g.push({type:"int32",data:[t.virtualWidth]})):(t=new DepthwiseConv2DProgram(m),g.push({type:"int32",data:[m.filterHeight]},{type:"int32",data:[m.filterWidth]},{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.dilationHeight,m.dilationWidth]})),n.runWebGPUProgram(t,[i,o],i.dtype,g)}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DepthwiseConv2DDerFilterProgram=class DepthwiseConv2DDerFilterProgram{constructor(e){this.variableNames=["x","dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){let e=`
      ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;return e}};let DepthwiseConv2DDerInputProgram=class DepthwiseConv2DDerInputProgram{constructor(e){this.variableNames=["dy","W"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){let e=`
      ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;return e}};let tU={kernelName:f.sL$,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,dy:i}=t,{strides:o,dilations:s,pad:u,dimRoundingMode:l,filterShape:d}=n,h=f.backend_util.computeConv2DInfo(a.shape,d,o,s,u,l,!0),c=new DepthwiseConv2DDerFilterProgram(h),p=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.inHeight]},{type:"int32",data:[h.inWidth]},{type:"int32",data:[h.batchSize]},{type:"int32",data:[h.outChannels/h.inChannels]}];return r.runWebGPUProgram(c,[a,i],"float32",p)}},tz={kernelName:f.y7R,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,filter:i}=t,{strides:o,dilations:s,pad:u,dimRoundingMode:l,inputShape:d}=n,h=f.backend_util.computeConv2DInfo(d,i.shape,o,s,u,l,!0),c=new DepthwiseConv2DDerInputProgram(h),p=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.filterHeight-1-h.padInfo.top,h.filterWidth-1-h.padInfo.left]},{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"int32",data:[h.outChannels/h.inChannels]}];return r.runWebGPUProgram(c,[a,i],a.dtype,p)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DiagProgram=class DiagProgram{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){let e=`
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `;return e}};let tW={kernelName:f.$w,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r}=e,{x:n}=t,a=[...n.shape,...n.shape],i=f.D5U.sizeFromShape(n.shape),o=reshape({inputs:{x:n},backend:r,attrs:{shape:[i]}}),s=new DiagProgram(i),u=r.runWebGPUProgram(s,[o],o.dtype),l=reshape({inputs:{x:u},backend:r,attrs:{shape:a}});return r.disposeData(o.dataId),r.disposeData(u.dataId),l}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Dilation2DProgram=class Dilation2DProgram{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){let e=`
       ${getMainHeaderString("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `;return e}};let tV={kernelName:f.p4S,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,filter:i}=t,{strides:o,pad:s,dilations:u}=n,l=f.backend_util.computeDilation2DInfo(a.shape,i.shape,o,s,"NHWC",u),d=[l.padInfo.top,l.padInfo.left],h=[{type:"int32",data:[l.filterHeight,l.filterWidth]},{type:"int32",data:[...d]},{type:"int32",data:[l.strideHeight,l.strideWidth]},{type:"int32",data:[l.dilationHeight,l.dilationWidth]}],c=new Dilation2DProgram(l),p=r.runWebGPUProgram(c,[a,i],a.dtype,h);return p}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Dilation2DBackpropInputProgram=class Dilation2DBackpropInputProgram{constructor(e,t){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=flatDispatchLayout(e.outShape),this.dispatch=computeDispatch(this.dispatchLayout,e.outShape,this.workgroupSize),"float32"!==t&&"int32"!==t)throw Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${t} type.`);this.type=t,this.shaderKey="dilation2DBackpropInput"}getUserCode(){let e=`
       ${getMainHeaderString("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${atomicAddSnippet("&result[flatIndexIn]","value",this.type)}
         }
       }
     `;return e}};let Dilation2DBackpropFilterProgram=class Dilation2DBackpropFilterProgram{constructor(e,t,r){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=flatDispatchLayout(e.outShape),this.dispatch=computeDispatch(this.dispatchLayout,e.outShape,this.workgroupSize),"float32"!==r&&"int32"!==r)throw Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${r} type.`);this.type=r,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){let e=`
       ${getMainHeaderString("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${atomicAddSnippet("&result[flatIndexIn]","value",this.type)}
         }
       }
     `;return e}};let tG={kernelName:f.Vn9,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,filter:i,dy:o}=t,{strides:s,pad:u,dilations:l}=n,d=f.backend_util.computeDilation2DInfo(a.shape,i.shape,s,u,"NHWC",l),h=i.dtype,c=new Dilation2DBackpropFilterProgram(d,i.shape,h),p=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[f.D5U.sizeFromShape(d.outShape)]}],m=fill({backend:r,attrs:{shape:i.shape,value:0,dtype:h}});return r.runWebGPUProgram(c,[a,i,o],h,p,m)}},tH={kernelName:f.ekb,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,filter:i,dy:o}=t,{strides:s,pad:u,dilations:l}=n,d=f.backend_util.computeDilation2DInfo(a.shape,i.shape,s,u,"NHWC",l),h=a.dtype,c=new Dilation2DBackpropInputProgram(d,h),p=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[f.D5U.sizeFromShape(d.outShape)]}],m=fill({backend:r,attrs:{shape:d.inShape,value:0,dtype:h}});return r.runWebGPUProgram(c,[a,i,o],h,p,m)}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let DrawProgram=class DrawProgram{constructor(e,t,r){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=l.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=t,this.textureFormat=r,this.shaderKey=`draw_${t}_${r}`}getUserCode(){let e;let t="float32"===this.type?"value":"value / 255.0";e=`
      if (uniforms.numChannels == 1) {
        rgba[0] = ${t};
        rgba[1] = ${t};
        rgba[2] = ${t};
      } else {
        rgba[d] = ${t};
      }`;let r=`
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${getMainHeaderString("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${e}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `;return r}};let tK={kernelName:f.hGc,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t;let{inputs:r,backend:n,attrs:a}=e,{image:i}=r,{canvas:o,options:s}=a,[u,l]=i.shape.slice(0,2),{imageOptions:d}=s||{},h=(null==d?void 0:d.alpha)||1,c=n.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",p=[u,l],f=new DrawProgram(p,i.dtype,c);o.width=l,o.height=u;let m="webgpu",g=o.getContext(m);g||(g=(t=new OffscreenCanvas(l,u)).getContext(m));let y=3===i.shape.length?i.shape[2]:1;g.configure({device:n.device,format:c,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});let x="int32",b=n.makeTensorInfo(p,x),v=n.tensorMap.get(b.dataId);v.resource=g.getCurrentTexture(),v.external=!0;let w=[{type:"uint32",data:[y]},{type:"float32",data:[h]}];if(n.runWebGPUProgram(f,[i],x,w,b),t){let e=o.getContext("2d");if(!e)throw Error("Please make sure this canvas has only been used for 2d or webgpu context!");e.drawImage(t,0,0)}return n.disposeData(b.dataId),i}},tj=binaryKernelFunc({opType:h.MUL,cpuKernelImpl:eS,supportsComplex:!0}),tX={kernelName:f.wYn,backendName:"webgpu",kernelFunc:tj};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sum(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:i,keepDims:o}=n;return reduce(a,i,o,"sum",r)}let tq={kernelName:f.GBy,backendName:"webgpu",kernelFunc:sum},tY={kernelName:f.$g6,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{equation:a}=n,{allDims:i,summedDims:o,idDims:s}=f.backend_util.decodeEinsumEquation(a,t.length);f.backend_util.checkEinsumDimSizes(i.length,s,t);let{path:u,steps:l}=f.backend_util.getEinsumComputePath(o,s),d=l.length,h=null,c=i.length,p=[];for(let e=0;e<d;++e){for(let n of l[e]){let e;let{permutationIndices:a,expandDims:i}=f.backend_util.getEinsumPermutation(c,s[n]);f.backend_util.isIdentityPermutation(a)?e=t[n]:(e=transpose({inputs:{x:t[n]},backend:r,attrs:{perm:a}}),p.push(e));let o=e.shape.slice();for(let e=0;e<i.length;++e)o.splice(i[e],0,1);f.D5U.arraysEqual(e.shape,o)||(e=reshape({inputs:{x:e},backend:r,attrs:{shape:o}}),p.push(e)),null===h?h=e:(h=tj({inputs:{a:e,b:h},backend:r}),p.push(h))}e<d-1&&(u[e]>=0&&(h=sum({inputs:{x:h},backend:r,attrs:{axis:u[e]-(i.length-c),keepDims:!1}}),p.push(h)),c--)}for(let e of p)e!==h&&r.disposeData(e.dataId);return h}},tQ=unaryKernelFunc({opType:c.ELU}),tZ={kernelName:f.SX0,backendName:"webgpu",kernelFunc:tQ},tJ={kernelName:f.HEU,backendName:"webgpu",kernelFunc:e=>{let{inputs:t,backend:r}=e,{dy:n,y:a}=t,i=new BinaryOpProgram(h.ELU_DER,n.shape,a.shape);return r.runWebGPUProgram(i,[n,a],n.dtype)}},t0=binaryKernelFunc({opType:h.EQUAL,dtype:"bool",cpuKernelImpl:eu}),t1={kernelName:f.hdR,backendName:"webgpu",kernelFunc:t0},t2=unaryKernelFunc({opType:c.ERF}),t3={kernelName:f.Omj,backendName:"webgpu",kernelFunc:t2},t4=unaryKernelFunc({opType:c.EXP,cpuKernelImpl:el,dtype:"float32"}),t5={kernelName:f.NEP,backendName:"webgpu",kernelFunc:t4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function expandDims(e){let{inputs:t,attrs:r,backend:n}=e,{dim:a}=r,{input:i}=t,o=i.shape.length,s=i.shape.slice(),u=a;return a<0&&(f.D5U.assert(-(o+1)<=a,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+a+1),s.splice(u,0,1),reshape({inputs:{x:i},backend:n,attrs:{shape:s}})}let t6={kernelName:f.YFo,backendName:"webgpu",kernelFunc:expandDims},t8=unaryKernelFunc({opType:c.EXPM1,cpuKernelImpl:ed}),t7={kernelName:f.Y0y,backendName:"webgpu",kernelFunc:t8};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let FFTProgram=class FFTProgram{constructor(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){let e="real"===this.component?"return real * expR - imag * expI;":"return real * expI + imag * expR;",t=`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${e}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `;return t}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fftImpl(e,t,r){let n=r.tensorMap.get(e.dataId),a=f.D5U.sizeFromShape(e.shape),i=e.shape[e.shape.length-1],o=a/i,s=[],u=reshape({inputs:{x:e},backend:r,attrs:{shape:[o,i]}});s.push(u);let l=u.shape,d=new FFTProgram("real",l),h=new FFTProgram("imag",l),c=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:l},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:l}],p=t?2*Math.PI:-2*Math.PI,m=t?l[1]:1,g=[{type:"float32",data:[p]},{type:"float32",data:[m]}],y=r.runWebGPUProgram(d,c,"float32",g);s.push(y);let x=r.runWebGPUProgram(h,c,"float32",g);s.push(x);let b=complex({inputs:{real:y,imag:x},backend:r});s.push(b);let v=reshape({inputs:{x:b},backend:r,attrs:{shape:e.shape}});return s.forEach(e=>r.disposeData(e.dataId)),v}let t9={kernelName:f.vwp,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r}=e,{input:n}=t;return fftImpl(n,!1,r)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let FlipLeftRightProgram=class FlipLeftRightProgram{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){let e=`
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `;return e}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let re={kernelName:f.Uyb,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{let{image:r}=e,n=new FlipLeftRightProgram(r.shape),a=t.runWebGPUProgram(n,[r],r.dtype);return a}},rt=unaryKernelFunc({opType:c.FLOOR,cpuKernelImpl:eh}),rr={kernelName:f.OR,backendName:"webgpu",kernelFunc:rt},rn=binaryKernelFunc({opType:h.FLOOR_DIV,cpuKernelImpl:ec,dtype:"int32"}),ra={kernelName:f.jeX,backendName:"webgpu",kernelFunc:rn};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let FromPixelsProgram=class FromPixelsProgram{constructor(e,t,r=!1){this.pixelsOpType=l.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=r,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){let e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)",t=this.importVideo?"texture_external":"texture_2d<f32>";return`
      @binding(1) @group(0) var src: ${t};
      ${getMainHeaderString("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ri={kernelName:f.eBW,backendName:"webgpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:a}=e,{pixels:i}=t,{numChannels:o}=a;if(null==i)throw Error("pixels passed to tf.browser.fromPixels() can not be null");let s="undefined"!=typeof HTMLVideoElement&&i instanceof HTMLVideoElement,u="undefined"!=typeof HTMLImageElement&&i instanceof HTMLImageElement,l="undefined"!=typeof HTMLCanvasElement&&i instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&i instanceof OffscreenCanvas,d="undefined"!=typeof ImageBitmap&&i instanceof ImageBitmap,[h,c]=s?[i.videoWidth,i.videoHeight]:[i.width,i.height],p=[c,h,o],m=(0,f.OBj)().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&s,g=s||u;if(d||l||g){let e;if(m)e=r.device.importExternalTexture({source:i});else{if(g){let e=(0,f.OBj)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==n||e!==ro)&&(ro=e,n=document.createElement("canvas").getContext("2d",{willReadFrequently:ro})),n.canvas.width=h,n.canvas.height=c,n.drawImage(i,0,0,h,c),i=n.canvas}let t=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,a=r.textureManager.acquireTexture(p[1],p[0],"rgba8unorm",t);r.queue.copyExternalImageToTexture({source:i},{texture:a},[p[1],p[0]]),e=a}let t=f.D5U.sizeFromShape(p),a=f.D5U.computeStrides(p),s=new FromPixelsProgram(p,o,m),u=[{type:"uint32",data:[t]},{type:"uint32",data:[o]},{type:"uint32",data:[...a]}],l=r.makeTensorInfo([c,h],"int32"),d=r.tensorMap.get(l.dataId);d.resource=e;let y=r.runWebGPUProgram(s,[l],"int32",u);return r.disposeData(l.dataId),y}let y=i.data,x=y;if(null!=o&&4!==o){x=new Uint8Array(i.width*i.height*o);let e=y.length,t=0;for(let r=0;r<e;r++)r%4<o&&(x[t++]=y[r])}let b=r.makeTensorInfo(p,"int32",new Int32Array(x));return r.uploadToGPU(b.dataId),b}},ro=(0,f.OBj)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let BatchNormProgram=class BatchNormProgram{constructor(e,t,r,n,a){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],f.backend_util.assertAndGetBroadcastShape(e,t),f.backend_util.assertAndGetBroadcastShape(e,r),this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),null!=n&&(f.backend_util.assertAndGetBroadcastShape(e,n),this.variableNames.push("offset")),null!=a&&(f.backend_util.assertAndGetBroadcastShape(e,a),this.variableNames.push("scale")),this.offsetShape=n,this.scaleShape=a,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";null!=this.offsetShape&&(e="getOffsetByOutputIndex(index)");let t="1.0";null!=this.scaleShape&&(t="getScaleByOutputIndex(index)");let r=`
      ${getMainHeaderString("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${t};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `;return r}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rs={kernelName:f.sHE,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:r})=>{let{x:n,scale:a,offset:i,mean:o,variance:s}=e,{varianceEpsilon:u}=t,l=[n,o,s],d=null;null!=i&&(d=i.shape,l.push(i));let h=null;null!=a&&(h=a.shape,l.push(a));let c=new BatchNormProgram(n.shape,o.shape,s.shape,d,h),p=[{type:"float32",data:[u]}];return r.runWebGPUProgram(c,l,n.dtype,p)}},ru={kernelName:f._V0,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,filter:i,bias:o,preluActivationWeights:s}=t,{strides:u,pad:l,dataFormat:d,dilations:h,dimRoundingMode:c,activation:p,leakyreluAlpha:m}=n,g=f.backend_util.convertConv2DDataFormat(d),y=f.backend_util.computeConv2DInfo(a.shape,i.shape,u,h,l,c,!1,g);return conv2DImpl({x:a,filter:i,convInfo:y,backend:r,bias:o,preluActivationWeights:s,leakyreluAlpha:m,activation:p})}},rl={kernelName:f.luS,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t;let{inputs:r,backend:n,attrs:a}=e,{x:i,filter:o,bias:s,preluActivationWeights:u}=r,{strides:l,pad:d,dilations:h,dimRoundingMode:c,activation:p,leakyreluAlpha:m}=a,g=h;null==g&&(g=[1,1]),f.D5U.assert(f.backend_util.eitherStridesOrDilationsAreOne(l,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`);let y=f.backend_util.computeConv2DInfo(i.shape,o.shape,l,g,d,c,!0),x=[i,o],b=null!=s,v=null!=u;b&&x.push(s),v&&x.push(u);let w=[{type:"int32",data:[y.padInfo.top,y.padInfo.left]},{type:"int32",data:[y.inHeight,y.inWidth]}];y.outHeight>4&&y.outWidth>4&&y.strideWidth<=2&&y.inChannels===y.outChannels&&1===y.dilationHeight&&1===y.dilationWidth&&y.inChannels%4==0?(t=new DepthwiseConv2DVec4Program(y,b,p,v),w.push({type:"int32",data:[t.virtualWidth]})):(t=new DepthwiseConv2DProgram(y,b,p,v),w.push({type:"int32",data:[y.filterHeight]},{type:"int32",data:[y.filterWidth]},{type:"int32",data:[y.strideHeight,y.strideWidth]},{type:"int32",data:[y.dilationHeight,y.dilationWidth]})),"leakyrelu"===p&&(w.push({type:"float32",data:[m]}),t.uniforms+=" alpha : f32,");let C=n.runWebGPUProgram(t,x,"float32",w);return C}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let GatherNDProgram=class GatherNDProgram{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${getCoordsDataType(e)},`}getUserCode(){let e;e=this.sliceDim>1?"uniforms.strides[j]":"uniforms.strides";let t=`
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `;return t}};let rd={kernelName:f.q1x,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r}=e,{params:n,indices:a}=t,i=a.shape,o=i[i.length-1],s=f.D5U.sizeFromShape(n.shape),[u,l,d,h]=f.backend_util.prepareAndValidate(n,a),c=reshape({inputs:{x:a},backend:r,attrs:{shape:[l,o]}}),p=reshape({inputs:{x:n},backend:r,attrs:{shape:[f.D5U.sizeFromShape(n.shape)/d,d]}});if(r.shouldExecuteOnCPU([n,a])||"string"===n.dtype){let e=r.readSync(a.dataId),t=r.bufferSync(n),i=ep(e,t,n.dtype,l,o,d,h,n.shape,s);return r.makeTensorInfo(u,n.dtype,i.values)}let m=new GatherNDProgram(o,[l,d]),g=[{type:"int32",data:[o]},{type:"int32",data:h}],y=r.runWebGPUProgram(m,[p,c],p.dtype,g),x=reshape({inputs:{x:y},backend:r,attrs:{shape:u}});return r.disposeData(c.dataId),r.disposeData(p.dataId),r.disposeData(y.dataId),x}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let GatherProgram=class GatherProgram{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){let e=function(e){let t=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let n=0;n<e.length;n++)2===n?r.push("indexZ"):r.push(`${t[n]}`);return r.join()}(this.aShape),t=`
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `;return t}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gatherV2(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,indices:i}=t,{axis:o,batchDims:s}=n,u=f.D5U.parseAxisParam(o,a.shape)[0],l=f.backend_util.segment_util.collectGatherOpShapeInfo(a,i,u,s),d=f.D5U.sizeFromShape(i.shape),h=[],c=reshape({inputs:{x:a},backend:r,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),p=reshape({inputs:{x:i},backend:r,attrs:{shape:[l.batchSize,d/l.batchSize]}});h.push(c),h.push(p);let m=[l.batchSize,l.outerSize,d/l.batchSize,l.sliceSize];if(r.shouldExecuteOnCPU([a,i])){let e=r.tensorMap.get(p.dataId),t=e.values,n=(0,f.f3b)(p.shape,p.dtype,t),a=r.tensorMap.get(c.dataId),i=a.values,o=(0,f.f3b)(c.shape,c.dtype,i),s=ef(o,n,m);return h.forEach(e=>r.disposeData(e.dataId)),r.makeTensorInfo(l.outputShape,s.dtype,s.values)}let g=new GatherProgram(c.shape,m),y=r.runWebGPUProgram(g,[c,p],c.dtype);h.push(y);let x=reshape({inputs:{x:y},backend:r,attrs:{shape:l.outputShape}});return h.forEach(e=>r.disposeData(e.dataId)),x}let rh={kernelName:f.qi_,backendName:"webgpu",kernelFunc:gatherV2},rc=binaryKernelFunc({opType:h.GREATER,cpuKernelImpl:eg,dtype:"bool"}),rp={kernelName:f.iZT,backendName:"webgpu",kernelFunc:rc},rf=binaryKernelFunc({opType:h.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:em}),rm={kernelName:f.Acj,backendName:"webgpu",kernelFunc:rf},rg={kernelName:f.Qg5,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r}=e,{input:n}=t;return fftImpl(n,!0,r)}},ry=unaryKernelFunc({opType:c.IS_FINITE,dtype:"bool"}),rx={kernelName:f.avt,backendName:"webgpu",kernelFunc:ry},rb=unaryKernelFunc({opType:c.IS_INF,dtype:"bool"}),rv={kernelName:f.iWB,backendName:"webgpu",kernelFunc:rb},rw=unaryKernelFunc({opType:c.IS_NAN,dtype:"bool"}),rC={kernelName:f.r7n,backendName:"webgpu",kernelFunc:rw},rS={kernelName:f.J$2,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{alpha:i}=n,o=[{type:"float32",data:[i]}],s=new UnaryOpProgram(a.shape,c.LEAKYRELU,"alpha : f32,");return r.runWebGPUProgram(s,[a],"float32",o)}},rI=binaryKernelFunc({opType:h.LESS,dtype:"bool",cpuKernelImpl:ex}),rk={kernelName:f.vtC,backendName:"webgpu",kernelFunc:rI},rR=binaryKernelFunc({opType:h.LESS_EQUAL,dtype:"bool",cpuKernelImpl:ey}),r$={kernelName:f.CAk,backendName:"webgpu",kernelFunc:rR};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let LinSpaceProgram=class LinSpaceProgram{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){let e=`
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `;return e}};let rT={kernelName:f.e7N,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{backend:t,attrs:r}=e,{start:n,stop:a,num:i}=r,o=(a-n)/(i-1),s=new LinSpaceProgram(i),u=[{type:"float32",data:[n]},{type:"float32",data:[o]}];return t.runWebGPUProgram(s,[],"float32",u)}},rD=unaryKernelFunc({opType:c.LOG,cpuKernelImpl:eb}),rE={kernelName:f.ZbH,backendName:"webgpu",kernelFunc:rD},rA=unaryKernelFunc({opType:c.LOG1P}),rP={kernelName:f.kU,backendName:"webgpu",kernelFunc:rA},r_=binaryKernelFunc({opType:h.LOGICAL_AND,dtype:"bool"}),rN={kernelName:f.PYm,backendName:"webgpu",kernelFunc:r_},rF=unaryKernelFunc({opType:c.LOGICAL_NOT}),rO={kernelName:f.VfG,backendName:"webgpu",kernelFunc:rF},rB=binaryKernelFunc({opType:h.LOGICAL_OR}),rL={kernelName:f.MZg,backendName:"webgpu",kernelFunc:rB},rM=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;let LRNProgram=class LRNProgram{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){let e=`
    ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${rM}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `;return e}};let LRNSharedProgram=class LRNSharedProgram{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,f.D5U.assert(t<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t}`),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){let e=`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${getMainHeaderString()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${rM}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `;return e}};let rU={kernelName:f.eZ0,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t;let{inputs:r,backend:n,attrs:a}=e,{x:i}=r,{depthRadius:o,bias:s,alpha:u,beta:l}=a;t=o>16?new LRNProgram(i.shape):new LRNSharedProgram(i.shape,o);let d=[{type:"int32",data:[o]},{type:"float32",data:[s]},{type:"float32",data:[u]},{type:"float32",data:[l]}],h=n.runWebGPUProgram(t,[i],i.dtype,d);return h}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let LRNGradProgram=class LRNGradProgram{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){let e=`
    ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `;return e}};let rz={kernelName:f.Hhh,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,y:i,dy:o}=t,{depthRadius:s,bias:u,alpha:l,beta:d}=n,h=new LRNGradProgram(a.shape),c=r.runWebGPUProgram(h,[a,i,o],a.dtype,[{type:"int32",data:[s]},{type:"float32",data:[u]},{type:"float32",data:[l]},{type:"float32",data:[d]}]);return c}},rW=binaryKernelFunc({opType:h.MAX,cpuKernelImpl:ew}),rV={kernelName:f.BMI,backendName:"webgpu",kernelFunc:rW},rG={kernelName:f.mTV,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{filterSize:i,strides:o,pad:s,dimRoundingMode:u}=n,l=f.backend_util.computePool2DInfo(a.shape,i,o,1,s,u);return poolImpl(a,l,"max",r)}},rH={kernelName:f.OAf,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{filterSize:i,strides:o,pad:s,dataFormat:u,dimRoundingMode:l}=n,d=f.backend_util.computePool3DInfo(a.shape,i,o,[1,1,1],s,l,u),h=new Pool3DProgram(d,"max"),c=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.front,d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inDepth,d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]}];return r.runWebGPUProgram(h,[a],a.dtype,c)}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let MaxPool2DBackpropProgram=class MaxPool2DBackpropProgram{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){let e=`
      ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `;return e}};let MaxPool3DBackpropProgram=class MaxPool3DBackpropProgram{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){let e=`
      ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `;return e}};let rK={kernelName:f.OU7,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,input:i}=t,{filterSize:o,strides:s,pad:u,dimRoundingMode:l}=n,d=f.backend_util.computePool3DInfo(i.shape,o,s,[1,1,1],u,l),h=new Pool3DProgram(d,"max",!0),c=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.front,d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inDepth,d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]}],p=r.runWebGPUProgram(h,[i],"int32",c),m=new MaxPool3DBackpropProgram(d);c=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterDepth-1-d.padInfo.front,d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outDepth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]}];let g=r.runWebGPUProgram(m,[a,p],i.dtype,c);return r.disposeData(p.dataId),g}},rj={kernelName:f.OV7,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{dy:a,input:i,output:o}=t;assertNotComplex([i,o],"maxPoolGrad");let{filterSize:s,strides:u,pad:l,dimRoundingMode:d}=n,h=f.backend_util.computePool2DInfo(i.shape,s,u,1,l,d),c=new Pool2DProgram(h,"max",!0),p=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]},{type:"int32",data:[h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterHeight,h.effectiveFilterWidth]}],m=r.runWebGPUProgram(c,[i],"int32",p),g=new MaxPool2DBackpropProgram(h);p=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]},{type:"int32",data:[h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]}];let y=r.runWebGPUProgram(g,[a,m],i.dtype,p);return r.disposeData(m.dataId),y}},rX={kernelName:f.vFR,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{filterSize:a,strides:i,pad:o,includeBatchInIndex:s}=n,{x:u}=t;f.D5U.assert(4===u.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${u.shape.length}.`);let l=[1,1];f.D5U.assert(f.backend_util.eitherStridesOrDilationsAreOne(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let d=f.backend_util.computePool2DInfo(u.shape,a,i,l,o),h=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]}],c=new Pool2DProgram(d,"max",!1),p=r.runWebGPUProgram(c,[u],u.dtype,h);c=new Pool2DProgram(d,"max",!0,!0,s);let m=r.runWebGPUProgram(c,[u],"int32",h);return[p,m]}},rq={kernelName:f.c17,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:i,keepDims:o}=n;return reduce(a,i,o,"min",r)}},rY=binaryKernelFunc({opType:h.MIN,cpuKernelImpl:eC}),rQ={kernelName:f.q8u,backendName:"webgpu",kernelFunc:rY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let MirrorPadProgram=class MirrorPadProgram{constructor(e,t,r){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((t,r)=>t[0]+e[r]+t[1]),this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`}),this.offset="reflect"===r?0:1,this.shaderKey=`mirrorPad_${r}`}getUserCode(){let e=this.xShape.length,t=this.xShape.map((e,t)=>`uniforms.pad${t}[0]`).join(","),r=this.xShape.map((t,r)=>`uniforms.pad${r}[0] + uniforms.xShape${e>1?`[${r}]`:""}`).join(","),n=1===e?"start":"start[i]",a=1===e?"end":"end[i]",i=1===e?"outC":"outC[i]",o=getCoordsDataType(e),s=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let start = ${o}(${t});
          let end = ${o}(${r});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${i} < ${n}) {
              ${i} = ${n} * 2 - ${i} - ${this.offset};
            } else if(${i} >= ${a}) {
              ${i} = (${a} - 1) * 2 - ${i} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${s}));
        }
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rZ={kernelName:f.jQs,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:r})=>{let{x:n}=e,{paddings:a,mode:i}=t,o=a.map(e=>({type:"int32",data:[e[0],e[1]]})),s=new MirrorPadProgram(n.shape,a,i),u=r.runWebGPUProgram(s,[n],n.dtype,o);return u}},rJ=binaryKernelFunc({opType:h.MOD}),r0={kernelName:f.Vbg,backendName:"webgpu",kernelFunc:rJ};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let MultinomialProgram=class MultinomialProgram{constructor(e,t){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){let e=`
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `;return e}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SoftmaxProgram=class SoftmaxProgram{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){let e=`
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${getMainHeaderString("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `;return e}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function softmax(e){let{inputs:t,backend:r,attrs:n}=e,{logits:a}=t,{dim:i}=n,o=reshape({inputs:{x:a},backend:r,attrs:{shape:[f.D5U.sizeFromShape(a.shape)/a.shape[i],a.shape[i]]}}),s=new SoftmaxProgram(o.shape),u=r.runWebGPUProgram(s,[o],a.dtype),l=reshape({inputs:{x:u},backend:r,attrs:{shape:a.shape}});return r.disposeData(o.dataId),r.disposeData(u.dataId),l}let r1={kernelName:f.Gcp,backendName:"webgpu",kernelFunc:softmax},r2={kernelName:f.NZg,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{logits:a}=t,{numSamples:i,seed:o,normalized:s}=n,u=s?a:softmax({inputs:{logits:a},backend:r,attrs:{dim:a.shape.length-1}}),l=u.shape[0],d=u.shape[1],h=new MultinomialProgram(l,i),c=r.runWebGPUProgram(h,[u],"int32",[{type:"float32",data:[o]},{type:"int32",data:[d]}]);return s||r.disposeData(u.dataId),c}},r3={kernelName:f.kuV,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r}=e,{x:n}=t;if(r.shouldExecuteOnCPU([n])){let e=r.tensorMap.get(n.dataId),[t,a]=eI(e.values,n.shape,n.dtype);return r.makeTensorInfo(a,n.dtype,t)}let a=new UnaryOpProgram(n.shape,c.NEG);return r.runWebGPUProgram(a,[n],n.dtype)}},r4={kernelName:f.uv1,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:r,attrs:n}=e,{boxes:a,scores:i}=t,{maxOutputSize:o,iouThreshold:s,scoreThreshold:u}=n,l=r.readSync(a.dataId),d=r.readSync(i.dataId),{selectedIndices:h}=f.GDt.nonMaxSuppressionV3Impl(l,d,o,s,u);return r.makeTensorInfo([h.length],"int32",new Int32Array(h))}},r5={kernelName:f.W0H,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:r,attrs:n}=e,{boxes:a,scores:i}=t,{maxOutputSize:o,iouThreshold:s,scoreThreshold:u,softNmsSigma:l}=n,d=r.readSync(a.dataId),h=r.readSync(i.dataId),{selectedIndices:c,selectedScores:p}=f.GDt.nonMaxSuppressionV5Impl(d,h,o,s,u,l);return[r.makeTensorInfo([c.length],"int32",new Int32Array(c)),r.makeTensorInfo([p.length],"float32",new Float32Array(p))]}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let OneHotProgram=class OneHotProgram{constructor(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){let e=`
      ${getMainHeaderString("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `;return e}};let r6={kernelName:f.we_,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{indices:a}=t,{dtype:i,depth:o,onValue:s,offValue:u}=n,l=f.D5U.sizeFromShape(a.shape),d=new OneHotProgram(l,o),h=reshape({inputs:{x:a},backend:r,attrs:{shape:[l]}}),c=r.runWebGPUProgram(d,[h],i,[{type:"float32",data:[s]},{type:"float32",data:[u]}]);r.disposeData(h.dataId);let p=[...a.shape,o],m=reshape({inputs:{x:c},backend:r,attrs:{shape:p}});return r.disposeData(c.dataId),m}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zerosLike(e){let{inputs:t,backend:r}=e,{x:n}=t;if("complex64"!==n.dtype)return fill({attrs:{shape:n.shape,dtype:n.dtype,value:"string"===n.dtype?"":0},backend:r});{let e=real({inputs:{input:n},backend:r}),t=zerosLike({inputs:{x:e},backend:r}),a=imag({inputs:{input:n},backend:r}),i=zerosLike({inputs:{x:a},backend:r}),o=complex({inputs:{real:t,imag:i},backend:r});return r.disposeData(e.dataId),r.disposeData(t.dataId),r.disposeData(a.dataId),r.disposeData(i.dataId),o}}let r8={kernelName:f.RuY,backendName:"webgpu",kernelFunc:zerosLike},r7={kernelName:f.qWM,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function onesLike(e){let{inputs:t,backend:r}=e,{x:n}=t;if("string"===n.dtype)throw Error("onesLike is not supported under string dtype");if("complex64"!==n.dtype)return fill({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:r});{let e=real({inputs:{input:n},backend:r}),t=onesLike({inputs:{x:e},backend:r}),a=imag({inputs:{input:n},backend:r}),i=zerosLike({inputs:{x:a},backend:r}),o=complex({inputs:{real:t,imag:i},backend:r});return r.disposeData(e.dataId),r.disposeData(t.dataId),r.disposeData(a.dataId),r.disposeData(i.dataId),o}}},r9={kernelName:f.QiL,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{axis:a}=n;if(1===t.length)return expandDims({inputs:{input:t[0]},backend:r,attrs:{dim:a}});let i=t[0].shape,o=t[0].dtype;t.forEach(e=>{f.D5U.assertShapesMatch(i,e.shape,"All tensors passed to stack must have matching shapes"),f.D5U.assert(o===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});let s=[],u=t.map(e=>{let t=expandDims({inputs:{input:e},backend:r,attrs:{dim:a}});return s.push(t),t}),l=concat({inputs:u,backend:r,attrs:{axis:a}});return s.forEach(e=>r.disposeData(e.dataId)),l}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function padCommon(e,t=!1){let r=e.length,n=getCoordsDataType(r),a=e.map((e,t)=>`uniforms.pad${t}[0]`).join(","),i=e.map((e,t)=>`uniforms.pad${t}[0] + uniforms.xShape${r>1?`[${t}]`:""}`).join(","),o=r>1?`${n}(${a})`:`${a}`,s=r>1?`${n}(${i})`:`${i}`,u=r>1?"any(paddedCoords < start)":"paddedCoords < start",l=r>1?"any(paddedCoords >= end)":"paddedCoords >= end",d=r>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r):"coords";return`
        let start = ${o};
        let end = ${s};
        if (${u} || ${l}) {
          setOutputAtIndex(index, ${t?0:"uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${d}));
        }
  `}let PadProgram=class PadProgram{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((t,r)=>t[0]+e[r]+t[1]),this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){let e=`
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${padCommon(this.xShape)}
        }
      }
    `;return e}};let ne={kernelName:f.lyA,backendName:"webgpu",kernelFunc:e=>{let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{paddings:i,constantValue:o}=n;if(i.every(e=>f.D5U.arraysEqual(e,[0,0])))return identity({inputs:{x:a},backend:r});if(0===f.D5U.sizeFromShape(a.shape)){let e=i.map((e,t)=>e[0]+a.shape[t]+e[1]);return fill({backend:r,attrs:{shape:e,value:o,dtype:a.dtype}})}let s=[{type:"float32",data:[o]}];i.map(e=>s.push({type:"int32",data:[e[0],e[1]]}));let u=new PadProgram(a.shape,i);return r.runWebGPUProgram(u,[a],a.dtype,s)}},nt=binaryKernelFunc({opType:h.POW}),nr={kernelName:f.pe_,backendName:"webgpu",kernelFunc:nt},nn={kernelName:f.o0g,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r}=e,{x:n,alpha:a}=t,i=new BinaryOpProgram(h.PRELU,n.shape,a.shape);return r.runWebGPUProgram(i,[n,a],"float32")}},na={kernelName:f.DlI,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{axis:i,keepDims:o}=n;return reduce(a,i,o,"prod",r)}},ni={kernelName:f.e6w,backendName:"webgpu",kernelFunc:e=>{let{backend:t,attrs:r}=e,{start:n,stop:a,step:i,dtype:o}=r,s=e$(n,a,i,o);return t.makeTensorInfo([s.length],o,s)}},no=binaryKernelFunc({opType:h.DIV}),ns={kernelName:f.oHH,backendName:"webgpu",kernelFunc:no},nu=unaryKernelFunc({opType:c.RECIPROCAL}),nl={kernelName:f.$HU,backendName:"webgpu",kernelFunc:nu},nd=unaryKernelFunc({opType:c.RELU}),nh={kernelName:f.qkr,backendName:"webgpu",kernelFunc:nd},nc=unaryKernelFunc({opType:c.RELU6}),np={kernelName:f.SbG,backendName:"webgpu",kernelFunc:nc};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ResizeBilinearProgram=class ResizeBilinearProgram{constructor(e,t,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,r,e[3]],this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){let e=`
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `;return e}};let nf={kernelName:f._Yw,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{images:a}=t,{alignCorners:i,size:o,halfPixelCenters:s}=n,[u,l]=o,d=i&&u>1?1:0,h=i&&l>1?1:0,c=[{type:"float32",data:[d,h]},{type:"float32",data:[s?.5:0]}],p=new ResizeBilinearProgram(a.shape,u,l);return r.runWebGPUProgram(p,[a],"float32",c)}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ResizeBilinearBackpropProgram=class ResizeBilinearBackpropProgram{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeBilinearBackprop_${t}`}getUserCode(){let e=`
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `;return e}};let nm={kernelName:f.zbQ,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{images:a,dy:i}=t,{alignCorners:o}=n,[,s,u]=a.shape,[,l,d]=i.shape,h=[o&&l>1?s-1:s,o&&d>1?u-1:u],c=[o&&l>1?l-1:l,o&&d>1?d-1:d],p=h[0]/c[0],f=h[1]/c[1],m=1/p,g=1/f,y=2*Math.ceil(m)+2,x=2*Math.ceil(g)+2,b=new ResizeBilinearBackpropProgram(a.shape,o),v=[{type:"int32",data:h},{type:"int32",data:c},{type:"float32",data:[p]},{type:"float32",data:[f]},{type:"float32",data:[m]},{type:"float32",data:[g]},{type:"int32",data:[y]},{type:"int32",data:[x]}];return r.runWebGPUProgram(b,[i],i.dtype,v)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ResizeNearestNeighborProgram=class ResizeNearestNeighborProgram{constructor(e,t,r,n){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,r,e[3]],this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=n,this.shaderKey=`resizeNearest_${n}`}getUserCode(){let e;e=this.halfPixelCenters?"max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC";let t=`
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `;return t}};let ng={kernelName:f.dpD,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{images:a}=t,{alignCorners:i,halfPixelCenters:o,size:s}=n,[u,l]=s,d=i&&u>1?1:0,h=i&&l>1?1:0,c=[{type:"float32",data:[d,h]},{type:"float32",data:[i?.5:0]}],p=new ResizeNearestNeighborProgram(a.shape,u,l,o);return r.runWebGPUProgram(p,[a],a.dtype,c)}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ResizeNearestNeigborBackpropProgram=class ResizeNearestNeigborBackpropProgram{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeNearestNeigborBackprop_${t}`}getUserCode(){let e=`
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `;return e}};let ny={kernelName:f.Hmb,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{images:a,dy:i}=t,{alignCorners:o}=n,[,s,u]=a.shape,[,l,d]=i.shape,h=[o&&l>1?s-1:s,o&&d>1?u-1:u],c=[o&&l>1?l-1:l,o&&d>1?d-1:d],p=h[0]/c[0],f=h[1]/c[1],m=1/p,g=1/f,y=2*Math.ceil(m)+2,x=2*Math.ceil(g)+2,b=new ResizeNearestNeigborBackpropProgram(a.shape,o),v=[{type:"int32",data:h},{type:"int32",data:c},{type:"float32",data:[m]},{type:"float32",data:[g]},{type:"int32",data:[y]},{type:"int32",data:[x]}];return r.runWebGPUProgram(b,[i],i.dtype,v)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ReverseProgram=class ReverseProgram{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){let e=`
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    `,t=`
      ${e}
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `;return t}};let nx={kernelName:f.mKl,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{dims:i}=n,o=a.shape.length;if(0===o)return identity({inputs:{x:a},backend:r});let s=a.shape,u=[1,1,1,1];s.forEach((e,t)=>{u[t+4-o]=e});let l=f.D5U.parseAxisParam(i,a.shape),d=[0,0,0,0];l.forEach(e=>{d[e+4-o]=1});let h=[{type:"int32",data:d}],c=reshape({inputs:{x:a},backend:r,attrs:{shape:u}}),p=new ReverseProgram(u),m=r.runWebGPUProgram(p,[c],c.dtype,h);r.disposeData(c.dataId);let g=reshape({inputs:{x:m},backend:r,attrs:{shape:s}});return r.disposeData(m.dataId),g}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let RotateProgram=class RotateProgram{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=e,"number"==typeof t?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){let e=`
        ${getMainHeaderString("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `;return e}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nb={kernelName:f.b9H,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:r})=>{let{image:n}=e,{radians:a,fillValue:i,center:o}=t,s=new RotateProgram(n.shape,i),[u,l]=f.backend_util.getImageCenter(o,n.shape[1],n.shape[2]),d=[{type:"float32",data:[u]},{type:"float32",data:[l]},{type:"float32",data:[Math.sin(a)]},{type:"float32",data:[Math.cos(a)]}];"number"==typeof i?d.push({type:"float32",data:[Number.parseFloat(i.toFixed(2))]}):d.push({type:"float32",data:i});let h=r.runWebGPUProgram(s,[n],n.dtype,d);return h}},nv=unaryKernelFunc({opType:c.ROUND}),nw={kernelName:f.e07,backendName:"webgpu",kernelFunc:nv},nC=unaryKernelFunc({opType:c.RSQRT,cpuKernelImpl:eT}),nS={kernelName:f.bV0,backendName:"webgpu",kernelFunc:nC};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ScatterProgram=class ScatterProgram{constructor(e,t,r,n,a,i,o,s=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=i,this.type=o,this.sumDupeIndices=s,this.dispatchLayout=flatDispatchLayout(e),this.dispatch=computeDispatch(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${r}_${n}_${this.sliceDimGreaterThanOne}_${o}_${s}_${a.length}`;let u=getCoordsDataType(a.length);this.uniforms=`sliceDim : i32, strides: ${u}, updatesSize: i32,`,this.updatesRank=n,this.indicesRank=r}getUserCode(){let e="";1===this.indicesRank?e="coords[0]":2===this.indicesRank&&(e="coords[0], j");let t=`getIndices(${e})`,r=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides",n="",a="";1===this.dispatchLayout.x.length?(n="flattenedIndex",a=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):2===this.dispatchLayout.x.length&&(n="vec2<i32>(flattenedIndex, coords[1])",a=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);let i=Array.from({length:this.updatesRank},(e,t)=>`coords[${t}]`),o=`getUpdates(${i.join(", ")})`,s=`
    ${a}
      ${getMainHeaderString("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t}));
            flattenedIndex = flattenedIndex + indexInside * ${r};
          }
          let updateValue =
              ${dataTypeToGPUType(this.type)}(${o});
          let flatIndex = getOutputIndexFromCoords(${n});

          ${this.sumDupeIndices?atomicAddSnippet("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`;return s}};let nI={kernelName:f.xQA,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{indices:a,updates:i}=t,{shape:o}=n,{sliceRank:s,numUpdates:u,sliceSize:l,strides:d,outputSize:h}=f.backend_util.calculateShapes(i,a,o),c=[h/l,l];if(0===h)return r.makeTensorInfo(o,a.dtype);let p=reshape({inputs:{x:a},backend:r,attrs:{shape:[u,s]}}),m=reshape({inputs:{x:i},backend:r,attrs:{shape:[u,l]}}),g=m.dtype,y=fill({backend:r,attrs:{shape:c,value:0,dtype:g}}),x=f.D5U.sizeFromShape(m.shape),b=[{type:"int32",data:[s]},{type:"int32",data:d},{type:"int32",data:[x]}],v=new ScatterProgram(m.shape,s,p.shape.length,m.shape.length,d,c,g),w=r.runWebGPUProgram(v,[m,p],g,b,y),C=reshape({inputs:{x:w},backend:r,attrs:{shape:o}});return r.disposeData(p.dataId),r.disposeData(m.dataId),r.disposeData(w.dataId),C}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SearchSortedProgram=class SearchSortedProgram{constructor(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey=`search_sorted_${t}`}getUserCode(){let e="left"===this.side?"<":"<=",t=`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${e} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `;return t}};let nk={kernelName:f.nr8,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{sortedSequence:a,values:i}=t,{side:o}=n,s=new SearchSortedProgram([i.shape[0],i.shape[1]],o),u=[{type:"int32",data:[a.shape[1]]}];return r.runWebGPUProgram(s,[a,i],"int32",u)}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SelectProgram=class SelectProgram{constructor(e,t,r){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=r,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(1===this.rank)t="resRC",e="resRC";else{let r=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[],a=[];for(let e=0;e<this.outputShape.length;e++)a.push(`${r[e]}`),e<this.cRank&&n.push(`${r[e]}`);e=n.join(),t=a.join()}let r=`
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${t}));
          } else {
            setOutputAtIndex(index, getB(${t}));
          }
        }
      }
    `;return r}};let nR={kernelName:f.PhF,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r}=e,{condition:n,t:a,e:i}=t,o=new SelectProgram(n.shape.length,a.shape,a.shape.length);return r.runWebGPUProgram(o,[n,a,i],(0,f.x8V)(a.dtype,i.dtype))}},n$=unaryKernelFunc({opType:c.SELU}),nT={kernelName:f.oFR,backendName:"webgpu",kernelFunc:n$},nD=unaryKernelFunc({opType:c.SIGMOID}),nE={kernelName:f.a5O,backendName:"webgpu",kernelFunc:nD},nA=unaryKernelFunc({opType:c.SIGN}),nP={kernelName:f.i5y,backendName:"webgpu",kernelFunc:nA},n_=unaryKernelFunc({opType:c.SIN}),nN={kernelName:f.RQH,backendName:"webgpu",kernelFunc:n_},nF=unaryKernelFunc({opType:c.SINH}),nO={kernelName:f.wYB,backendName:"webgpu",kernelFunc:nF},nB=unaryKernelFunc({opType:c.SOFTPLUS}),nL={kernelName:f.MRv,backendName:"webgpu",kernelFunc:nB};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SpaceToBatchNDProgram=class SpaceToBatchNDProgram{constructor(e,t,r,n,a,i){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;let o=Array(n.length);for(let e=0;e<o.length;e++)o[e]=n[a[e]];this.outputShape=o,this.newDim=a,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=t,this.uniforms+=`reshapedPaddedXShape : ${getCoordsDataType(n.length)}, paddedXShapeStrides : ${getCoordsDataType(i)}, `,r.map((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${a}`}getUserCode(){let e=getCoordsDataType(this.outputShape.length),t=getSwitchedCoords(this.newDim),r=`
      ${getCoordsFromIndexSnippet(this.paddedXShape,"PaddedX")}
      ${getMainHeaderString("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${t}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${padCommon(this.xShape,!0)}
        }
      }
    `;return r}};let nM={kernelName:f.TQc,backendName:"webgpu",kernelFunc:e=>{let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{blockShape:i,paddings:o}=n;f.D5U.assert(a.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");let s=i.reduce((e,t)=>e*t),u=[[0,0]];u.push(...o);for(let e=1+i.length;e<a.shape.length;++e)u.push([0,0]);let l=u.map((e,t)=>e[0]+a.shape[t]+e[1]),d=f.backend_util.getReshaped(l,i,s,!1),h=f.backend_util.getPermuted(d.length,i.length,!1),c=f.backend_util.getReshapedPermuted(l,i,s,!1),p=f.D5U.computeStrides(l),m=new SpaceToBatchNDProgram(a.shape,l,u,d,h,p.length),g=[{type:"int32",data:d},{type:"int32",data:p}];u.map(e=>g.push({type:"int32",data:[e[0],e[1]]}));let y=r.runWebGPUProgram(m,[a],a.dtype,g),x=reshape({inputs:{x:y},backend:r,attrs:{shape:c}});return r.disposeData(y.dataId),x}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SparseSegmentSumProgram=class SparseSegmentSumProgram{constructor(e,t,r){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=r,this.dispatchLayout=flatDispatchLayout([t]),this.dispatch=computeDispatch(this.dispatchLayout,[t],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){let e=`
    ${getMainHeaderString("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${atomicAddSnippet("&result[outIndex]","value",this.type)}
      }
    }
  `;return e}};let SparseSegmentIdCountProgram=class SparseSegmentIdCountProgram{constructor(e,t){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=flatDispatchLayout(t),this.dispatch=computeDispatch(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){let e=`
    ${getMainHeaderString("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${atomicAddSnippet("&result[segmentId]","1","int32")}
      }
    }
  `;return e}};let SparseSegmentMeanProgram=class SparseSegmentMeanProgram{constructor(e,t){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=t,this.dispatchLayout=flatDispatchLayout(e),this.dispatch=computeDispatch(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){let e=`
    ${getMainHeaderString("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${"float32"===this.type?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `;return e}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sparseSegmentReduce(e,t,r,n=!1,a){let i;let o=f.D5U.sizeFromShape(e.shape),s=o/e.shape[0],u=e.dtype,l=f.D5U.sizeFromShape(t.shape),d=a.readSync(r.dataId),h=l>0?d[l-1]+1:0,c=e.shape.slice();c[0]=h;let p=l*s,m=fill({backend:a,attrs:{shape:c,value:0,dtype:u}});i=new SparseSegmentSumProgram(c,p,u);let g=[{type:"int32",data:[s]},{type:"int32",data:[p]}],y=a.runWebGPUProgram(i,[e,t,r],u,g,m);if(n)return y;let x=fill({backend:a,attrs:{shape:[h],value:0,dtype:"int32"}});i=new SparseSegmentIdCountProgram(h,r.shape);let b=a.runWebGPUProgram(i,[r],"int32",null,x),v=fill({backend:a,attrs:{shape:c,value:0,dtype:u}});i=new SparseSegmentMeanProgram(c,u),g=[{type:"int32",data:[s]}];let w=a.runWebGPUProgram(i,[y,b],u,g,v);return a.disposeData(y.dataId),a.disposeData(b.dataId),w}let nU={kernelName:f.w3H,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r}=e,{data:n,indices:a,segmentIds:i}=t;return sparseSegmentReduce(n,a,i,!1,r)}},nz={kernelName:f.ZjV,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r}=e,{data:n,indices:a,segmentIds:i}=t;return sparseSegmentReduce(n,a,i,!0,r)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TileProgram=class TileProgram{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;let r=Array(e.length);for(let n=0;n<r.length;n++)r[n]=e[n]*t[n];this.outputShape=r,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){let e=function(e,t=""){if(e>=5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`(resRC % ${t}aShape)`;let r=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let a=0;a<e;a++)n.push(`(${r[a]} % ${t}aShape[${a}])`);return n.join()}(this.rank,"uniforms."),t=`
      ${getMainHeaderString("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `;return t}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tile(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{reps:i}=n;if(r.shouldExecuteOnCPU([a])||"string"===a.dtype||a.shape.length>=5){let e=r.readSync(a.dataId),t="string"===a.dtype?e.map(e=>f.D5U.decodeString(e)):e,n=(0,f.f3b)(a.shape,a.dtype,t),o=eF(n,i);return r.makeTensorInfo(o.shape,o.dtype,o.values)}let o=new TileProgram(a.shape,i),s=r.runWebGPUProgram(o,[a],a.dtype);return s}let nW={kernelName:f.n9L,backendName:"webgpu",kernelFunc:tile},nV={kernelName:f.D2d,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{sparseIndices:a,sparseValues:i,defaultValue:o}=t,{outputShape:s}=n,{sliceRank:u,numUpdates:l,sliceSize:d,strides:h,outputSize:c}=f.backend_util.calculateShapes(i,a,s);if("string"===i.dtype){let e=r.bufferSync(a),t=r.bufferSync(i),n=f.D5U.decodeString(r.readSync(o.dataId)[0]),p=eD(e,t,s,c,d,l,u,h,n,!1);return r.makeTensorInfo(s,p.dtype,p.values)}let p=[c/d,d],m=reshape({inputs:{x:a},backend:r,attrs:{shape:[l,u]}}),g=i.shape.length?reshape({inputs:{x:i},backend:r,attrs:{shape:[l,d]}}):identity({inputs:{x:i},backend:r}),y=g.dtype,x=r.makeTensorInfo([],y,f.D5U.makeZerosTypedArray(1,y)),b=reshape({inputs:{x:o},backend:r,attrs:{shape:Array(p.length).fill(1)}}),v=tile({inputs:{x:b},backend:r,attrs:{reps:p}}),w=f.D5U.sizeFromShape([l,d]),C=[{type:"int32",data:[u]},{type:"int32",data:h},{type:"int32",data:[w]}];switch(l){case 0:break;case 1:{let e=new ScatterProgram([l,d],u,m.shape.length,g.shape.length,h,p,y,!1);r.runWebGPUProgram(e,[g,m],y,C,v)}break;default:{let e=new ScatterProgram([l,d],u,m.shape.length,x.shape.length,h,p,y,!1);r.runWebGPUProgram(e,[x,m],y,C,v)}{let e=new ScatterProgram([l,d],u,m.shape.length,g.shape.length,h,p,y);r.runWebGPUProgram(e,[g,m],y,C,v)}}let S=reshape({inputs:{x:v},backend:r,attrs:{shape:s}});return r.disposeData(m.dataId),r.disposeData(g.dataId),r.disposeData(b.dataId),r.disposeData(x.dataId),r.disposeData(v.dataId),S}},nG={kernelName:f.L8s,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{numOrSizeSplits:i,axis:o}=n,s=f.D5U.parseAxisParam(o,a.shape)[0],u=f.backend_util.prepareSplitSize(a,i,s),l=a.shape.length,d=Array(l).fill(0),h=a.shape.slice();return u.map(e=>{let t=[...h];t[s]=e;let n=slice({inputs:{x:a},backend:r,attrs:{begin:d,size:t}});return d[s]+=e,n})}},nH=unaryKernelFunc({opType:c.SQRT}),nK={kernelName:f.FKq,backendName:"webgpu",kernelFunc:nH},nj={kernelName:f.bK0,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{let{x:r}=e,n=new UnaryOpProgram(r.shape,c.SQUARE);return t.runWebGPUProgram(n,[r],r.dtype)}},nX=binaryKernelFunc({opType:h.SQUARED_DIFFERENCE}),nq={kernelName:f._tC,backendName:"webgpu",kernelFunc:nX},nY={kernelName:f.h8e,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function({inputs:e,attrs:t,backend:r}){let{x:n}=e,a=new UnaryOpProgram(n.shape,c.STEP,"stepAlpha : f32,"),i=[{type:"float32",data:[t.alpha]}];return r.runWebGPUProgram(a,[n],n.dtype,i)}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let StridedSliceProgram=class StridedSliceProgram{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);let t=getCoordsDataType(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){let e=this.outputShape.length,t="";if(1===e)t="coords * uniforms.strides + uniforms.begin";else{let e=0;t=this.outputShape.map((t,r)=>(e++,1===this.outputShape.length?`coords * uniforms.strides[${r}] + uniforms.begin[${r}]`:`coords[${e-1}] * uniforms.strides[${r}] + uniforms.begin[${r}]`)).join(",")}let r=`
       ${getMainHeaderString("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${t}));
         }
       }
     `;return r}};let nQ={kernelName:f.jQk,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t;let{inputs:r,backend:n,attrs:a}=e,{x:i}=r,{begin:o,end:s,strides:u,beginMask:l,endMask:d,ellipsisMask:h,newAxisMask:c,shrinkAxisMask:p}=a,{finalShapeSparse:m,finalShape:g,isIdentity:y,sliceDim0:x,isSimpleSlice:b,begin:v,end:w,strides:C}=f.kuN.sliceInfo(i.shape,o,s,u,l,d,h,c,p);if(y)t=reshape({inputs:{x:i},backend:n,attrs:{shape:g}});else if(x||b){f.D5U.assert(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);let e=f.kuN.computeOutShape(v,w,C),r=slice({inputs:{x:i},backend:n,attrs:{begin:v,size:e}});t=reshape({inputs:{x:r},backend:n,attrs:{shape:g}}),n.disposeData(r.dataId)}else{let e=n.shouldExecuteOnCPU([i]);if(e){let e=n.readSync(i.dataId),r=(0,f.f3b)(i.shape,i.dtype,e),a=eP(m,r,C,v);t=n.makeTensorInfo(g,i.dtype,a.values)}else{let e=new StridedSliceProgram(m),r=[{type:"int32",data:v},{type:"int32",data:C}],a=n.runWebGPUProgram(e,[i],i.dtype,r);t=reshape({inputs:{x:a},backend:n,attrs:{shape:g}}),n.disposeData(a.dataId)}}return t}},nZ={kernelName:f._JP,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{separator:a,nGramWidths:i,leftPad:o,rightPad:s,padWidth:u,preserveShortSequences:l}=n,{data:d,dataSplits:h}=t,c=r.readSync(d.dataId),p=r.readSync(h.dataId),[f,m]=e_(c,p,a,i,o,s,u,l);return[r.makeTensorInfo([f.length],"string",f),r.makeTensorInfo(h.shape,"int32",m)]}},nJ=binaryKernelFunc({opType:h.SUB,cpuKernelImpl:eN,supportsComplex:!0}),n0={kernelName:f.Tr8,backendName:"webgpu",kernelFunc:nJ},n1=unaryKernelFunc({opType:c.TAN}),n2={kernelName:f.sEM,backendName:"webgpu",kernelFunc:n1},n3=unaryKernelFunc({opType:c.TANH}),n4={kernelName:f.MIZ,backendName:"webgpu",kernelFunc:n3},n5={kernelName:f.SIB,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{tensor:a,indices:i,updates:o}=t,{}=n,{sliceRank:s,numUpdates:u,sliceSize:l,strides:d,outputSize:h}=f.backend_util.calculateShapes(o,i,a.shape),c=[h/l,l];if(0===h)return r.makeTensorInfo(a.shape,i.dtype);let p=[],m=reshape({inputs:{x:i},backend:r,attrs:{shape:[u,s]}});p.push(m);let g=reshape({inputs:{x:o},backend:r,attrs:{shape:[u,l]}});p.push(g);let y=reshape({inputs:{x:a},backend:r,attrs:{shape:c}});p.push(y);let x=tile({inputs:{x:y},backend:r,attrs:{reps:Array(c.length).fill(1)}}),b=new ScatterProgram([u,l],s,m.shape.length,g.shape.length,d,c,a.dtype,!1),v=f.D5U.sizeFromShape([u,l]),w=[{type:"int32",data:[s]},{type:"int32",data:d},{type:"int32",data:[v]}],C=r.runWebGPUProgram(b,[g,m],y.dtype,w,x);p.push(C);let S=reshape({inputs:{x:C},backend:r,attrs:{shape:a.shape}});return p.forEach(e=>r.disposeData(e.dataId)),S}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SwapProgram=class SwapProgram{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){let e=`
        ${getMainHeaderString("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `;return e}};let MergeProgram=class MergeProgram{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){let e=`
        ${getMainHeaderString("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `;return e}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function disposeIntermediateTensorInfoOrNull(e,t){null!==t&&e.disposeData(t.dataId)}function roundUpToPow2(e){let t=1;for(;t<e;)t*=2;return t}let n6={kernelName:f.cWu,backendName:"webgpu",kernelFunc:function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a}=t,{k:i,sorted:o}=n,s=a.shape,u=s[s.length-1];if(r.shouldExecuteOnCPU([a])){let e=r.readSync(a.dataId),[t,n]=eO(e,s,a.dtype,i,o);return[r.makeTensorInfo(t.shape,t.dtype,t.values),r.makeTensorInfo(n.shape,n.dtype,n.values)]}if(0===i)return s[s.length-1]=0,[r.makeTensorInfo(s,a.dtype,[]),r.makeTensorInfo(s,"int32",[])];if(1===u)return[a,fill({attrs:{shape:s,dtype:"int32",value:0},backend:r})];let l=f.D5U.sizeFromShape(s),d=l/u,h=reshape({inputs:{x:a},attrs:{shape:[d,u]},backend:r}),c=roundUpToPow2(i),p=roundUpToPow2(u),m=null,getInputs=()=>null===m?[h,h]:[h,m],runSwap=(e,t,n)=>{let a=getInputs(),i=new SwapProgram(n),o=null===m?1:0,s=[{type:"int32",data:[u]},{type:"int32",data:[o]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[e]},{type:"int32",data:[t]}],l=m;m=r.runWebGPUProgram(i,a,"int32",s),disposeIntermediateTensorInfoOrNull(r,l)};for(let e=1;e<c;e*=2){let t=2*e;for(let r=e;r>=1;r/=2)runSwap(t,r,[d,p])}for(let e=p;e>c;e/=2){let t=getInputs(),n=new MergeProgram([d,e/2]),a=null===m?1:0,i=[{type:"int32",data:[u]},{type:"int32",data:[a]},{type:"int32",data:[c]}],o=m;m=r.runWebGPUProgram(n,t,"int32",i),disposeIntermediateTensorInfoOrNull(r,o);let s=c/2,l=2*s;for(let e=s;e>=1;e/=2)runSwap(l,e,m.shape)}let g=m;m=slice({inputs:{x:m},backend:r,attrs:{begin:0,size:[d,i]}}),disposeIntermediateTensorInfoOrNull(r,g);let y=gatherV2({inputs:{x:h,indices:m},backend:r,attrs:{axis:1,batchDims:1}});disposeIntermediateTensorInfoOrNull(r,h);let x=s.slice(0,-1);x.push(i),g=m,m=reshape({inputs:{x:m},attrs:{shape:x},backend:r}),disposeIntermediateTensorInfoOrNull(r,g);let b=y;return y=reshape({inputs:{x:y},attrs:{shape:x},backend:r}),disposeIntermediateTensorInfoOrNull(r,b),[y,m]}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TransformProgram=class TransformProgram{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=flatDispatchLayout(this.outputShape),this.dispatch=computeDispatch(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){let e=`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${getMainHeaderString("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `;return e}};let n8={kernelName:f.wx7,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t;let{inputs:r,backend:n,attrs:a}=e,{image:i,transforms:o}=r,{interpolation:s,fillMode:u,fillValue:l,outputShape:d}=a,[h,c,p,f]=i.shape,[m,g]=null!=d?d:[c,p],y=new TransformProgram([h,m,g,f]);switch(u){case"constant":default:t=1;break;case"reflect":t=2;break;case"wrap":t=3;break;case"nearest":t=4}let x=[{type:"int32",data:["nearest"===s?1:2]},{type:"int32",data:[t]},{type:"float32",data:[l]}];return n.runWebGPUProgram(y,[i,o],"float32",x)}},n7={kernelName:f.ToN,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{value:a}=t,{axis:i}=n;i<0&&(i+=a.shape.length);let o=a.shape.length,s=a.shape[i],u=Array(o-1),l=0;for(let e=0;e<o;e++)e!==i&&(u[l++]=a.shape[e]);let d=[],h=Array(o).fill(0),c=a.shape.slice();c[i]=1;let p=Array(s);for(let e=0;e<p.length;e++){h[i]=e;let t=slice({inputs:{x:a},backend:r,attrs:{begin:h,size:c}}),n=reshape({inputs:{x:t},backend:r,attrs:{shape:u}});p[e]=n,d.push(t)}return d.forEach(e=>r.disposeData(e.dataId)),p}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let UnsortedSegmentSumProgram=class UnsortedSegmentSumProgram{constructor(e,t,r){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.dispatchLayout=flatDispatchLayout(e),this.dispatch=computeDispatch(this.dispatchLayout,e,this.workgroupSize),"float32"!==r&&"int32"!==r)throw Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${r} type.`);this.type=r,this.shaderKey="unsortedSegmentSum"}getUserCode(){let e=`
    ${getMainHeaderString("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${atomicAddSnippet("&result[flatIndex]","value",this.type)}
        }
      }
    }
  `;return e}};let n9={kernelName:f.Qvg,backendName:"webgpu",kernelFunc:/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let{inputs:t,backend:r,attrs:n}=e,{x:a,segmentIds:i}=t,{numSegments:o}=n,s=a.shape.length,u=[],l=0,d=f.backend_util.getAxesPermutation([l],s),h=a;null!=d&&(h=transpose({inputs:{x:a},backend:r,attrs:{perm:d}}),u.push(h),l=f.backend_util.getInnerMostAxes(1,s)[0]);let c=f.backend_util.segment_util.computeOutShape(h.shape,l,o),p=f.D5U.sizeFromShape([h.shape[l]]),m=reshape({inputs:{x:h},backend:r,attrs:{shape:[-1,p]}});u.push(m);let g=a.dtype,y=[m.shape[0],o],x=fill({backend:r,attrs:{shape:y,value:0,dtype:g}}),b=new UnsortedSegmentSumProgram(m.shape,y,g),v=[{type:"int32",data:[o]},{type:"int32",data:[f.D5U.sizeFromShape(m.shape)]}],w=r.runWebGPUProgram(b,[m,i],g,v,x),C=reshape({inputs:{x:w},backend:r,attrs:{shape:c}});u.push(w);let S=C;if(null!=d){u.push(C);let e=f.backend_util.getUndoAxesPermutation(d);S=transpose({inputs:{x:S},backend:r,attrs:{perm:e}})}return u.forEach(e=>r.disposeData(e.dataId)),S}};for(let e of[ee,eU,eW,eG,eK,ej,eY,eQ,eZ,eJ,e1,e3,e5,e8,e9,tr,tn,ta,ti,to,tl,tc,tp,ty,tb,tv,er,tw,tS,tI,tk,tR,t$,tT,tD,tA,t_,tN,tF,tO,tB,tL,tU,tz,tM,tW,tV,tG,tH,tK,tY,tZ,tJ,t1,t3,t5,t6,t7,t9,Z,re,ri,rr,ra,rs,ru,rl,rd,rh,rp,rm,et,rg,tC,rx,rv,rC,rS,rk,r$,rT,rP,rE,rN,rO,rL,rU,rz,te,rV,rG,rj,rH,rK,rX,tt,rq,rQ,rZ,r0,r2,tX,r3,r4,r5,tm,r6,r7,r9,ne,nr,nn,na,ni,tg,ns,nl,nh,np,J,nf,nm,ng,ny,nx,nb,nw,nS,nI,nk,nR,nT,nE,nP,nN,nO,tu,nY,nQ,nZ,r1,nL,nM,nU,nz,nV,nG,nK,nj,nq,n0,tq,n2,n4,n5,nW,n6,n8,eX,n7,n9,r8])(0,f.wCN)(e);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */},82783:function(e,t,r){"use strict";let n,a,i;r.d(t,{SYM:function(){return A},VGw:function(){return P},SpW:function(){return _},mm_:function(){return N},Xze:function(){return F},oT6:function(){return O},IKK:function(){return B},sJF:function(){return L},aJk:function(){return M},M2y:function(){return U},qw7:function(){return z},jMg:function(){return W},QCc:function(){return G},Oyi:function(){return V},JhU:function(){return H},_k9:function(){return j},IMb:function(){return X},ROF:function(){return K},XLW:function(){return q},zws:function(){return Y},zvY:function(){return Q},hCO:function(){return Z},eEB:function(){return J},RFZ:function(){return ee},gJX:function(){return et},xnO:function(){return er},Zz9:function(){return en},yj2:function(){return ea},Eh3:function(){return ei},mhS:function(){return eo},wUP:function(){return es},wm:function(){return eu},x12:function(){return el},o2y:function(){return ed},ik2:function(){return eh},mc4:function(){return ec},TR1:function(){return ep},VcC:function(){return eg},Byc:function(){return ef},iHb:function(){return em},JLz:function(){return DataStorage},QRR:function(){return ey},T0n:function(){return ex},cie:function(){return eb},sL$:function(){return ev},y7R:function(){return ew},$w:function(){return eC},p4S:function(){return eS},Vn9:function(){return ek},ekb:function(){return eI},hGc:function(){return eR},$g6:function(){return eT},SX0:function(){return eD},HEU:function(){return eE},hdR:function(){return eP},Omj:function(){return eA},NEP:function(){return e_},YFo:function(){return eN},Y0y:function(){return eF},vwp:function(){return eO},deh:function(){return eB},Uyb:function(){return eL},OR:function(){return eM},jeX:function(){return eU},eBW:function(){return ry},sHE:function(){return ez},_V0:function(){return rv},luS:function(){return rw},q1x:function(){return eV},qi_:function(){return eW},iZT:function(){return eG},Acj:function(){return eH},Qg5:function(){return ej},iJz:function(){return eK},J_u:function(){return eX},avt:function(){return eq},iWB:function(){return eY},r7n:function(){return eQ},Zuw:function(){return KernelBackend},eZ0:function(){return e8},Hhh:function(){return e7},J$2:function(){return eZ},vtC:function(){return eJ},CAk:function(){return e0},e7N:function(){return e1},ZbH:function(){return e2},kU:function(){return e3},PYm:function(){return e4},VfG:function(){return e5},MZg:function(){return e6},YoZ:function(){return e9},mTV:function(){return tt},OAf:function(){return tn},OU7:function(){return ta},OV7:function(){return tr},vFR:function(){return ti},BMI:function(){return te},q2K:function(){return to},c17:function(){return ts},q8u:function(){return tu},jQs:function(){return tl},Vbg:function(){return td},NZg:function(){return th},wYn:function(){return tc},kuV:function(){return tp},uv1:function(){return tm},cye:function(){return tg},W0H:function(){return ty},yQU:function(){return tf},we_:function(){return tb},qWM:function(){return tx},QiL:function(){return tv},lyA:function(){return tw},pe_:function(){return tC},o0g:function(){return tS},DlI:function(){return tI},dDz:function(){return tk},CQl:function(){return tR},BiW:function(){return t$},e6w:function(){return tT},xJR:function(){return tD},oHH:function(){return e$},$HU:function(){return tE},qkr:function(){return tA},SbG:function(){return tB},HZH:function(){return tP},_Yw:function(){return tF},zbQ:function(){return tO},dpD:function(){return t_},Hmb:function(){return tN},mKl:function(){return tL},b9H:function(){return rx},e07:function(){return tM},bV0:function(){return tU},xQA:function(){return tz},nr8:function(){return tV},PhF:function(){return tG},oFR:function(){return tH},a5O:function(){return tY},i5y:function(){return tq},RQH:function(){return tj},wYB:function(){return tX},p2w:function(){return tK},Gcp:function(){return t2},MRv:function(){return tQ},TQc:function(){return t0},O3z:function(){return t3},nhH:function(){return t4},w3H:function(){return t5},ZjV:function(){return t6},D2d:function(){return t8},L8s:function(){return t1},FKq:function(){return tZ},bK0:function(){return t9},_tC:function(){return t7},e0R:function(){return re},h8e:function(){return rg},jQk:function(){return rt},_JP:function(){return rr},s1s:function(){return rn},XkS:function(){return ra},Tr8:function(){return ri},GBy:function(){return tJ},sEM:function(){return ro},MIZ:function(){return rs},YDk:function(){return TensorBuffer},SIB:function(){return tW},n9L:function(){return ru},cWu:function(){return rl},wx7:function(){return rd},G3Y:function(){return rh},kpP:function(){return rc},ToN:function(){return rp},Qvg:function(){return rf},RuY:function(){return rm},usg:function(){return rb},backend_util:function(){return k},UFq:function(){return r7},Jyw:function(){return C},f3b:function(){return buffer},C2$:function(){return w},hiC:function(){return rq},SRH:function(){return engine},OBj:function(){return environment_env},GDt:function(){return R},J69:function(){return r9},glt:function(){return nextFrame},sQ3:function(){return r2},jqO:function(){return registerBackend},wCN:function(){return registerKernel},XLQ:function(){return r8},iD$:function(){return scalar},CQI:function(){return setBackend},tdS:function(){return nb},kuN:function(){return S},Vl2:function(){return ne},luU:function(){return r3},Smz:function(){return nt},z4k:function(){return sumOutType},odF:function(){return tensor2d},lub:function(){return tidy},x8V:function(){return upcastType},D5U:function(){return v},lls:function(){return zeros}});var o,s,u,l,d,h,c,p,f,m,g,y,x,b,v={};r.r(v),r.d(v,{arraysEqual:function(){return arraysEqual},arraysEqualWithNull:function(){return arraysEqualWithNull},assert:function(){return util_base_assert},assertNonNegativeIntegerDimensions:function(){return assertNonNegativeIntegerDimensions},assertNonNull:function(){return assertNonNull},assertShapesMatch:function(){return assertShapesMatch},bytesFromStringArray:function(){return bytesFromStringArray},bytesPerElement:function(){return bytesPerElement},checkConversionForErrors:function(){return checkConversionForErrors},clamp:function(){return clamp},computeStrides:function(){return computeStrides},convertBackendValuesAndArrayBuffer:function(){return convertBackendValuesAndArrayBuffer},createScalarValue:function(){return createScalarValue},createShuffledIndices:function(){return createShuffledIndices},decodeString:function(){return decodeString},distSquared:function(){return distSquared},encodeString:function(){return encodeString},fetch:function(){return util_fetch},fingerPrint64:function(){return fingerPrint64},flatten:function(){return flatten},getArrayFromDType:function(){return getArrayFromDType},getTypedArrayFromDType:function(){return getTypedArrayFromDType},hasEncodingLoss:function(){return hasEncodingLoss},hexToLong:function(){return hexToLong},indexToLoc:function(){return indexToLoc},inferDtype:function(){return inferDtype},inferFromImplicitShape:function(){return inferFromImplicitShape},isBoolean:function(){return isBoolean},isFunction:function(){return isFunction},isInt:function(){return isInt},isNumber:function(){return isNumber},isPromise:function(){return isPromise},isScalarShape:function(){return isScalarShape},isString:function(){return isString},isTypedArray:function(){return isTypedArray},isValidDtype:function(){return isValidDtype},locToIndex:function(){return locToIndex},makeOnesTypedArray:function(){return makeOnesTypedArray},makeZerosNestedTypedArray:function(){return makeZerosNestedTypedArray},makeZerosTypedArray:function(){return makeZerosTypedArray},nearestDivisor:function(){return nearestDivisor},nearestLargerEven:function(){return nearestLargerEven},now:function(){return now},parseAxisParam:function(){return parseAxisParam},randUniform:function(){return randUniform},repeatedTry:function(){return repeatedTry},rightPad:function(){return rightPad},shuffle:function(){return shuffle},shuffleCombo:function(){return shuffleCombo},sizeFromShape:function(){return util_base_sizeFromShape},sizeToSquarishShape:function(){return sizeToSquarishShape},squeezeShape:function(){return squeezeShape},sum:function(){return sum},swap:function(){return swap},tanh:function(){return tanh},toNestedArray:function(){return toNestedArray},toTypedArray:function(){return toTypedArray}});var w={};r.r(w),r.d(w,{isBrowser:function(){return isBrowser},isMobile:function(){return isMobile},mockIsMobile:function(){return mockIsMobile}});var C={};r.r(C),r.d(C,{assertAndGetBroadcastShape:function(){return assertAndGetBroadcastShape},getBroadcastDims:function(){return getBroadcastDims},getReductionAxes:function(){return getReductionAxes}});var S={};r.r(S),r.d(S,{assertParamsValid:function(){return assertParamsValid},computeFlatOffset:function(){return computeFlatOffset},computeOutShape:function(){return computeOutShape},getNormalizedAxes:function(){return getNormalizedAxes},isSliceContinous:function(){return isSliceContinous},maskToAxes:function(){return maskToAxes},parseSliceParams:function(){return parseSliceParams},sliceInfo:function(){return sliceInfo},startForAxis:function(){return startForAxis},startIndicesWithElidedDims:function(){return startIndicesWithElidedDims},stopForAxis:function(){return stopForAxis},stopIndicesWithElidedDims:function(){return stopIndicesWithElidedDims},stridesForAxis:function(){return stridesForAxis},stridesWithElidedDims:function(){return stridesWithElidedDims}});var I={};r.r(I),r.d(I,{collectGatherOpShapeInfo:function(){return collectGatherOpShapeInfo},computeOutShape:function(){return segment_util_computeOutShape},segOpComputeOptimalWindowSize:function(){return segOpComputeOptimalWindowSize}});var k={};r.r(k),r.d(k,{ERF_A1:function(){return nA},ERF_A2:function(){return nP},ERF_A3:function(){return n_},ERF_A4:function(){return nN},ERF_A5:function(){return nF},ERF_P:function(){return nE},PARALLELIZE_THRESHOLD:function(){return n$},RowPartitionType:function(){return b},SELU_SCALE:function(){return nD},SELU_SCALEALPHA:function(){return nT},applyActivation:function(){return applyActivation},assertAndGetBroadcastShape:function(){return assertAndGetBroadcastShape},assertAxesAreInnerMostDims:function(){return assertAxesAreInnerMostDims},assertParamsConsistent:function(){return assertParamsConsistent},assignToTypedArray:function(){return assignToTypedArray},axesAreInnerMostDims:function(){return axesAreInnerMostDims},calculateShapes:function(){return calculateShapes},checkEinsumDimSizes:function(){return checkEinsumDimSizes},checkPadOnDimRoundingMode:function(){return checkPadOnDimRoundingMode},combineLocations:function(){return combineLocations},combineRaggedTensorToTensorShapes:function(){return combineRaggedTensorToTensorShapes},complexWithEvenIndex:function(){return complexWithEvenIndex},complexWithOddIndex:function(){return complexWithOddIndex},computeConv2DInfo:function(){return computeConv2DInfo},computeConv3DInfo:function(){return computeConv3DInfo},computeDefaultPad:function(){return computeDefaultPad},computeDilation2DInfo:function(){return computeDilation2DInfo},computeOptimalWindowSize:function(){return computeOptimalWindowSize},computeOutAndReduceShapes:function(){return computeOutAndReduceShapes},computeOutShape:function(){return concat_util_computeOutShape},computePool2DInfo:function(){return computePool2DInfo},computePool3DInfo:function(){return computePool3DInfo},convertConv2DDataFormat:function(){return convertConv2DDataFormat},decodeEinsumEquation:function(){return decodeEinsumEquation},eitherStridesOrDilationsAreOne:function(){return eitherStridesOrDilationsAreOne},expandShapeToKeepDim:function(){return expandShapeToKeepDim},exponent:function(){return exponent},exponents:function(){return exponents},fromStringArrayToUint8:function(){return fromStringArrayToUint8},fromUint8ToStringArray:function(){return fromUint8ToStringArray},getAxesPermutation:function(){return getAxesPermutation},getBroadcastDims:function(){return getBroadcastDims},getComplexWithIndex:function(){return getComplexWithIndex},getEinsumComputePath:function(){return getEinsumComputePath},getEinsumPermutation:function(){return getEinsumPermutation},getFusedBiasGradient:function(){return getFusedBiasGradient},getFusedDyActivation:function(){return getFusedDyActivation},getImageCenter:function(){return getImageCenter},getInnerMostAxes:function(){return getInnerMostAxes},getPermuted:function(){return getPermuted},getRaggedRank:function(){return getRaggedRank},getReductionAxes:function(){return getReductionAxes},getReshaped:function(){return getReshaped},getReshapedPermuted:function(){return getReshapedPermuted},getRowPartitionTypesHelper:function(){return getRowPartitionTypesHelper},getSliceBeginCoords:function(){return getSliceBeginCoords},getSliceSize:function(){return getSliceSize},getSparseFillEmptyRowsIndicesDenseShapeMismatch:function(){return getSparseFillEmptyRowsIndicesDenseShapeMismatch},getSparseFillEmptyRowsNegativeIndexErrorMessage:function(){return getSparseFillEmptyRowsNegativeIndexErrorMessage},getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:function(){return getSparseFillEmptyRowsOutOfRangeIndexErrorMessage},getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:function(){return getSparseReshapeEmptyTensorZeroOutputDimErrorMessage},getSparseReshapeInputOutputMismatchErrorMessage:function(){return getSparseReshapeInputOutputMismatchErrorMessage},getSparseReshapeInputOutputMultipleErrorMessage:function(){return getSparseReshapeInputOutputMultipleErrorMessage},getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:function(){return getSparseReshapeMultipleNegativeOneOutputDimErrorMessage},getSparseReshapeNegativeOutputDimErrorMessage:function(){return getSparseReshapeNegativeOutputDimErrorMessage},getSparseSegmentReductionIndicesOutOfRangeErrorMessage:function(){return getSparseSegmentReductionIndicesOutOfRangeErrorMessage},getSparseSegmentReductionNegativeSegmentIdsErrorMessage:function(){return getSparseSegmentReductionNegativeSegmentIdsErrorMessage},getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:function(){return getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage},getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:function(){return getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage},getUndoAxesPermutation:function(){return getUndoAxesPermutation},isIdentityPermutation:function(){return isIdentityPermutation},log:function(){return log_log},mergeRealAndImagArrays:function(){return mergeRealAndImagArrays},prepareAndValidate:function(){return prepareAndValidate},prepareSplitSize:function(){return prepareSplitSize},segment_util:function(){return I},shouldFuse:function(){return shouldFuse},slice_util:function(){return S},splitRealAndImagArrays:function(){return splitRealAndImagArrays},stridesOrDilationsArePositive:function(){return stridesOrDilationsArePositive},tupleValuesAreOne:function(){return tupleValuesAreOne},upcastType:function(){return upcastType},validateDefaultValueShape:function(){return validateDefaultValueShape},validateInput:function(){return validateInput},validateUpdateShape:function(){return validateUpdateShape},warn:function(){return warn}});var R={};r.r(R),r.d(R,{nonMaxSuppressionV3Impl:function(){return nonMaxSuppressionV3Impl},nonMaxSuppressionV4Impl:function(){return nonMaxSuppressionV4Impl},nonMaxSuppressionV5Impl:function(){return nonMaxSuppressionV5Impl},whereImpl:function(){return whereImpl}});let DataStorage=class DataStorage{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}};let KernelBackend=class KernelBackend{refCount(e){return notYetImplemented("refCount")}incRef(e){return notYetImplemented("incRef")}timerAvailable(){return!0}time(e){return notYetImplemented("time")}read(e){return notYetImplemented("read")}readSync(e){return notYetImplemented("readSync")}readToGPU(e,t){return notYetImplemented("readToGPU")}numDataIds(){return notYetImplemented("numDataIds")}disposeData(e,t){return notYetImplemented("disposeData")}write(e,t,r){return notYetImplemented("write")}move(e,t,r,n,a){return notYetImplemented("move")}createTensorFromGPUData(e,t,r){return notYetImplemented("createTensorFromGPUData")}memory(){return notYetImplemented("memory")}floatPrecision(){return notYetImplemented("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return notYetImplemented("dispose")}};function notYetImplemented(e){throw Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function shuffle(e){let t=e.length,r=0;for(;t>0;)r=Math.random()*t|0,swap(e,--t,r)}function shuffleCombo(e,t){if(e.length!==t.length)throw Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let r=e.length,n=0;for(;r>0;)n=Math.random()*r|0,swap(e,--r,n),swap(t,r,n)}function clamp(e,t,r){return Math.max(e,Math.min(t,r))}function nearestLargerEven(e){return e%2==0?e:e+1}function swap(e,t,r){let n=e[t];e[t]=e[r],e[r]=n}function sum(e){let t=0;for(let r=0;r<e.length;r++)t+=e[r];return t}function randUniform(e,t){let r=Math.random();return t*r+(1-r)*e}function distSquared(e,t){let r=0;for(let n=0;n<e.length;n++){let a=Number(e[n])-Number(t[n]);r+=a*a}return r}function util_base_assert(e,t){if(!e)throw Error("string"==typeof t?t:t())}function assertShapesMatch(e,t,r=""){util_base_assert(arraysEqual(e,t),()=>r+` Shapes ${e} and ${t} must match`)}function assertNonNull(e){util_base_assert(null!=e,()=>"The input to the tensor constructor must be a non-null value.")}function util_base_sizeFromShape(e){if(0===e.length)return 1;let t=e[0];for(let r=1;r<e.length;r++)t*=e[r];return t}function isScalarShape(e){return 0===e.length}function arraysEqualWithNull(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(null!==e[r]&&null!==t[r]&&e[r]!==t[r])return!1;return!0}function arraysEqual(e,t){if(e===t)return!0;if(null==e||null==t||e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(e[r]!==t[r])return!1;return!0}function isInt(e){return e%1==0}function tanh(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return -1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function sizeToSquarishShape(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function createShuffledIndices(e){let t=new Uint32Array(e);for(let r=0;r<e;++r)t[r]=r;return shuffle(t),t}function rightPad(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function repeatedTry(e,t=e=>0,r,n){return new Promise((a,i)=>{let o=0,tryFn=()=>{if(e()){a();return}o++;let s=t(o);if(null!=r&&o>=r){i();return}null!=n?n(tryFn,s):setTimeout(tryFn,s)};tryFn()})}function inferFromImplicitShape(e,t){let r=1,n=-1;for(let t=0;t<e.length;++t)if(e[t]>=0)r*=e[t];else if(-1===e[t]){if(-1!==n)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${n} and dim ${t}`);n=t}else if(e[t]<0)throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);if(-1===n){if(t>0&&t!==r)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===r)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%r!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${r}`);let a=e.slice();return a[n]=t/r,a}function parseAxisParam(e,t){let r=t.length;return util_base_assert((e=null==e?t.map((e,t)=>t):[].concat(e)).every(e=>e>=-r&&e<r),()=>`All values in axis param must be in range [-${r}, ${r}) but got axis ${e}`),util_base_assert(e.every(e=>isInt(e)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(e=>e<0?r+e:e)}function squeezeShape(e,t){let r=[],n=[],a=null!=t&&Array.isArray(t)&&0===t.length,i=null==t||a?null:parseAxisParam(t,e).sort(),o=0;for(let t=0;t<e.length;++t){if(null!=i){if(i[o]===t&&1!==e[t])throw Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==i[o]||i[o]>t)&&1===e[t]&&(r.push(e[t]),n.push(t)),i[o]<=t&&o++}1!==e[t]&&(r.push(e[t]),n.push(t))}return{newShape:r,keptDims:n}}function getTypedArrayFromDType(e,t){return getArrayFromDType(e,t)}function getArrayFromDType(e,t){let r=null;if(null==e||"float32"===e)r=new Float32Array(t);else if("int32"===e)r=new Int32Array(t);else if("bool"===e)r=new Uint8Array(t);else if("string"===e)r=Array(t);else throw Error(`Unknown data type ${e}`);return r}function checkConversionForErrors(e,t){for(let r=0;r<e.length;r++){let n=e[r];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${t} being uploaded contains ${n}.`)}}function isValidDtype(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function hasEncodingLoss(e,t){return"complex64"!==t&&("float32"!==t||"complex64"===e)&&("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)}function bytesPerElement(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw Error(`Unknown dtype ${e}`)}function bytesFromStringArray(e){if(null==e)return 0;let t=0;return e.forEach(e=>t+=e.length),t}function isString(e){return"string"==typeof e||e instanceof String}function isBoolean(e){return"boolean"==typeof e}function isNumber(e){return"number"==typeof e}function inferDtype(e){if(Array.isArray(e))return inferDtype(e[0]);if(e instanceof Float32Array);else if(e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray)return"int32";else if(isNumber(e));else if(isString(e))return"string";else if(isBoolean(e))return"bool";return"float32"}function isFunction(e){return!!(e&&e.constructor&&e.call&&e.apply)}function nearestDivisor(e,t){for(let r=t;r<e;++r)if(e%r==0)return r;return e}function computeStrides(e){let t=e.length;if(t<2)return[];let r=Array(t-1);r[t-2]=e[t-1];for(let n=t-3;n>=0;--n)r[n]=r[n+1]*e[n+1];return r}function toNestedArray(e,t,r=!1){if(0===e.length)return t[0];let n=e.reduce((e,t)=>e*t)*(r?2:1);if(0===n)return[];if(n!==t.length)throw Error(`[${e}] does not match the input size ${t.length}${r?" for a complex tensor":""}.`);return function createNestedArray(e,t,r,n=!1){let a=[];if(1===t.length){let i=t[0]*(n?2:1);for(let t=0;t<i;t++)a[t]=r[e+t]}else{let i=t[0],o=t.slice(1),s=o.reduce((e,t)=>e*t)*(n?2:1);for(let t=0;t<i;t++)a[t]=createNestedArray(e+t*s,o,r,n)}return a}(0,e,t,r)}function convertBackendValuesAndArrayBuffer(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw Error(`Unknown dtype ${t}`)}function makeOnesTypedArray(e,t){let r=makeZerosTypedArray(e,t);for(let e=0;e<r.length;e++)r[e]=1;return r}function makeZerosTypedArray(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw Error(`Unknown data type ${t}`)}function makeZerosNestedTypedArray(e,t){let r=e.reduce((e,t)=>e*t,1);if(null==t||"float32"===t)return toNestedArray(e,new Float32Array(r));if("int32"===t)return toNestedArray(e,new Int32Array(r));if("bool"===t)return toNestedArray(e,new Uint8Array(r));throw Error(`Unknown data type ${t}`)}function assertNonNegativeIntegerDimensions(e){e.forEach(t=>{util_base_assert(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function locToIndex(e,t,r){if(0===t)return 0;if(1===t)return e[0];let n=e[e.length-1];for(let t=0;t<e.length-1;++t)n+=r[t]*e[t];return n}function indexToLoc(e,t,r){if(0===t)return[];if(1===t)return[e];let n=Array(t);for(let t=0;t<n.length-1;++t)n[t]=Math.floor(e/r[t]),e-=n[t]*r[t];return n[n.length-1]=e,n}function isPromise(e){return e&&e.then&&"function"==typeof e.then}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let $="tfjsflags";let Environment=class Environment{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=getQueryParams,this.populateURLFlags()}setPlatform(e,t){null==this.platform||T.getBool("IS_TEST")||T.getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=e,this.platform=t}registerFlag(e,t,r){if(this.flagRegistry[e]={evaluationFn:t,setHook:r},null!=this.urlFlags[e]){let t=this.urlFlags[e];T.getBool("IS_TEST")||T.getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(isPromise(t))throw Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;let e=this.getQueryParams(this.global.location.search);if($ in e){let t=e[$].split(",");t.forEach(e=>{let[t,r]=e.split(":");this.urlFlags[t]=function(e,t){let r=t.toLowerCase();return"true"===r||"false"===r?"true"===r:`${+r}`===r?+r:t}(0,r)})}}};function getQueryParams(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...r)=>{var n,a;return n=r[0],a=r[1],t[decodeURIComponent(n)]=decodeURIComponent(a||""),r.join("=")}),t}function environment_env(){return T}let T=null;var D=r(28070);function getGlobalNamespace(){if(null==n){let e;if("undefined"!=typeof window)e=window;else if(void 0!==r.g)e=r.g;else if(void 0!==D)e=D;else if("undefined"!=typeof self)e=self;else throw Error("Could not find a global object");n=e}return n}function getGlobal(e,t){let r=function(){let e=getGlobalNamespace();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(r.has(e))return r.get(e);{let n=t();return r.set(e,n),r.get(e)}}let A="Abs",P="Acos",_="Acosh",N="Add",F="AddN",O="All",B="Any",L="ArgMax",M="ArgMin",U="Asin",z="Asinh",W="Atan",V="Atanh",G="Atan2",H="AvgPool",K="AvgPoolGrad",j="AvgPool3D",X="AvgPool3DGrad",q="BatchMatMul",Y="BatchToSpaceND",Q="Bincount",Z="BitwiseAnd",J="BroadcastArgs",ee="Cast",et="Ceil",er="ClipByValue",en="Complex",ea="ComplexAbs",ei="Concat",eo="Conv2D",es="Conv2DBackpropFilter",eu="Conv2DBackpropInput",el="Conv3D",ed="Conv3DBackpropFilterV2",eh="Conv3DBackpropInputV2",ec="Cos",ep="Cosh",ef="Cumprod",em="Cumsum",eg="CropAndResize",ey="DenseBincount",ex="DepthToSpace",eb="DepthwiseConv2dNative",ev="DepthwiseConv2dNativeBackpropFilter",ew="DepthwiseConv2dNativeBackpropInput",eC="Diag",eS="Dilation2D",eI="Dilation2DBackpropInput",ek="Dilation2DBackpropFilter",eR="Draw",e$="RealDiv",eT="Einsum",eD="Elu",eE="EluGrad",eA="Erf",eP="Equal",e_="Exp",eN="ExpandDims",eF="Expm1",eO="FFT",eB="Fill",eL="FlipLeftRight",eM="Floor",eU="FloorDiv",ez="FusedBatchNorm",eW="GatherV2",eV="GatherNd",eG="Greater",eH="GreaterEqual",eK="Identity",ej="IFFT",eX="Imag",eq="IsFinite",eY="IsInf",eQ="IsNan",eZ="LeakyRelu",eJ="Less",e0="LessEqual",e1="LinSpace",e2="Log",e3="Log1p",e4="LogicalAnd",e5="LogicalNot",e6="LogicalOr",e8="LRN",e7="LRNGrad",e9="Max",te="Maximum",tt="MaxPool",tr="MaxPoolGrad",tn="MaxPool3D",ta="MaxPool3DGrad",ti="MaxPoolWithArgmax",to="Mean",ts="Min",tu="Minimum",tl="MirrorPad",td="Mod",th="Multinomial",tc="Multiply",tp="Neg",tf="NotEqual",tm="NonMaxSuppressionV3",tg="NonMaxSuppressionV4",ty="NonMaxSuppressionV5",tx="OnesLike",tb="OneHot",tv="Pack",tw="PadV2",tC="Pow",tS="Prelu",tI="Prod",tk="RaggedGather",tR="RaggedRange",t$="RaggedTensorToTensor",tT="Range",tD="Real",tE="Reciprocal",tA="Relu",tP="Reshape",t_="ResizeNearestNeighbor",tN="ResizeNearestNeighborGrad",tF="ResizeBilinear",tO="ResizeBilinearGrad",tB="Relu6",tL="Reverse",tM="Round",tU="Rsqrt",tz="ScatterNd",tW="TensorScatterUpdate",tV="SearchSorted",tG="Select",tH="Selu",tK="Slice",tj="Sin",tX="Sinh",tq="Sign",tY="Sigmoid",tQ="Softplus",tZ="Sqrt",tJ="Sum",t0="SpaceToBatchND",t1="SplitV",t2="Softmax",t3="SparseFillEmptyRows",t4="SparseReshape",t5="SparseSegmentMean",t6="SparseSegmentSum",t8="SparseToDense",t7="SquaredDifference",t9="Square",re="StaticRegexReplace",rt="StridedSlice",rr="StringNGrams",rn="StringSplit",ra="StringToHashBucketFast",ri="Sub",ro="Tan",rs="Tanh",ru="Tile",rl="TopK",rd="Transform",rh="Transpose",rc="Unique",rp="Unpack",rf="UnsortedSegmentSum",rm="ZerosLike",rg="Step",ry="FromPixels",rx="RotateWithOffset",rb="_FusedMatMul",rv="FusedConv2D",rw="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function warn(...e){T.getBool("IS_TEST")||T.getBool("PROD")||console.warn(...e)}function log_log(...e){T.getBool("IS_TEST")||T.getBool("PROD")||console.log(...e)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rC=getGlobal("kernelRegistry",()=>new Map),rS=getGlobal("gradRegistry",()=>new Map);function getKernel(e,t){let r=`${t}_${e}`;return rC.get(r)}function getKernelsForBackend(e){let t=rC.entries(),r=[];for(;;){let{done:n,value:a}=t.next();if(n)break;let[i,o]=a,[s]=i.split("_");s===e&&r.push(o)}return r}function registerKernel(e){let{kernelName:t,backendName:r}=e,n=`${r}_${t}`;rC.has(n)&&warn(`The kernel '${t}' for backend '${r}' is already registered`),rC.set(n,e)}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function isTypedArrayBrowser(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var rI=r(6017),rk=r.n(rI);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rR=rk()||rI;function hexToLong(e){return rR.fromString(e,!0,16)}let r$=hexToLong("c3a5c85c97cb3127"),rT=hexToLong("b492b66fbe98f273"),rD=hexToLong("9ae16a3b2f90404f");function shiftMix(e){return e.xor(e.shru(47))}function hash_util_fetch(e,t,r){let n=e.slice(t,t+r);return rR.fromBytes(Array.from(n),!0,!0)}function fetch64(e,t){return hash_util_fetch(e,t,8)}function rotate64(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function hashLen16(e,t,r=hexToLong("9ddfea08eb382d69")){let n=e.xor(t).mul(r);n=n.xor(n.shru(47));let a=t.xor(n).mul(r);return(a=a.xor(a.shru(47))).mul(r)}function weakHashLen32WithSeedsStr(e,t,r,n){return function(e,t,r,n,a,i){a=a.add(e),i=rotate64(i.add(a).add(n),21);let o=a;return a=(a=a.add(t)).add(r),i=i.add(rotate64(a,44)),[a.add(n),i.add(o)]}(fetch64(e,t),fetch64(e,t+8),fetch64(e,t+16),fetch64(e,t+24),r,n)}function fingerPrint64(e,t=e.length){let r=rR.fromNumber(81,!0);if(t<=32)return t<=16?function(e,t=e.length){if(t>=8){let r=rD.add(2*t),n=fetch64(e,0).add(rD),a=fetch64(e,t-8),i=rotate64(a,37).mul(r).add(n),o=rotate64(n,25).add(a).mul(r);return hashLen16(i,o,r)}if(t>=4){let r=rD.add(2*t),n=hash_util_fetch(e,0,4);return hashLen16(n.shl(3).add(t),hash_util_fetch(e,t-4,4),r)}if(t>0){let r=e[0],n=e[t>>1],a=e[t-1],i=t+(a<<2);return shiftMix(rD.mul(r+(n<<8)).xor(r$.mul(i))).mul(rD)}return rD}(e,t):function(e,t=e.length){let r=rD.add(2*t),n=fetch64(e,0).mul(rT),a=fetch64(e,8),i=fetch64(e,t-8).mul(r),o=fetch64(e,t-16).mul(rD);return hashLen16(rotate64(n.add(a),43).add(rotate64(i,30)).add(o),n.add(rotate64(a.add(rD),18)).add(i),r)}(e,t);if(t<=64)return function(e,t=e.length){let r=rD.add(2*t),n=fetch64(e,0).mul(rD),a=fetch64(e,8),i=fetch64(e,t-8).mul(r),o=fetch64(e,t-16).mul(rD),s=rotate64(n.add(a),43).add(rotate64(i,30)).add(o),u=hashLen16(s,n.add(rotate64(a.add(rD),18)).add(i),r),l=fetch64(e,16).mul(r),d=fetch64(e,24),h=s.add(fetch64(e,t-32)).mul(r),c=u.add(fetch64(e,t-24)).mul(r);return hashLen16(rotate64(l.add(d),43).add(rotate64(h,30)).add(c),l.add(rotate64(d.add(n),18)).add(h),r)}(e,t);let n=r,a=r.mul(rT).add(113),i=shiftMix(a.mul(rD).add(113)).mul(rD),o=[rR.UZERO,rR.UZERO],s=[rR.UZERO,rR.UZERO];n=n.mul(rD).add(fetch64(e,0));let u=0,l=(t-1>>6)*64,d=l+(t-1&63)-63;do n=rotate64(n.add(a).add(o[0]).add(fetch64(e,u+8)),37).mul(rT),a=rotate64(a.add(o[1]).add(fetch64(e,u+48)),42).mul(rT),n=n.xor(s[1]),a=a.add(o[0]).add(fetch64(e,u+40)),i=rotate64(i.add(s[0]),33).mul(rT),o=weakHashLen32WithSeedsStr(e,u,o[1].mul(rT),n.add(s[0])),s=weakHashLen32WithSeedsStr(e,u+32,i.add(s[1]),a.add(fetch64(e,u+16))),[i,n]=[n,i],u+=64;while(u!==l);let h=rT.add(i.and(255).shl(1));return u=d,s[0]=s[0].add(t-1&63),o[0]=o[0].add(s[0]),s[0]=s[0].add(o[0]),n=rotate64(n.add(a).add(o[0]).add(fetch64(e,u+8)),37).mul(h),a=rotate64(a.add(o[1]).add(fetch64(e,u+48)),42).mul(h),n=n.xor(s[1].mul(9)),a=a.add(o[0].mul(9).add(fetch64(e,u+40))),i=rotate64(i.add(s[0]),33).mul(h),o=weakHashLen32WithSeedsStr(e,u,o[1].mul(h),n.add(s[0])),s=weakHashLen32WithSeedsStr(e,u+32,i.add(s[1]),a.add(fetch64(e,u+16))),[i,n]=[n,i],hashLen16(hashLen16(o[0],s[0],h).add(shiftMix(a).mul(r$)).add(i),hashLen16(o[1],s[1],h).add(n),h)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function createScalarValue(e,t){return"string"===t?encodeString(e):toTypedArray([e],t)}function toTypedArray(e,t){var r;if("string"===t)throw Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=flatten(e)),T.getBool("DEBUG")&&checkConversionForErrors(e,t),(r=e)instanceof Float32Array&&"float32"===t||r instanceof Int32Array&&"int32"===t||r instanceof Uint8Array&&"bool"===t)return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){let t=new Uint8Array(e.length);for(let r=0;r<t.length;++r)0!==Math.round(e[r])&&(t[r]=1);return t}throw Error(`Unknown data type ${t}`)}function now(){return T.platform.now()}function util_fetch(e,t){return T.platform.fetch(e,t)}function encodeString(e,t="utf-8"){return t=t||"utf-8",T.platform.encode(e,t)}function decodeString(e,t="utf-8"){return t=t||"utf-8",T.platform.decode(e,t)}function isTypedArray(e){return null!=T.platform.isTypedArray?T.platform.isTypedArray(e):isTypedArrayBrowser(e)}function flatten(e,t=[],r=!1){if(null==t&&(t=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||isPromise(e)||null==e||isTypedArray(e)&&r)t.push(e);else if(Array.isArray(e)||isTypedArray(e))for(let n=0;n<e.length;++n)flatten(e[n],t,r);else{let n=-1;for(let t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(n=Math.max(n,Number(t)));for(let a=0;a<=n;a++)flatten(e[a],t,r)}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Profiler=class Profiler{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new Logger)}profileKernel(e,t,r){let n,a;let holdResultWrapperFn=()=>{n=r()},i=now();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(holdResultWrapperFn);else{for(let e of(holdResultWrapperFn(),n))e.dataSync();a=Promise.resolve({kernelMs:now()-i})}if(T.getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let t=0;t<n.length;t++){let r=n[t];r.data().then(t=>{!function(e,t,r){if("float32"===t)for(let t=0;t<e.length;t++){let n=e[t];if(isNaN(n)||!isFinite(n))return console.warn(`Found ${n} in the result of '${r}'`),!0}}(t,r.dtype,e)})}let o={kernelName:e,outputs:n,inputs:t,timeMs:a.then(e=>e.kernelMs),extraInfo:a.then(e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():"")};return o}logKernelProfile(e){let{kernelName:t,outputs:r,timeMs:n,inputs:a,extraInfo:i}=e;r.forEach(e=>{Promise.all([e.data(),n,i]).then(r=>{this.logger.logKernelProfile(t,e,r[0],r[1],a,r[2])})})}};let Logger=class Logger{logKernelProfile(e,t,r,n,a,i){let o="number"==typeof n?rightPad(`${n}ms`,9):n.error,s=rightPad(e,25),u=t.rank,l=t.size,d=rightPad(t.shape.toString(),14),h="";for(let e in a){let r=a[e];if(null!=r){let n=r.shape||t.shape,a=n.length;h+=`${e}: ${a}D ${a>0?n:""} `}}console.log(`%c${s}	%c${o}	%c${u}D ${d}	%c${l}	%c${h}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function valToString(e,t,r){return rightPad(Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:isString(e)?`'${e}'`:"bool"===r?boolNumToString(e):parseFloat(e.toFixed(7)).toString(),t)}function boolNumToString(e){return 0===e?"false":"true"}function createComplexTuples(e){let t=[];for(let r=0;r<e.length;r+=2)t.push([e[r],e[r+1]]);return t}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let TensorBuffer=class TensorBuffer{constructor(e,t,r){if(this.dtype=t,this.shape=e.slice(),this.size=util_base_sizeFromShape(e),null!=r){let e=r.length;util_base_assert(e===this.size,()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===t)throw Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||getArrayFromDType(t,this.size),this.strides=computeStrides(e)}set(e,...t){0===t.length&&(t=[0]),util_base_assert(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let r=this.locToIndex(t);this.values[r]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(let r of e){if(r<0||r>=this.shape[t]){let t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw Error(t)}t++}let r=e[e.length-1];for(let t=0;t<e.length-1;++t)r+=this.strides[t]*e[t];return this.values[r]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let r=0;r<e.length-1;++r)t+=this.strides[r]*e[r];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];let t=Array(this.shape.length);for(let r=0;r<t.length-1;++r)t[r]=Math.floor(e/this.strides[r]),e-=t[r]*this.strides[r];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return rE().makeTensor(this.values,this.shape,this.dtype)}};let rE=null,rA=null;let tensor_Tensor=class tensor_Tensor{constructor(e,t,r,n){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=util_base_sizeFromShape(e),this.strides=computeStrides(e),this.dataId=r,this.id=n,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return rA.buffer(this.shape,this.dtype,e)}bufferSync(){return rA.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return toNestedArray(this.shape,e,"complex64"===this.dtype)}arraySync(){return toNestedArray(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();let e=rE().read(this.dataId);if("string"===this.dtype){let t=await e;try{return t.map(e=>decodeString(e))}catch(e){throw Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),rE().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=rE().readSync(this.dataId);if("string"===this.dtype)try{return e.map(e=>decodeString(e))}catch(e){throw Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await rE().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),rE().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw Error("Tensor is disposed.")}print(e=!1){return rA.print(this,e)}clone(){return this.throwIfDisposed(),rA.clone(this)}toString(e=!1){let t=this.dataSync();return function(e,t,r,n){let a=computeStrides(t),i=function(e,t,r,n){let a=util_base_sizeFromShape(t),i=n[n.length-1],o=Array(i).fill(0),s=t.length,u="complex64"===r?createComplexTuples(e):e;if(s>1)for(let e=0;e<a/i;e++){let t=e*i;for(let e=0;e<i;e++)o[e]=Math.max(o[e],valToString(u[t+e],0,r).length)}return o}(e,t,r,a),o=t.length,s=function subTensorToString(e,t,r,n,a,i=!0){let o="complex64"===r?2:1,s=t[0],u=t.length;if(0===u){if("complex64"===r){let t=createComplexTuples(e);return[valToString(t[0],0,r)]}return"bool"===r?[boolNumToString(e[0])]:[e[0].toString()]}if(1===u){if(s>20){let t=3*o,n=Array.from(e.slice(0,t)),i=Array.from(e.slice((s-3)*o,s*o));return"complex64"===r&&(n=createComplexTuples(n),i=createComplexTuples(i)),["["+n.map((e,t)=>valToString(e,a[t],r)).join(", ")+", ..., "+i.map((e,t)=>valToString(e,a[s-3+t],r)).join(", ")+"]"]}let t="complex64"===r?createComplexTuples(e):Array.from(e);return["["+t.map((e,t)=>valToString(e,a[t],r)).join(", ")+"]"]}let l=t.slice(1),d=n.slice(1),h=n[0]*o,c=[];if(s>20){for(let t=0;t<3;t++){let n=t*h,i=n+h;c.push(...subTensorToString(e.slice(n,i),l,r,d,a,!1))}c.push("...");for(let t=s-3;t<s;t++){let n=t*h,i=n+h;c.push(...subTensorToString(e.slice(n,i),l,r,d,a,t===s-1))}}else for(let t=0;t<s;t++){let n=t*h,i=n+h;c.push(...subTensorToString(e.slice(n,i),l,r,d,a,t===s-1))}let p=2===u?",":"";c[0]="["+(s>0?c[0]+p:"");for(let e=1;e<c.length-1;e++)c[e]=" "+c[e]+p;let f=",\n";for(let e=2;e<u;e++)f+="\n";return c[c.length-1]=" "+c[c.length-1]+"]"+(i?"":f),c}(e,t,r,a,i),u=["Tensor"];return n&&(u.push(`  dtype: ${r}`),u.push(`  rank: ${o}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(s.map(e=>"    "+e).join("\n")),u.join("\n")}(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),rA.cast(this,e)}variable(e=!0,t,r){return this.throwIfDisposed(),rE().makeVariable(this,e,t,r)}};function getGlobalTensorClass(){return getGlobal("Tensor",()=>tensor_Tensor)}Object.defineProperty(tensor_Tensor,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),getGlobalTensorClass();let Variable=class Variable extends tensor_Tensor{constructor(e,t,r,n){super(e.shape,e.dtype,e.dataId,n),this.trainable=t,this.name=r}assign(e){if(e.dtype!==this.dtype)throw Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!arraysEqual(e.shape,this.shape))throw Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);rE().disposeTensor(this),this.dataId=e.dataId,rE().incRef(this,null)}dispose(){rE().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Variable,Symbol.hasInstance,{value:e=>e instanceof tensor_Tensor&&null!=e.assign&&e.assign instanceof Function}),(o=p||(p={})).R0="R0",o.R1="R1",o.R2="R2",o.R3="R3",o.R4="R4",o.R5="R5",o.R6="R6",(s=f||(f={})).float32="float32",s.int32="int32",s.bool="int32",s.complex64="complex64",(u=m||(m={})).float32="float32",u.int32="int32",u.bool="bool",u.complex64="complex64",(l=g||(g={})).float32="float32",l.int32="float32",l.bool="float32",l.complex64="complex64",(d=y||(y={})).float32="complex64",d.int32="complex64",d.bool="complex64",d.complex64="complex64";let rP={float32:g,int32:f,bool:m,complex64:y};function upcastType(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw Error(`Can not upcast ${e} with ${t}`)}return rP[e][t]}function sumOutType(e){return upcastType(e,"int32")}function isWebGLData(e){return null!=e&&"object"==typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function isWebGPUData(e){return"undefined"!=typeof GPUBuffer&&null!=e&&"object"==typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function makeTypesMatch(e,t){if(e.dtype===t.dtype)return[e,t];let r=upcastType(e.dtype,t.dtype);return[e.cast(r),t.cast(r)]}function getTensorsInContainer(e){let t=[],r=new Set;return function walkTensorContainer(e,t,r){if(null!=e){if(e instanceof tensor_Tensor){t.push(e);return}if(Array.isArray(e)||"object"==typeof e)for(let n in e){let a=e[n];r.has(a)||(r.add(a),walkTensorContainer(a,t,r))}}}(e,t,r),t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function isRegisteredKernelInvocation(e){return null!=e.kernelName}let EngineState=class EngineState{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}};let Engine=class Engine{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new EngineState}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let r=e[t],n=await this.initializeBackend(r).success;if(n){await this.setBackend(r);return}}throw Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{let{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,r=1){return e in this.registryFactory?(warn(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:r},!0)}async setBackend(e){if(null==this.registryFactory[e])throw Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;let{success:t,asyncInit:r}=this.initializeBackend(e),n=r?await t:t;if(!n)return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Profiler(this.backendInstance),!0}setupRegisteredKernels(){let e=getKernelsForBackend(this.backendName);e.forEach(e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){let t=getKernelsForBackend(e);t.forEach(t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])})}initializeBackend(e){let t=this.registryFactory[e];if(null==t)throw Error(`Cannot initialize backend ${e}, no registration found.`);try{let r=t.factory();if(!r||r instanceof KernelBackend||"function"!=typeof r.then)return this.registry[e]=r,{success:!0,asyncInit:!1};{let t=++this.pendingBackendInitId,n=r.then(r=>!(t<this.pendingBackendInitId)&&(this.registry[e]=r,this.pendingBackendInit=null,!0)).catch(r=>!(t<this.pendingBackendInitId)&&(this.pendingBackendInit=null,warn(`Initialization of backend ${e} failed`),warn(r.stack||r.message),!1));return this.pendingBackendInit=n,{success:n,asyncInit:!0}}}catch(t){return warn(`Initialization of backend ${e} failed`),warn(t.stack||t.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let r=e[t],{success:n,asyncInit:a}=this.initializeBackend(r);if(a||n)return{name:r,asyncInit:a}}throw Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let r=this.state.tensorInfo.get(t),n=r.backend,a=this.readSync(t),i=n.refCount(t);n.disposeData(t,!0),r.backend=e,e.move(t,a,r.shape,r.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let r,n=null;if(null==t){if("function"!=typeof e)throw Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=e}return this.scopedRun(()=>this.startScope(n),()=>this.endScope(r),()=>((r=t())instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,r){e();try{let e=r();return t(),e}catch(e){throw t(),e}}nextTensorId(){return Engine.nextTensorId++}nextVariableId(){return Engine.nextVariableId++}clone(e){let t=r_.runKernel(eK,{x:e});return this.addTapeNode(this.state.activeScope.name,{x:e},[t],e=>({x:()=>r_.runKernel(ee,{x:e},{dtype:"float32"})}),[],{}),t}runKernel(e,t,r){null==this.backendName&&this.backend;let n=null!=getKernel(e,this.backendName);if(!n)throw Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,r){let n=this.backend.numDataIds(),a=0;r.forEach(e=>{a+="complex64"===e.dtype?3:1});let i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=n-t-a-i;if(o>0)throw Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let t,r,n,a;let i=[],o=this.isTapeOn(),s=this.state.numBytes,u=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;let l=isRegisteredKernelInvocation(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(isRegisteredKernelInvocation(e)){let{kernelName:t,inputs:a,attrs:s}=e;null==this.backendName&&this.backend;let u=getKernel(t,this.backendName);util_base_assert(null!=u,()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`),r=()=>{let e=this.backend.numDataIds();n=u.kernelFunc({inputs:a,attrs:s,backend:this.backend});let r=Array.isArray(n)?n:[n];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,r);let l=r.map(e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e));if(o){let e=this.getTensorsForGradient(t,a,l);i=this.saveTensorsForBackwardMode(e)}return l}}else{let{forwardFunc:t}=e,saveFunc=e=>{o&&(i=e.map(e=>this.keep(this.clone(e))))};r=()=>{let e=this.backend.numDataIds();n=this.tidy(()=>t(this.backend,saveFunc));let r=Array.isArray(n)?n:[n];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,r),r}}let{inputs:d,attrs:h}=e,c=isRegisteredKernelInvocation(e)?null:e.backwardsFunc;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(a=this.profiler.profileKernel(l,d,()=>r()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(a),t=a.outputs):t=r()}),o&&this.addTapeNode(l,d,t,c,i,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-u,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(d).map(e=>null!=d[e]?d[e].shape:null),outputShapes:t.map(e=>e.shape),kernelTimeMs:a.timeMs,extraInfo:a.extraInfo}),Array.isArray(n)?t:t[0]}saveTensorsForBackwardMode(e){let t=e.map(e=>this.keep(this.clone(e)));return t}getTensorsForGradient(e,t,r){let n=rS.get(e);if(null!=n){let e;let a=n.inputsToSave||[],i=n.outputsToSave||[];n.saveAllInputs?(util_base_assert(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),e=Object.keys(t).map(e=>t[e])):e=a.map(e=>t[e]);let o=r.filter((e,t)=>i[t]);return e.concat(o)}return[]}makeTensor(e,t,r,n){if(null==e)throw Error("Values passed to engine.makeTensor() are null");r=r||"float32",n=n||this.backend;let a=e;"string"===r&&isString(e[0])&&(a=e.map(e=>encodeString(e)));let i=n.write(a,t,r),o=new tensor_Tensor(t,r,i,this.nextTensorId());if(this.trackTensor(o,n),"string"===r){let e=this.state.tensorInfo.get(i),t=bytesFromStringArray(a);this.state.numBytes+=t-e.bytes,e.bytes=t}return o}makeTensorFromDataId(e,t,r,n){r=r||"float32";let a={dataId:e,shape:t,dtype:r};return this.makeTensorFromTensorInfo(a,n)}makeTensorFromTensorInfo(e,t){let{dataId:r,shape:n,dtype:a}=e,i=new tensor_Tensor(n,a,r,this.nextTensorId());return this.trackTensor(i,t),i}makeVariable(e,t=!0,r,n){r=r||this.nextVariableId().toString(),null!=n&&n!==e.dtype&&(e=e.cast(n));let a=new Variable(e,t,r,this.nextTensorId());if(null!=this.state.registeredVariables[a.name])throw Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let r=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(r=e.size*bytesPerElement(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof Variable||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){let t=e.size*bytesPerElement(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,r=this.state.numTensors;for(let n of(this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(e=>e.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-r,this.state.activeProfile.kernels))n.kernelTimeMs=await n.kernelTimeMs,n.extraInfo=await n.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,r,n,a,i){let o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:r,saved:a},s=rS.get(e);null!=s&&(n=s.gradFunc),null!=n&&(o.gradient=e=>n((e=e.map((e,t)=>{if(null==e){let e=r[t],n=makeZerosTypedArray(e.size,e.dtype);return this.makeTensor(n,e.shape,e.dtype)}return e})).length>1?e:e[0],a,i)),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=getTensorsInContainer(e),r=new Set(t.map(e=>e.id));for(let e=0;e<this.state.activeScope.track.length;e++){let t=this.state.activeScope.track[e];t.kept||r.has(t.id)||t.dispose()}let n=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(e=>{e.kept||e.scopeId!==n.id||this.track(e)})}gradients(e,t,r,n=!1){if(util_base_assert(t.length>0,()=>"gradients() received an empty list of xs."),null!=r&&"float32"!==r.dtype)throw Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);let a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));util_base_assert(a instanceof tensor_Tensor,()=>"The result y returned by f() must be a tensor.");let i=/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t,r){let n={},a={};for(let e=0;e<t.length;e++)n[t[e].id]=!0;for(let r=0;r<e.length;r++){let i=e[r],o=i.inputs;for(let e in o){let r=o[e],s=!1;for(let e=0;e<t.length;e++)if(n[r.id]){i.outputs.forEach(e=>n[e.id]=!0),s=!0,a[i.id]=!0;break}if(s)break}}let i={};i[r.id]=!0;let o={};for(let t=e.length-1;t>=0;t--){let r=e[t],n=r.inputs;for(let e=0;e<r.outputs.length;e++)if(i[r.outputs[e].id]){for(let e in n)i[n[e].id]=!0,o[r.id]=!0;break}}let s=[];for(let t=0;t<e.length;t++){let r=e[t];if(a[r.id]&&o[r.id]){let e={};for(let t in r.inputs){let a=r.inputs[t];n[a.id]&&(e[t]=a)}let t=Object.assign({},r);t.inputs=e,t.outputs=r.outputs,s.push(t)}}return s}(this.state.activeTape,t,a);if(!n&&0===i.length&&t.length>0)throw Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let e={};e[a.id]=null==r?function(e){let t=makeOnesTypedArray(util_base_sizeFromShape(e),"float32");return r_.makeTensor(t,e,"float32")}(a.shape):r,function(e,t,r,n){for(let a=t.length-1;a>=0;a--){let i=t[a],o=[];if(i.outputs.forEach(t=>{let r=e[t.id];null!=r?o.push(r):o.push(null)}),null==i.gradient)throw Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);let s=i.gradient(o);for(let t in i.inputs){if(!(t in s))throw Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(s)}.`);let a=r(()=>s[t]());if("float32"!==a.dtype)throw Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${a.dtype}'`);let o=i.inputs[t];if(!arraysEqual(a.shape,o.shape))throw Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${t}' has shape '${a.shape}', which does not match the shape of the input '${o.shape}'`);if(null==e[o.id])e[o.id]=a;else{let t=e[o.id];e[o.id]=n(t,a),t.dispose()}}}}(e,i,e=>this.tidy(e),add);let n=t.map(t=>e[t.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(e=>{for(let t of e.saved)t.dispose()}),this.state.activeTape=null),{value:a,grads:n}})}customGrad(e){return util_base_assert(isFunction(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{let r;util_base_assert(t.every(e=>e instanceof tensor_Tensor),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n={};return t.forEach((e,t)=>{n[t]=e}),this.runKernelFunc({forwardFunc:(n,a)=>(util_base_assert((r=e(...[...t,a])).value instanceof tensor_Tensor,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),util_base_assert(isFunction(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),backwardsFunc:(e,n)=>{let a=r.gradFunc(e,n),i=Array.isArray(a)?a:[a];util_base_assert(i.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),util_base_assert(i.every(e=>e instanceof tensor_Tensor),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let o={};return i.forEach((e,t)=>{o[t]=()=>e}),o},inputs:n})}}readSync(e){let t=this.state.tensorInfo.get(e);return t.backend.readSync(e)}read(e){let t=this.state.tensorInfo.get(e);return t.backend.read(e)}readToGPU(e,t){let r=this.state.tensorInfo.get(e);return r.backend.readToGPU(e,t)}async time(e){let t=now(),r=await this.backend.time(e);return r.wallMs=now()-t,r}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){for(let e in this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new EngineState,this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};function getOrMakeEngine(){let e=getGlobalNamespace();if(null==e._tfengine){let t=new Environment(e);e._tfengine=new Engine(t)}return T=e._tfengine.ENV,rE=()=>e._tfengine,e._tfengine}Engine.nextTensorId=0,Engine.nextVariableId=0;let r_=getOrMakeEngine();function add(e,t){return r_.runKernel(N,{a:e,b:t})}function mockIsMobile(e){a=e}function isMobile(e){if(void 0!==a)return a;if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;let t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){let t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function isBrowser(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}var rN=r(28070);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rF=T;rF.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),rF.registerFlag("IS_BROWSER",()=>isBrowser()),rF.registerFlag("IS_NODE",()=>void 0!==rN&&void 0!==rN.versions&&void 0!==rN.versions.node),rF.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),rF.registerFlag("IS_SAFARI",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),rF.registerFlag("PROD",()=>!1),rF.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>rF.getBool("DEBUG")),rF.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),rF.registerFlag("IS_TEST",()=>!1),rF.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>rF.getBool("DEBUG")),rF.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),rF.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),rF.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);let composite_array_buffer_CompositeArrayBuffer=class composite_array_buffer_CompositeArrayBuffer{static join(e){return new composite_array_buffer_CompositeArrayBuffer(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e||(e instanceof Array||(e=[e]),0===(e=e.map(e=>isTypedArray(e)?e.buffer:e)).length))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let r=0;r<e.length;r++){let n=e[r];r!==e.length-1&&n.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let a=t+n.byteLength;this.shards.push({buffer:n,start:t,end:a}),t=a}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(0===this.shards.length||(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),(t=Math.min(this.byteLength,t))<=e))return new ArrayBuffer(0);let r=this.findShardForByte(e);if(-1===r)throw Error(`Could not find start shard for byte ${e}`);let n=t-e,a=new ArrayBuffer(n),i=new Uint8Array(a),o=0;for(let n=r;n<this.shards.length;n++){let r=this.shards[n],a=e+o,s=a-r.start,u=o,l=Math.min(t,r.end),d=l-r.start,h=new Uint8Array(r.buffer,s,d-s);if(i.set(h,u),o+=h.length,t<r.end)break}return a}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return -1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function check(t){return e<t.start?-1:e>=t.end?1:0}if(0===check(this.shards[this.previousShardIndex]))return this.previousShardIndex;let t=function(e,t){let r=0,n=e.length;for(;r<=n;){let a=Math.floor((n-r)/2)+r,i=t(e[a]);if(0===i)return a;i<0?n=a:r=a+1}return -1}(this.shards,check);return -1===t?-1:(this.previousShardIndex=t,this.previousShardIndex)}};var rO=r(61900).lW;let rB=void 0!==rO&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function stringByteLength(e){return rB?rO.byteLength(e,"utf8"):new Blob([e]).size}function getModelJSONForModelArtifacts(e,t){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),r}async function io_utils_getModelArtifactsForJSON(e,t){let r,n;return null!=e.weightsManifest&&([r,n]=await t(e.weightsManifest)),function(e,t,r){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw Error("modelJSON has weightsManifest but weightSpecs is null");if(!r)throw Error("modelJSON has weightsManifest but weightData is null");n.weightSpecs=t,n.weightData=r}return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),n}(e,r,n)}function getModelArtifactsInfoForJSON(e){if(e.modelTopology instanceof ArrayBuffer)throw Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:stringByteLength(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:stringByteLength(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new composite_array_buffer_CompositeArrayBuffer(e.weightData).byteLength}}function getWeightSpecs(e){let t=[];for(let r of e)t.push(...r.weights);return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let router_registry_IORouterRegistry=class router_registry_IORouterRegistry{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==router_registry_IORouterRegistry.instance&&(router_registry_IORouterRegistry.instance=new router_registry_IORouterRegistry),router_registry_IORouterRegistry.instance}static registerSaveRouter(e){router_registry_IORouterRegistry.getInstance().saveRouters.push(e)}static registerLoadRouter(e){router_registry_IORouterRegistry.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return router_registry_IORouterRegistry.getHandlers(e,"save")}static getLoadHandlers(e,t){return router_registry_IORouterRegistry.getHandlers(e,"load",t)}static getHandlers(e,t,r){let n=[],a="load"===t?router_registry_IORouterRegistry.getInstance().loadRouters:router_registry_IORouterRegistry.getInstance().saveRouters;return a.forEach(t=>{let a=t(e,r);null!==a&&n.push(a)}),n}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rL="tensorflowjs",rM="models_store",rU="model_info_store";function getIndexedDBFactory(){if(!T.getBool("IS_BROWSER"))throw Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw Error("The current browser does not appear to support IndexedDB.");return t}function setUpDatabase(e){let t=e.result;t.createObjectStore(rM,{keyPath:"modelPath"}),t.createObjectStore(rU,{keyPath:"modelPath"})}let BrowserIndexedDB=class BrowserIndexedDB{constructor(e){if(this.indexedDB=getIndexedDBFactory(),null==e||!e)throw Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((e,r)=>{let n=this.indexedDB.open(rL,1);n.onupgradeneeded=()=>setUpDatabase(n),n.onsuccess=()=>{let a=n.result;if(null==t){let t=a.transaction(rM,"readonly"),n=t.objectStore(rM),i=n.get(this.modelPath);i.onsuccess=()=>{if(null==i.result)return a.close(),r(Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(i.result.modelArtifacts)},i.onerror=e=>(a.close(),r(i.error)),t.oncomplete=()=>a.close()}else{let n,i;t.weightData=composite_array_buffer_CompositeArrayBuffer.join(t.weightData);let o=getModelArtifactsInfoForJSON(t),s=a.transaction(rU,"readwrite"),u=s.objectStore(rU);try{n=u.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(e){return r(e)}n.onsuccess=()=>{let n;i=a.transaction(rM,"readwrite");let l=i.objectStore(rM);try{n=l.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:o})}catch(e){return r(e)}n.onsuccess=()=>e({modelArtifactsInfo:o}),n.onerror=e=>{u=s.objectStore(rU);let t=u.delete(this.modelPath);t.onsuccess=()=>(a.close(),r(n.error)),t.onerror=e=>(a.close(),r(n.error))}},n.onerror=e=>(a.close(),r(n.error)),s.oncomplete=()=>{null==i?a.close():i.oncomplete=()=>a.close()}}},n.onerror=e=>r(n.error)})}};BrowserIndexedDB.URL_SCHEME="indexeddb://";let indexedDBRouter=e=>{var t;return T.getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(BrowserIndexedDB.URL_SCHEME)?(t=e.slice(BrowserIndexedDB.URL_SCHEME.length),new BrowserIndexedDB(t)):null};router_registry_IORouterRegistry.registerSaveRouter(indexedDBRouter),router_registry_IORouterRegistry.registerLoadRouter(indexedDBRouter);let rz="tensorflowjs_models",rW="info";function getModelKeys(e){return{info:[rz,e,rW].join("/"),topology:[rz,e,"model_topology"].join("/"),weightSpecs:[rz,e,"weight_specs"].join("/"),weightData:[rz,e,"weight_data"].join("/"),modelMetadata:[rz,e,"model_metadata"].join("/")}}function removeItems(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}let BrowserLocalStorage=class BrowserLocalStorage{constructor(e){if(!T.getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=getModelKeys(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),n=getModelArtifactsInfoForJSON(e),a=composite_array_buffer_CompositeArrayBuffer.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(n)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,function(e){if(rB)return rO.from(e).toString("base64");let t=new Uint8Array(e),r="";for(let e=0,n=t.length;e<n;e++)r+=String.fromCharCode(t[e]);return btoa(r)}(a));let i={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:n}}catch(e){throw removeItems(this.keys),Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${n.modelTopologyBytes}, weightSpecsBytes=${n.weightSpecsBytes}, weightDataBytes=${n.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(null==r)throw Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=r;let n=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==n)throw Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=n;let a=this.LS.getItem(this.keys.modelMetadata);if(null!=a){let e=JSON.parse(a);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}let i=this.LS.getItem(this.keys.weightData);if(null==i)throw Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(rB){let t=rO.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}let t=atob(e),r=new Uint8Array(t.length);for(let e=0;e<t.length;++e)r.set([t.charCodeAt(e)],e);return r.buffer}(i),t}};BrowserLocalStorage.URL_SCHEME="localstorage://";let localStorageRouter=e=>{var t;return T.getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(BrowserLocalStorage.URL_SCHEME)?(t=e.slice(BrowserLocalStorage.URL_SCHEME.length),new BrowserLocalStorage(t)):null};router_registry_IORouterRegistry.registerSaveRouter(localStorageRouter),router_registry_IORouterRegistry.registerLoadRouter(localStorageRouter);let ModelStoreManagerRegistry=class ModelStoreManagerRegistry{constructor(){this.managers={}}static getInstance(){return null==ModelStoreManagerRegistry.instance&&(ModelStoreManagerRegistry.instance=new ModelStoreManagerRegistry),ModelStoreManagerRegistry.instance}static registerManager(e,t){util_base_assert(null!=e,()=>"scheme must not be undefined or null."),e.endsWith("://")&&(e=e.slice(0,e.indexOf("://"))),util_base_assert(e.length>0,()=>"scheme must not be an empty string.");let r=ModelStoreManagerRegistry.getInstance();util_base_assert(null==r.managers[e],()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=t}static getManager(e){let t=ModelStoreManagerRegistry.getInstance().managers[e];if(null==t)throw Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(ModelStoreManagerRegistry.getInstance().managers)}};if(T.get("IS_BROWSER")){T.setPlatform("browser",new /**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if("undefined"==typeof window||!T.getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();let t=this.functionRefs[e.data.index];t(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return isTypedArrayBrowser(e)}});try{ModelStoreManagerRegistry.registerManager(BrowserLocalStorage.URL_SCHEME,new class{constructor(){util_base_assert(T.getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),util_base_assert("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=rz+"/",r="/"+rW;for(let n=0;n<this.LS.length;++n){let a=this.LS.key(n);if(a.startsWith(t)&&a.endsWith(r)){let t=function(e){let t=e.split("/");if(t.length<3)throw Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join("/")}(a);e[t]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){var t;e=(t=e).startsWith(BrowserLocalStorage.URL_SCHEME)?t.slice(BrowserLocalStorage.URL_SCHEME.length):t;let r=getModelKeys(e);if(null==this.LS.getItem(r.info))throw Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(r.info));return removeItems(r),n}})}catch(e){}try{ModelStoreManagerRegistry.registerManager(BrowserIndexedDB.URL_SCHEME,new class{constructor(){this.indexedDB=getIndexedDBFactory()}async listModels(){return new Promise((e,t)=>{let r=this.indexedDB.open(rL,1);r.onupgradeneeded=()=>setUpDatabase(r),r.onsuccess=()=>{let n=r.result,a=n.transaction(rU,"readonly"),i=a.objectStore(rU),o=i.getAll();o.onsuccess=()=>{let t={};for(let e of o.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},o.onerror=e=>(n.close(),t(o.error)),a.oncomplete=()=>n.close()},r.onerror=e=>t(r.error)})}async removeModel(e){var t;return e=(t=e).startsWith(BrowserIndexedDB.URL_SCHEME)?t.slice(BrowserIndexedDB.URL_SCHEME.length):t,new Promise((t,r)=>{let n=this.indexedDB.open(rL,1);n.onupgradeneeded=()=>setUpDatabase(n),n.onsuccess=()=>{let a;let i=n.result,o=i.transaction(rU,"readwrite"),s=o.objectStore(rU),u=s.get(e);u.onsuccess=()=>{if(null==u.result)return i.close(),r(Error(`Cannot find model with path '${e}' in IndexedDB.`));{let n=s.delete(e),deleteModelData=()=>{a=i.transaction(rM,"readwrite");let n=a.objectStore(rM),o=n.delete(e);o.onsuccess=()=>t(u.result.modelArtifactsInfo),o.onerror=e=>r(u.error)};n.onsuccess=deleteModelData,n.onerror=e=>(deleteModelData(),i.close(),r(u.error))}},u.onerror=e=>(i.close(),r(u.error)),o.oncomplete=()=>{null==a?i.close():a.oncomplete=()=>i.close()}},n.onerror=e=>r(n.error)})}})}catch(e){}}var rV=r(28070);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let rG={importFetch:()=>r(4112)};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function buffer(e,t="float32",r){return t=t||"float32",assertNonNegativeIntegerDimensions(e),new TensorBuffer(e,t,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function inferShape(e,t){let r=e;if(isTypedArray(e))return"string"===t?[]:[e.length];if(isWebGLData(e)){let t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(isWebGPUData(e))return[e.buffer.size/(null==t?4:bytesPerElement(t))];if(!Array.isArray(e))return[];let n=[];for(;Array.isArray(r)||isTypedArray(r)&&"string"!==t;)n.push(r.length),r=r[0];return Array.isArray(e)&&T.getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&function deepAssertShapeConsistency(e,t,r){if(r=r||[],!Array.isArray(e)&&!isTypedArray(e)){util_base_assert(0===t.length,()=>`Element arr[${r.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}util_base_assert(t.length>0,()=>`Element arr[${r.join("][")}] should be a primitive, but is an array of ${e.length} elements`),util_base_assert(e.length===t[0],()=>`Element arr[${r.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);let n=t.slice(1);for(let t=0;t<e.length;++t)deepAssertShapeConsistency(e[t],n,r.concat(t))}(e,n,[]),n}function assertDtype(e,t,r,n){if("string_or_numeric"!==e){if(null==e)throw Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw Error(`Argument '${r}' passed to '${n}' must be ${e} tensor, but got ${t} tensor`)}}function tensor_util_env_convertToTensor(e,t,r,n="numeric"){if(e instanceof getGlobalTensorClass())return assertDtype(n,e.dtype,t,r),e;let a=inferDtype(e);if("string"!==a&&["bool","int32","float32"].indexOf(n)>=0&&(a=n),assertDtype(n,a,t,r),null==e||!isTypedArray(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){let n=null==e?"null":e.constructor.name;throw Error(`Argument '${t}' passed to '${r}' must be a Tensor or TensorLike, but got '${n}'`)}let i=inferShape(e,a);isTypedArray(e)||Array.isArray(e)||(e=[e]);let o="string"!==a?toTypedArray(e,a):flatten(e,[],!0);return r_.makeTensor(o,i,a)}function op(e){let t=Object.keys(e);if(1!==t.length)throw Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let r=t[0],n=e[r];r.endsWith("_")&&(r=r.substring(0,r.length-1)),r+="__op";let f2=(...e)=>{r_.startScope(r);try{let t=n(...e);return isPromise(t)&&console.error("Cannot return a Promise inside of tidy."),r_.endScope(t),t}catch(e){throw r_.endScope(null),e}};return Object.defineProperty(f2,"name",{value:r,configurable:!0}),f2}T.get("IS_NODE")&&!T.get("IS_BROWSER")&&T.setPlatform("node",new class{constructor(){this.util=r(23062),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=T.global.fetch?T.global.fetch(e,t):(null==i&&(i=rG.importFetch()),i(e,t))}now(){let e=rV.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}});let rH=op({cast_:/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t){let r=tensor_util_env_convertToTensor(e,"x","cast");if(!isValidDtype(t))throw Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==r.dtype||"string"!==t&&"string"===r.dtype)throw Error("Only strings can be casted to strings");return r_.runKernel(ee,{x:r},{dtype:t})}}),rK=op({clone_:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t=tensor_util_env_convertToTensor(e,"x","clone","string_or_numeric");return r_.runKernel(eK,{x:t})}});function engine(){return r_}function tidy(e,t){return r_.tidy(e,t)}function dispose(e){let t=getTensorsInContainer(e);t.forEach(e=>e.dispose())}function setBackend(e){return r_.setBackend(e)}function registerBackend(e,t,r=1){return r_.registerBackend(e,t,r)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */getOrMakeEngine(),rA={buffer:buffer,cast:rH,clone:rK,print:/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t=!1){console.log(e.toString(t))}};let rj=op({add_:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t){let r=tensor_util_env_convertToTensor(e,"a","add"),n=tensor_util_env_convertToTensor(t,"b","add");[r,n]=makeTypesMatch(r,n);let a={a:r,b:n};return r_.runKernel(N,a)}}),rX=op({floorDiv_:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t){let r=tensor_util_env_convertToTensor(e,"a","floorDiv"),n=tensor_util_env_convertToTensor(t,"b","floorDiv");[r,n]=makeTypesMatch(r,n);let a={a:r,b:n};return r_.runKernel(eU,a)}}),rq=op({div_:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t){let r=tensor_util_env_convertToTensor(e,"a","div"),n=tensor_util_env_convertToTensor(t,"b","div");if([r,n]=makeTypesMatch(r,n),"int32"===r.dtype&&"int32"===n.dtype)return rX(r,n);let a={a:r,b:n};return r_.runKernel(e$,a,{})}}),rY=op({mul_:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t){let r=tensor_util_env_convertToTensor(e,"a","mul"),n=tensor_util_env_convertToTensor(t,"b","mul");[r,n]=makeTypesMatch(r,n);let a={a:r,b:n};return r_.runKernel(tc,a)}}),rQ=op({sqrt_:/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t=tensor_util_env_convertToTensor(e,"x","sqrt","float32");return r_.runKernel(tZ,{x:t})}}),rZ=op({square_:/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t=tensor_util_env_convertToTensor(e,"x","square");return r_.runKernel("Square",{x:t},{})}}),rJ=op({zerosLike_:/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t=tensor_util_env_convertToTensor(e,"x","zerosLike");return r_.runKernel(rm,{x:t})}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function makeTensor(e,t,r,n){if(null==n)n=inferDtype(e);else if("complex64"===n)throw Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(isWebGPUData(e)||isWebGLData(e)){if("float32"!==n&&"int32"!==n)throw Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${n}.`);return r_.backend.createTensorFromGPUData(e,t||r,n)}if(!isTypedArray(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){assertNonNegativeIntegerDimensions(t);let e=util_base_sizeFromShape(t),n=util_base_sizeFromShape(r);util_base_assert(e===n,()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${n}`);for(let e=0;e<r.length;++e){let n=r[e],a=e!==r.length-1||n!==util_base_sizeFromShape(t.slice(e));util_base_assert(r[e]===t[e]||!a,()=>`Error creating a new Tensor. Inferred shape (${r}) does not match the provided shape (${t}). `)}}return isTypedArray(e)||Array.isArray(e)||(e=[e]),t=t||r,e="string"!==n?toTypedArray(e,n):flatten(e,[],!0),r_.makeTensor(e,t,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function scalar(e,t){if((isTypedArray(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&isTypedArray(e)&&!(e instanceof Uint8Array))throw Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return makeTensor(e,[],[],t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let r0=new Map,r1=new Map;let Serializable=class Serializable{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}};let SerializationMap=class SerializationMap{constructor(){this.classNameMap={}}static getMap(){return null==SerializationMap.instance&&(SerializationMap.instance=new SerializationMap),SerializationMap.instance}static register(e){SerializationMap.getMap().classNameMap[e.className]=[e,e.fromConfig]}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Optimizer=class Optimizer extends Serializable{minimize(e,t=!1,r){let{value:n,grads:a}=this.computeGradients(e,r);if(null!=r){let e=r.map(e=>({name:e.name,tensor:a[e.name]}));this.applyGradients(e)}else this.applyGradients(a);return(dispose(a),t)?n:(n.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){util_base_assert(isFunction(e),()=>"The f passed in variableGrads(f) must be a function"),util_base_assert(null==t||Array.isArray(t)&&t.every(e=>e instanceof Variable),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let r=null!=t;if(!r)for(let e in t=[],r_.registeredVariables)t.push(r_.registeredVariables[e]);let n=r?t.filter(e=>!e.trainable):null,a=t.length;util_base_assert((t=t.filter(e=>e.trainable)).length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`);let{value:i,grads:o}=r_.gradients(e,t,null,!0);util_base_assert(o.some(e=>null!=e),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),util_base_assert(0===i.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let s={};return t.forEach((e,t)=>{null!=o[t]&&(s[e.name]=o[t])}),null!=n&&n.forEach(e=>s[e.name]=null),{value:i,grads:s}}(e,t)}dispose(){null!=this.iterations_&&dispose(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:scalar(this.iterations_,"int32")}}async getWeights(){throw Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fill(e,t,r){assertNonNegativeIntegerDimensions(e),r=r||inferDtype(t);let n={shape:e,value:t,dtype:r};return r_.runKernel(eB,{},n)}Object.defineProperty(Optimizer,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});let r2=op({pow_:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t){let r=tensor_util_env_convertToTensor(e,"base","pow"),n=tensor_util_env_convertToTensor(t,"exp","pow");[r,n]=makeTypesMatch(r,n);let a={a:r,b:n};return r_.runKernel(tC,a)}}),r3=op({sub_:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t){let r=tensor_util_env_convertToTensor(e,"a","sub"),n=tensor_util_env_convertToTensor(t,"b","sub");[r,n]=makeTypesMatch(r,n);let a={a:r,b:n};return r_.runKernel(ri,a)}}),r4=op({abs_:/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t=tensor_util_env_convertToTensor(e,"x","abs");return"complex64"===t.dtype?r_.runKernel(ea,{x:t}):r_.runKernel(A,{x:t})}});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getBroadcastDims(e,t){let r=e.length,n=[];for(let a=0;a<r;a++){let i=r-1-a,o=e[i]||1,s=t[t.length-1-a]||1;s>1&&1===o&&n.unshift(i)}return n}function getReductionAxes(e,t){let r=[];for(let n=0;n<t.length;n++){let a=e[e.length-n-1],i=t.length-n-1,o=t[i];(null==a||1===a&&o>1)&&r.unshift(i)}return r}function assertAndGetBroadcastShape(e,t){let r=Math.max(e.length,t.length),n=Array(r);for(let a=0;a<r;a++){let i=e[e.length-a-1];null==i&&(i=1);let o=t[t.length-a-1];if(null==o&&(o=1),1===i)n[r-a-1]=o;else if(1===o)n[r-a-1]=i;else if(i!==o){let r=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(r)}else n[r-a-1]=i}return n}let r5=op({maximum_:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t){let r=tensor_util_env_convertToTensor(e,"a","maximum"),n=tensor_util_env_convertToTensor(t,"b","maximum");[r,n]=makeTypesMatch(r,n),"bool"===r.dtype&&(r=rH(r,"int32"),n=rH(n,"int32")),assertAndGetBroadcastShape(r.shape,n.shape);let a={a:r,b:n};return r_.runKernel(te,a)}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let SGDOptimizer=class SGDOptimizer extends Optimizer{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){let t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);t.forEach((t,r)=>{let n=Array.isArray(e)?e[r].tensor:e[t];if(null==n)return;let a=r_.registeredVariables[t];tidy(()=>{let e=rj(rY(this.c,n),a);a.assign(e)})}),this.incrementIterations()}setLearningRate(e){var t;this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=(t=scalar(-e),r_.keep(t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let r6=[/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class extends Optimizer{static get className(){return"Adadelta"}constructor(e,t,r=null){super(),this.learningRate=e,this.rho=t,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==r&&(this.epsilon=r_.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);t.forEach((t,r)=>{let n=r_.registeredVariables[t];null==this.accumulatedGrads[r]&&(this.accumulatedGrads[r]={originalName:`${t}/accum_grad`,variable:tidy(()=>rJ(n).variable(!1))}),null==this.accumulatedUpdates[r]&&(this.accumulatedUpdates[r]={originalName:`${t}/accum_var`,variable:tidy(()=>rJ(n).variable(!1))});let a=Array.isArray(e)?e[r].tensor:e[t];if(null==a)return;let i=this.accumulatedGrads[r].variable,o=this.accumulatedUpdates[r].variable;tidy(()=>{let e=rj(rY(i,this.rho),rY(rZ(a),1-this.rho)),t=rY(rq(rQ(rj(o,this.epsilon)),rQ(rj(i,this.epsilon))),a),r=rj(rY(o,this.rho),rY(rZ(t),1-this.rho));i.assign(e),o.assign(r);let s=rj(rY(t,-this.learningRate),n);n.assign(s)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(dispose(this.accumulatedGrads.map(e=>e.variable)),dispose(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2;this.accumulatedGrads=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedUpdates=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class extends Optimizer{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){let t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);t.forEach((t,r)=>{let n=r_.registeredVariables[t];null==this.accumulatedGrads[r]&&(this.accumulatedGrads[r]={originalName:`${t}/accumulator`,variable:tidy(()=>fill(n.shape,this.initialAccumulatorValue).variable(!1))});let a=Array.isArray(e)?e[r].tensor:e[t];if(null==a)return;let i=this.accumulatedGrads[r].variable;tidy(()=>{let e=rj(i,rZ(a));i.assign(e);let t=rj(rY(rq(a,rQ(rj(e,r_.backend.epsilon()))),-this.learningRate),n);n.assign(t)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&dispose(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),this.accumulatedGrads=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class extends Optimizer{static get className(){return"Adam"}constructor(e,t,r,n=null){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=n,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],tidy(()=>{this.accBeta1=scalar(t).variable(),this.accBeta2=scalar(r).variable()}),null==n&&(this.epsilon=r_.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);tidy(()=>{let r=r3(1,this.accBeta1),n=r3(1,this.accBeta2);t.forEach((t,a)=>{let i=r_.registeredVariables[t];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:tidy(()=>rJ(i).variable(!1))}),null==this.accumulatedSecondMoment[a]&&(this.accumulatedSecondMoment[a]={originalName:`${t}/v`,variable:tidy(()=>rJ(i).variable(!1))});let o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;let s=this.accumulatedFirstMoment[a].variable,u=this.accumulatedSecondMoment[a].variable,l=rj(rY(s,this.beta1),rY(o,1-this.beta1)),d=rj(rY(u,this.beta2),rY(rZ(o),1-this.beta2)),h=rq(l,r),c=rq(d,n);s.assign(l),u.assign(d);let p=rj(rY(rq(h,rj(rQ(c),this.epsilon)),-this.learningRate),i);i.assign(p)}),this.accBeta1.assign(rY(this.accBeta1,this.beta1)),this.accBeta2.assign(rY(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&dispose(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedSecondMoment&&dispose(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),tidy(()=>{this.accBeta1.assign(r2(this.beta1,this.iterations_+1)),this.accBeta2.assign(r2(this.beta2,this.iterations_+1))});let t=e.length/2;this.accumulatedFirstMoment=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedSecondMoment=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class extends Optimizer{static get className(){return"Adamax"}constructor(e,t,r,n=null,a=0){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=n,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],tidy(()=>{this.iteration=scalar(0).variable(),this.accBeta1=scalar(t).variable()}),null==n&&(this.epsilon=r_.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);tidy(()=>{let r=r3(1,this.accBeta1),n=rq(-this.learningRate,rj(rY(this.iteration,this.decay),1));t.forEach((t,a)=>{let i=r_.registeredVariables[t];null==this.accumulatedFirstMoment[a]&&(this.accumulatedFirstMoment[a]={originalName:`${t}/m`,variable:rJ(i).variable(!1)}),null==this.accumulatedWeightedInfNorm[a]&&(this.accumulatedWeightedInfNorm[a]={originalName:`${t}/v`,variable:rJ(i).variable(!1)});let o=Array.isArray(e)?e[a].tensor:e[t];if(null==o)return;let s=this.accumulatedFirstMoment[a].variable,u=this.accumulatedWeightedInfNorm[a].variable,l=rj(rY(s,this.beta1),rY(o,1-this.beta1)),d=rY(u,this.beta2),h=r4(o),c=r5(d,h);s.assign(l),u.assign(c);let p=rj(rY(rq(n,r),rq(l,rj(c,this.epsilon))),i);i.assign(p)}),this.iteration.assign(rj(this.iteration,1)),this.accBeta1.assign(rY(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&dispose(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedWeightedInfNorm&&dispose(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class extends SGDOptimizer{static get className(){return"Momentum"}constructor(e,t,r=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=r,this.accumulations=[],this.m=scalar(this.momentum)}applyGradients(e){let t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);t.forEach((t,r)=>{let n=r_.registeredVariables[t];null==this.accumulations[r]&&(this.accumulations[r]={originalName:`${t}/momentum`,variable:tidy(()=>rJ(n).variable(!1))});let a=this.accumulations[r].variable,i=Array.isArray(e)?e[r].tensor:e[t];null!=i&&tidy(()=>{let e;let t=rj(rY(this.m,a),i);e=this.useNesterov?rj(rY(this.c,rj(i,rY(t,this.m))),n):rj(rY(this.c,t),n),a.assign(t),n.assign(e)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&dispose(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),this.accumulations=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class extends Optimizer{static get className(){return"RMSProp"}constructor(e,t=.9,r=0,n=null,a=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=r,this.epsilon=n,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,null==n&&(this.epsilon=r_.backend.epsilon()),null==e)throw Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){let t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);t.forEach((t,r)=>{let n=r_.registeredVariables[t];null==this.accumulatedMeanSquares[r]&&(this.accumulatedMeanSquares[r]={originalName:`${t}/rms`,variable:tidy(()=>rJ(n).variable(!1))}),null==this.accumulatedMoments[r]&&(this.accumulatedMoments[r]={originalName:`${t}/momentum`,variable:tidy(()=>rJ(n).variable(!1))}),null==this.accumulatedMeanGrads[r]&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${t}/mg`,variable:tidy(()=>rJ(n).variable(!1))});let a=Array.isArray(e)?e[r].tensor:e[t];if(null==a)return;let i=this.accumulatedMeanSquares[r].variable,o=this.accumulatedMoments[r].variable;tidy(()=>{let e=rj(rY(i,this.decay),rY(rZ(a),1-this.decay));if(this.centered){let t=this.accumulatedMeanGrads[r].variable,s=rj(rY(t,this.decay),rY(a,1-this.decay)),u=rq(rY(a,this.learningRate),rQ(r3(e,rj(rZ(s),this.epsilon)))),l=rj(rY(o,this.momentum),u);i.assign(e),t.assign(s),o.assign(l);let d=r3(n,l);n.assign(d)}else{let e=rj(rY(i,this.decay),rY(rZ(a),1-this.decay)),t=rj(rY(o,this.momentum),rq(rY(a,this.learningRate),rQ(rj(e,this.epsilon))));i.assign(e),o.assign(t);let r=r3(n,t);n.assign(r)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&dispose(this.accumulatedMeanSquares.map(e=>e.variable)),null!=this.accumulatedMeanGrads&&this.centered&&dispose(this.accumulatedMeanGrads.map(e=>e.variable)),null!=this.accumulatedMoments&&dispose(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2;this.accumulatedMeanSquares=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.accumulatedMoments=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map(e=>({originalName:e.name,variable:e.tensor.variable(!1)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},SGDOptimizer];function defer(e){return new Promise(e=>setTimeout(e)).then(e)}let BrowserDownloads=class BrowserDownloads{constructor(e){if(!T.getBool("IS_BROWSER"))throw Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(BrowserDownloads.URL_SCHEME)&&(e=e.slice(BrowserDownloads.URL_SCHEME.length)),(null==e||0===e.length)&&(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"==typeof document)throw Error("Browser downloads are not supported in this environment since `document` is not present");let t=composite_array_buffer_CompositeArrayBuffer.join(e.weightData),r=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let t=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],n=getModelJSONForModelArtifacts(e,t),a=window.URL.createObjectURL(new Blob([JSON.stringify(n)],{type:"application/json"})),i=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(i.download=this.modelJsonFileName,i.href=a,await defer(()=>i.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){let e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=r,await defer(()=>e.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:getModelArtifactsInfoForJSON(e)}}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function monitorPromisesProgress(e,t,r,n){var a,i;util_base_assert(null!=e&&Array.isArray(e)&&e.length>0,()=>"promises must be a none empty array"),a=r=null==r?0:r,i=n=null==n?1:n,util_base_assert(a>=0&&a<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${a}`),util_base_assert(i>=0&&i<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${i}`),util_base_assert(i>=a,()=>`startFraction must be no more than endFraction, but got startFraction ${a} and endFraction ${i}`);let o=0;return Promise.all(e.map(a=>(a.then(a=>{let i=r+ ++o/e.length*(n-r);return t(i),a}),a)))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function loadWeightsAsArrayBuffer(e,t){null==t&&(t={});let r=null==t.fetchFunc?T.platform.fetch:t.fetchFunc,n=e.map(e=>r(e,t.requestInit,{isBinary:!0})),a=null==t.onProgress?await Promise.all(n):await monitorPromisesProgress(n,t.onProgress,0,.5),i=a.map(e=>e.arrayBuffer()),o=null==t.onProgress?await Promise.all(i):await monitorPromisesProgress(i,t.onProgress,.5,1);return o}BrowserDownloads.URL_SCHEME="downloads://",router_registry_IORouterRegistry.registerSaveRouter(e=>T.getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(BrowserDownloads.URL_SCHEME)?function(e="model"){return new BrowserDownloads(e)}(e.slice(BrowserDownloads.URL_SCHEME.length)):null);let HTTPRequest=class HTTPRequest{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(util_base_assert("function"==typeof t.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=T.platform.fetch,util_base_assert(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&util_base_assert(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],n=getModelJSONForModelArtifacts(e,r);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){let r=composite_array_buffer_CompositeArrayBuffer.join(e.weightData);t.body.append("model.weights.bin",new Blob([r],{type:"application/octet-stream"}),"model.weights.bin")}let a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:getModelArtifactsInfoForJSON(e),responses:[a]};throw Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async loadModelJSON(){let e;let t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);try{e=await t.json()}catch(t){let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",Error(e)}let r=e.modelTopology,n=e.weightsManifest;if(null==r&&null==n)throw Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return e}async load(){if(this.loadOptions.streamWeights)return this.loadStream();let e=await this.loadModelJSON();return io_utils_getModelArtifactsForJSON(e,e=>this.loadWeights(e))}async loadStream(){let e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),r=getWeightSpecs(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:r,getWeightStream:()=>(function(e,t){var r;let n;let a=null==t.fetchFunc?T.platform.fetch:t.fetchFunc,i=0;return null===(r=t.onProgress)||void 0===r||r.call(t,0),new ReadableStream({pull:async r=>{for(var o;i<e.length;){if(!n){let r=(await a(e[i],t.requestInit,{isBinary:!0})).body;n=r.getReader()}let{done:s,value:u}=await n.read();if(s){i++,n=void 0,null===(o=t.onProgress)||void 0===o||o.call(t,i/e.length);continue}r.enqueue(u);return}r.close()}})})(t,this.loadOptions)})}async getWeightUrls(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[r,n]=function(e){let t=e.lastIndexOf("/"),r=e.lastIndexOf("?"),n=e.substring(0,t),a=r>t?e.substring(r):"";return[n+"/",a]}(t),a=this.weightPathPrefix||r,i=[],o=[];for(let t of e)for(let e of t.paths)null!=this.weightUrlConverter?o.push(this.weightUrlConverter(e)):i.push(a+e+n);return this.weightUrlConverter&&i.push(...await Promise.all(o)),i}async loadWeights(e){let t=await this.getWeightUrls(e),r=getWeightSpecs(e),n=await loadWeightsAsArrayBuffer(t,this.loadOptions);return[r,n]}};function isHTTPScheme(e){return null!=e.match(HTTPRequest.URL_SCHEME_REGEX)}HTTPRequest.URL_SCHEME_REGEX=/^https?:\/\//;let httpRouter=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc));else if(Array.isArray(e)?e.every(e=>isHTTPScheme(e)):isHTTPScheme(e))return new HTTPRequest(e,t);return null};function assertParamsValid(e,t,r){let n=e.shape.length;util_base_assert(n===t.length,()=>`Error in slice${n}D: Length of begin ${t} must match the rank of the array (${n}).`),util_base_assert(n===r.length,()=>`Error in slice${n}D: Length of size ${r} must match the rank of the array (${n}).`);for(let a=0;a<n;++a)util_base_assert(t[a]+r[a]<=e.shape[a],()=>`Error in slice${n}D: begin[${a}] + size[${a}] (${t[a]+r[a]}) would overflow input.shape[${a}] (${e.shape[a]})`)}function maskToAxes(e){let t=[],r=0;for(;e>0;)1&e&&t.push(r),e/=2,r++;return t}function computeOutShape(e,t,r){let n=[];for(let a=0;a<e.length;a++)n[a]=Math.ceil((t[a]-e[a])/r[a]);return n}function stridesWithElidedDims(e,t,r,n){let a=[...e];for(let e=a.length;e<n.length;e++)a.push(1);for(let e=0;e<r;e++)0===e?a[t]=1:(a.splice(t,0,1),a.pop());return a}function getElidedAxes(e,t){let r=[];for(let n=0;n<e;n++)r.push(t+n);return r}function getNormalizedAxes(e,t,r,n,a,i,o,s,u){let l=e.length,d=Array(l),h=Array(l),c=Array(l);if(t.length&&r>0){let u=t[0],l=r+1;d=startIndicesWithElidedDims(o,u,l,n,e),h=stopIndicesWithElidedDims(s,u,l,a,e),c=stridesWithElidedDims(i,u,l,e)}else for(let t=0;t<l;t++)d[t]=startForAxis(o,n,i,e,t,u),h[t]=stopForAxis(s,a,i,e,t,u),c[t]=stridesForAxis(i,t,u);return{begin:d,end:h,strides:c}}function startIndicesWithElidedDims(e,t,r,n,a){let i=[...a],o=getElidedAxes(r,t);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=0;else{var s;let o=(s=a)<=t?s:s-(r-1),u=n[o];e&1<<o&&(u=0),i[a]=u}return i}function stopIndicesWithElidedDims(e,t,r,n,a){let i=[...a],o=getElidedAxes(r,t);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=Number.MAX_SAFE_INTEGER;else{var s;let o=(s=a)<=t?s:s-(r-1),u=n[o];e&1<<o&&(u=Number.MAX_SAFE_INTEGER),i[a]=u}for(let e=0;e<i.length;e++){let t=a[e];i[e]<0&&(i[e]+=t),i[e]=clamp(0,i[e],a[e])}return i}function stridesForAxis(e,t,r){let n=e[t];return(r&1<<t||null==n)&&(n=1),n}function startForAxis(e,t,r,n,a,i){let o=t[a],s=r[a]||1;(e&1<<a||i&1<<a||null==o)&&(o=s>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);let u=n[a];return o<0&&(o+=u),o=clamp(0,o,u-1)}function stopForAxis(e,t,r,n,a,i){let o=t[a],s=r[a]||1;(e&1<<a||i&1<<a||null==o)&&(o=s>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);let u=n[a];return o<0&&(o+=u),o=s>0?clamp(0,o,u):clamp(-1,o,u-1)}function isSliceContinous(e,t,r){let n=r.length;for(let e=0;e<r.length;e++)if(r[e]>1){n=e;break}for(let a=n+1;a<r.length;a++)if(t[a]>0||r[a]!==e[a])return!1;return!0}function computeFlatOffset(e,t){let r=e.length>0?e[e.length-1]:1;for(let n=0;n<e.length-1;n++)r+=e[n]*t[n];return r}function parseSliceParams(e,t,r){let n,a;let i=e.shape.length;return(n="number"==typeof t?[t,...Array(i-1).fill(0)]:t.length<i?t.concat(Array(i-t.length).fill(0)):t.slice()).forEach(e=>{util_base_assert(-1!==e,()=>"slice() does not support negative begin indexing.")}),a=(a=null==r?Array(i).fill(-1):"number"==typeof r?[r,...Array(i-1).fill(-1)]:r.length<i?r.concat(Array(i-r.length).fill(-1)):r).map((t,r)=>t>=0?t:(util_base_assert(-1===t,()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${r}.`),e.shape[r]-n[r])),[n,a]}function sliceInfo(e,t,r,n,a,i,o,s,u){let l;if(null==n?(l=Array(t.length)).fill(1):l=n,null!=o&&(o&o-1)!=0)throw Error("Multiple ellipses in slice is not allowed.");let d=!1,h={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:r.slice(),strides:l.slice(),beginMask:a,endMask:i,ellipsisMask:o,newAxisMask:s,shrinkAxisMask:u};for(let e=0;e<h.dims;e++)d&&(1<<e&s)!=0&&h.numAddAxisAfterEllipsis++,1<<e&o&&(d=!0);!d&&(h.ellipsisMask|=1<<h.dims,h.dims++);let c={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let r=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=Array(t.dims),t.end=Array(t.dims),t.strides=Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=Array(t.dims);for(let n=0;n<e.dims;n++)if(1<<n&e.ellipsisMask){let a=Math.min(t.dims-(e.dims-n)+1+e.numAddAxisAfterEllipsis,t.dims);for(;r<a;r++)t.begin[r]=0,t.end[r]=0,t.strides[r]=1,t.beginMask|=1<<r,t.endMask|=1<<r,t.finalShapeGatherIndices.push(r),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[r]=n}else if(1<<n&e.newAxisMask)t.finalShapeGatherIndices.push(-2),t.finalShapeGatherIndicesSparse.push(-1);else{if(r===t.begin.length)throw Error(`Index out of range using input dim ${r}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[r]=e.begin[n]),null!=e.end&&(t.end[r]=e.end[n]),t.strides[r]=e.strides[n],e.beginMask&1<<n&&(t.beginMask|=1<<r),e.endMask&1<<n&&(t.endMask|=1<<r),e.shrinkAxisMask&1<<n?(t.finalShapeGatherIndices.push(-1),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<r):(t.finalShapeGatherIndices.push(r),t.finalShapeGatherIndicesSparse.push(n)),t.inputShapeGatherIndicesSparse[r]=n,r++}}(h,c);let p=!0,f=!0,m=!0,g=[],y=[];for(let t=0;t<e.length;++t){let r;if(0===c.strides[t])throw Error(`strides[${t}] must be non-zero`);let n=!!(c.shrinkAxisMask&1<<t),a=e[t];if(-1===a){g.push(n?1:-1);continue}let i=[c.beginMask&1<<t,c.endMask&1<<t],o=[c.strides[t]>0?0:-1,c.strides[t]>0?a:a-1];if(n&&c.strides[t]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===c.strides[t];let s=!!(c.beginMask&1<<t&&c.endMask&1<<t);if(c.beginValid&&c.endValid){if(n){let e=c.begin[t]<0?a+c.begin[t]:c.begin[t];if(c.begin[t]=e,c.end[t]=c.begin[t]+1,e<0||e>=a)throw Error(`slice index ${c.begin[t]} of dimension ${t} out of bounds.`)}else c.begin[t]=canonical(c.begin[t],0,c.strides[t],a,i,o),c.end[t]=canonical(c.end[t],1,c.strides[t],a,i,o);let e=1===c.strides[t]&&0===c.begin[t]&&c.end[t]===a;p=p&&e,f=f&&(0===t&&1===c.strides[t]||e)}else p=p&&1===c.strides[t]&&s,f=f&&(0===t&&1===c.strides[t]||s);let u=!1;if(c.beginValid&&c.endValid?(r=c.end[t]-c.begin[t],u=!0):n?(r=1,u=!0):s&&a>=0&&(r=c.strides[t]<0?-a:a,u=!0),u){let e;e=0===r||r<0!=c.strides[t]<0?0:Math.trunc(r/c.strides[t])+(r%c.strides[t]!=0?1:0),g.push(e)}else g.push(-1)}for(let e=0;e<c.finalShapeGatherIndices.length;++e){let t=c.finalShapeGatherIndices[e];t>=0?y.push(g[t]):-2===t&&y.push(1)}let x=y.filter((e,t)=>-2!==c.finalShapeGatherIndices[t]);return{finalShapeSparse:x,finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:c.begin,end:c.end,strides:c.strides}}function canonical(e,t,r,n,a,i){if(a[t])return r>0?i[t]:i[t+1&1];{let t=e<0?n+e:e;return t<i[0]?i[0]:t>i[1]?i[1]:t}}router_registry_IORouterRegistry.registerSaveRouter(httpRouter),router_registry_IORouterRegistry.registerLoadRouter(httpRouter);let r8=op({reshape_:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t){let r=tensor_util_env_convertToTensor(e,"x","reshape","string_or_numeric");return r_.runKernel(tP,{x:r},{shape:t})}}),r7=op({broadcastTo_:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t){let r=tensor_util_env_convertToTensor(e,"broadcastTo","x"),n=r.shape;if(assertNonNegativeIntegerDimensions(t),t.length<r.rank)throw Error(`broadcastTo(): shape.length=${t.length} < input.rank=${r.rank}.`);if(t.length>r.rank){let e=r.shape.slice();for(;e.length<t.length;)e.unshift(1);r=r8(r,e)}let a=r.shape,i=Array.from(t);for(let e=t.length-1;e>=0;e--)if(a[e]===t[e])i[e]=1;else if(1!==r.shape[e])throw Error(`broadcastTo(): [${n}] cannot be broadcast to [${t}].`);let o=i.map((e,t)=>e>1?t:-1).filter(e=>e>=0);if(0===o.length)return rK(r);let s={x:r};return r_.runKernel(ru,s,{reps:i})}}),r9=op({mean_:/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t=null,r=!1){let n=tensor_util_env_convertToTensor(e,"x","mean");return r_.runKernel(to,{x:n},{axis:t,keepDims:r})}}),ne=op({split_:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t,r=0){let n=tensor_util_env_convertToTensor(e,"x","split");return r_.runKernel(t1,{x:n},{numOrSizeSplits:t,axis:r})}}),nt=op({sum_:/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t=null,r=!1){let n=tensor_util_env_convertToTensor(e,"x","sum");"bool"===n.dtype&&(n=rH(n,"int32"));let a={x:n};return r_.runKernel(tJ,a,{axis:t,keepDims:r})}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tensor2d(e,t,r){if(assertNonNull(e),null!=t&&2!==t.length)throw Error("tensor2d() requires shape to have two numbers");let n=inferShape(e,r);if(2!==n.length&&1!==n.length)throw Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===n.length&&null==t)throw Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return makeTensor(e,t,n,r)}let nr=op({complex_:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t){let r=tensor_util_env_convertToTensor(e,"real","complex"),n=tensor_util_env_convertToTensor(t,"imag","complex");return assertShapesMatch(r.shape,n.shape,`real and imag shapes, ${r.shape} and ${n.shape}, must match in call to tf.complex().`),r_.runKernel(en,{real:r,imag:n})}});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zeros(e,t="float32"){if(assertNonNegativeIntegerDimensions(e),"complex64"===t){let t=zeros(e,"float32"),r=zeros(e,"float32");return nr(t,r)}let r=makeZerosTypedArray(util_base_sizeFromShape(e),t);return r_.makeTensor(r,e,t)}let nn=op({concat_:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t=0){util_base_assert(e.length>=1,()=>"Pass at least one tensor to concat");let r=function(e,t,r,n="numeric"){if(!Array.isArray(e))throw Error(`Argument ${t} passed to ${r} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((e,a)=>tensor_util_env_convertToTensor(e,`${t}[${a}]`,r,n))}(e,"tensors","concat","string_or_numeric");return("complex64"===r[0].dtype&&r.forEach(e=>{if("complex64"!==e.dtype)throw Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${e.dtype}. `)}),1===r.length)?rK(r[0]):r_.runKernel(ei,r,{axis:t})}}),na=op({imag_:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t=tensor_util_env_convertToTensor(e,"input","imag");return r_.runKernel(eX,{input:t})}}),ni=op({real_:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t=tensor_util_env_convertToTensor(e,"input","real");return r_.runKernel(tD,{input:t})}}),no=op({slice_:/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t,r){let n=tensor_util_env_convertToTensor(e,"x","slice","string_or_numeric");if(0===n.rank)throw Error("Slicing scalar is not possible");return r_.runKernel(tK,{x:n},{begin:t,size:r})}}),ns=op({fft_:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){return util_base_assert("complex64"===e.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`),r_.runKernel(eO,{input:e})}}),nu=op({rfft_:/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t){let r;util_base_assert("float32"===e.dtype,()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1],a=e.size/n;if(null!=t&&t<n){let a=e.shape.map(e=>0),i=e.shape.map(e=>e);i[e.shape.length-1]=t,r=no(e,a,i),n=t}else if(null!=t&&t>n){let a=e.shape.map(e=>e);a[e.shape.length-1]=t-n,r=nn([e,zeros(a)],e.shape.length-1),n=t}else r=e;let i=rJ(r),o=r8(nr(r,i),[a,n]),s=ns(o),u=Math.floor(n/2)+1,l=ni(s),d=na(s),h=ne(l,[u,n-u],l.shape.length-1),c=ne(d,[u,n-u],d.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=u,r8(nr(h[0],c[0]),p)}});function cosineWindow(e,t,r){let n=1-e%2,a=new Float32Array(e);for(let i=0;i<e;++i){let o=2*Math.PI*i/(e+n-1);a[i]=t-r*Math.cos(o)}return(/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t){assertNonNull(e);let r=inferShape(e,t);if(1!==r.length)throw Error("tensor1d() requires values to be a flat/TypedArray");return makeTensor(e,null,r,t)}(a,"float32"))}let nl=op({hammingWindow_:/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){return cosineWindow(e,.54,.46)}}),nd=op({hannWindow_:/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){return cosineWindow(e,.5,.5)}}),nh=op({frame_:/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t,r,n=!1,a=0){let i=0,o=[];for(;i+t<=e.size;)o.push(no(e,i,t)),i+=r;if(n)for(;i<e.size;){let n=i+t-e.size,s=nn([no(e,i,t-n),fill([n],a)]);o.push(s),i+=r}return 0===o.length?tensor2d([],[0,t]):r8(nn(o),[o.length,t])}}),nc=op({stft_:/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t,r,n,a=nd){null==n&&(n=Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2)))));let i=nh(e,t,r),o=rY(i,a(t));return nu(o,n)}}),np=op({tile_:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t){let r=tensor_util_env_convertToTensor(e,"x","tile","string_or_numeric");return util_base_assert(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of reps ${t}.`),r_.runKernel(ru,{x:r},{reps:t})}}),nf=op({expandDims_:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t=0){let r=tensor_util_env_convertToTensor(e,"x","expandDims","string_or_numeric");return util_base_assert(t<=r.rank,()=>"Axis must be <= rank of the tensor"),r_.runKernel(eN,{input:r},{dim:t})}});function defaultComparator(e,t){return e>t?1:e<t?-1:0}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nonMaxSuppressionV3Impl(e,t,r,n,a){return nonMaxSuppressionImpl_(e,t,r,n,a,0)}function nonMaxSuppressionV4Impl(e,t,r,n,a,i){return nonMaxSuppressionImpl_(e,t,r,n,a,0,!1,i,!0)}function nonMaxSuppressionV5Impl(e,t,r,n,a,i){return nonMaxSuppressionImpl_(e,t,r,n,a,i,!0)}function nonMaxSuppressionImpl_(e,t,r,n,a,i,o=!1,s=!1,u=!1){let l=[];for(let e=0;e<t.length;e++)t[e]>a&&l.push({score:t[e],boxIndex:e,suppressBeginIndex:0});l.sort(ascendingComparator);let d=i>0?-.5/i:0,h=[],c=[];for(;h.length<r&&l.length>0;){let t=l.pop(),{score:r,boxIndex:i,suppressBeginIndex:o}=t;if(r<a)break;let s=!1;for(let r=h.length-1;r>=o;--r){let o=function(e,t,r){let n=e.subarray(4*t,4*t+4),a=e.subarray(4*r,4*r+4),i=Math.min(n[0],n[2]),o=Math.min(n[1],n[3]),s=Math.max(n[0],n[2]),u=Math.max(n[1],n[3]),l=Math.min(a[0],a[2]),d=Math.min(a[1],a[3]),h=Math.max(a[0],a[2]),c=Math.max(a[1],a[3]),p=(s-i)*(u-o),f=(h-l)*(c-d);if(p<=0||f<=0)return 0;let m=Math.max(i,l),g=Math.max(o,d),y=Math.min(s,h),x=Math.min(u,c),b=Math.max(y-m,0)*Math.max(x-g,0);return b/(p+f-b)}(e,i,h[r]);if(o>=n){s=!0;break}if(t.score=t.score*function(e,t,r){let n=Math.exp(t*r*r);return r<=e?n:0}(n,d,o),t.score<=a)break}t.suppressBeginIndex=h.length,!s&&(t.score===r?(h.push(i),c.push(t.score)):t.score>a&&/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t,r){let n=function(e,t,r){let n=0,a=e.length,i=0,o=!1;for(;n<a;){i=n+(a-n>>>1);let s=r(t,e[i]);s>0?n=i+1:(a=i,o=!s)}return o?n:-n-1}(e,t,r||defaultComparator),a=n<0?-(n+1):n;e.splice(a,0,t)}(l,t,ascendingComparator))}let p=h.length,f=r-p;s&&f>0&&(h.push(...Array(f).fill(0)),c.push(...Array(f).fill(0)));let m={selectedIndices:h};return o&&(m.selectedScores=c),u&&(m.validOutputs=p),m}function ascendingComparator(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}let nm=op({neg_:/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t=tensor_util_env_convertToTensor(e,"x","neg");return r_.runKernel(tp,{x:t})}});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function axesAreInnerMostDims(e,t){for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0}function combineLocations(e,t,r){let n=e.length+t.length,a=[],i=0,o=0;for(let s=0;s<n;s++)-1===r.indexOf(s)?a.push(e[i++]):a.push(t[o++]);return a}function computeOutAndReduceShapes(e,t){let r=[],n=e.length;for(let a=0;a<n;a++)-1===t.indexOf(a)&&r.push(e[a]);let a=t.map(t=>e[t]);return[r,a]}function expandShapeToKeepDim(e,t){let r=t.map(e=>1);return combineLocations(e,r,t)}function assertAxesAreInnerMostDims(e,t,r){util_base_assert(axesAreInnerMostDims(t,r),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${r} input.`)}function getAxesPermutation(e,t){if(axesAreInnerMostDims(e,t))return null;let r=[];for(let n=0;n<t;++n)-1===e.indexOf(n)&&r.push(n);return e.forEach(e=>r.push(e)),r}function getUndoAxesPermutation(e){return e.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function getInnerMostAxes(e,t){let r=[];for(let n=t-e;n<t;++n)r.push(n);return r}let ng=op({max_:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t=null,r=!1){let n=tensor_util_env_convertToTensor(e,"x","max");return r_.runKernel(e9,{x:n},{reductionIndices:t,keepDims:r})}}),ny=op({min_:/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t=null,r=!1){let n=tensor_util_env_convertToTensor(e,"x","min");return r_.runKernel(ts,{x:n},{axis:t,keepDims:r})}});(h=x||(x={}))[h.NONE=0]="NONE",h[h.MEAN=1]="MEAN",h[h.SUM=2]="SUM",h[h.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS";let nx=op({relu_:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t=tensor_util_env_convertToTensor(e,"x","relu");return r_.runKernel(tA,{x:t})}}),nb={hammingWindow:nl,hannWindow:nd,frame:nh,stft:nc},nv="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function nextFrame(){return new Promise(e=>nv(()=>e()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function assertParamsConsistent(e,t){let r=e[0].length;e.forEach((e,t)=>{util_base_assert(e.length===r,()=>`Error in concat${r}D: rank of tensors[${t}] must be the same as the rank of the rest (${r})`)}),util_base_assert(t>=0&&t<r,()=>`Error in concat${r}D: axis must be between 0 and ${r-1}.`);let n=e[0];e.forEach((e,a)=>{for(let i=0;i<r;i++)util_base_assert(i===t||e[i]===n[i],()=>`Error in concat${r}D: Shape of tensors[${a}] (${e}) does not match the shape of the rest (${n}) along the non-concatenated axis ${a}.`)})}function concat_util_computeOutShape(e,t){let r=e[0].slice();for(let n=1;n<e.length;n++)r[t]+=e[n][t];return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function computeDilation2DInfo(e,t,r,n,a="NHWC",i){let o=e[3],s=[...t,o],u=convertConv2DDataFormat(a);return computeConv2DInfo(e,s,r,i,n,null,null,u)}function computePool2DInfo(e,t,r,n,a,i,o="channelsLast"){let s;let[u,l]=parseTupleParam(t);if("channelsLast"===o)s=[u,l,e[3],e[3]];else if("channelsFirst"===o)s=[u,l,e[1],e[1]];else throw Error(`Unknown dataFormat ${o}`);return computeConv2DInfo(e,s,r,n,a,i,!1,o)}function computePool3DInfo(e,t,r,n,a,i,o="NDHWC"){let s,u;let[l,d,h]=parse3TupleParam(t);if("NDHWC"===o)u="channelsLast",s=[l,d,h,e[4],e[4]];else if("NCDHW"===o)u="channelsFirst",s=[l,d,h,e[1],e[1]];else throw Error(`Unknown dataFormat ${o}`);return computeConv3DInfo(e,s,r,n,a,!1,u,i)}function computeConv2DInfo(e,t,r,n,a,i,o=!1,s="channelsLast"){let u,[l,d,h,c]=[-1,-1,-1,-1];if("channelsLast"===s)[l,d,h,c]=e;else if("channelsFirst"===s)[l,c,d,h]=e;else throw Error(`Unknown dataFormat ${s}`);let[p,f,,m]=t,[g,y]=parseTupleParam(r),[x,b]=parseTupleParam(n),v=getEffectiveFilterSize(p,x),w=getEffectiveFilterSize(f,b),{padInfo:C,outHeight:S,outWidth:I}=function(e,t,r,n,a,i,o,s,u){let l,d,h;if("number"==typeof e){let a=0===e?"VALID":"NUMBER";l={top:e,bottom:e,left:e,right:e,type:a};let o=function(e,t,r,n,a){null==n&&(n=computeDefaultPad(e,t,r));let i=e[0],o=e[1],s=conv_util_round((i-t+2*n)/r+1,a),u=conv_util_round((o-t+2*n)/r+1,a);return[s,u]}([t,r],i,n,e,s);d=o[0],h=o[1]}else if("same"===e){d=Math.ceil(t/n),h=Math.ceil(r/a);let e=Math.max(0,(d-1)*n+i-t),s=Math.max(0,(h-1)*a+o-r),u=Math.floor(e/2),c=Math.floor(s/2);l={top:u,bottom:e-u,left:c,right:s-c,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},d=Math.ceil((t-i+1)/n),h=Math.ceil((r-o+1)/a);else if("object"==typeof e){let c="channelsLast"===u?e[1][0]:e[2][0],p="channelsLast"===u?e[1][1]:e[2][1],f="channelsLast"===u?e[2][0]:e[3][0],m="channelsLast"===u?e[2][1]:e[3][1],g=0===c&&0===p&&0===f&&0===m?"VALID":"EXPLICIT";l={top:c,bottom:p,left:f,right:m,type:g},d=conv_util_round((t-i+c+p)/n+1,s),h=conv_util_round((r-o+f+m)/a+1,s)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:l,outHeight:d,outWidth:h}}(a,d,h,g,y,v,w,i,s),k=o?m*c:m;return"channelsFirst"===s?u=[l,k,S,I]:"channelsLast"===s&&(u=[l,S,I,k]),{batchSize:l,dataFormat:s,inHeight:d,inWidth:h,inChannels:c,outHeight:S,outWidth:I,outChannels:k,padInfo:C,strideHeight:g,strideWidth:y,filterHeight:p,filterWidth:f,effectiveFilterHeight:v,effectiveFilterWidth:w,dilationHeight:x,dilationWidth:b,inShape:e,outShape:u,filterShape:t}}function computeConv3DInfo(e,t,r,n,a,i=!1,o="channelsLast",s){let u,[l,d,h,c,p]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[l,d,h,c,p]=e;else if("channelsFirst"===o)[l,p,d,h,c]=e;else throw Error(`Unknown dataFormat ${o}`);let[f,m,g,,y]=t,[x,b,v]=parse3TupleParam(r),[w,C,S]=parse3TupleParam(n),I=getEffectiveFilterSize(f,w),k=getEffectiveFilterSize(m,C),R=getEffectiveFilterSize(g,S),{padInfo:$,outDepth:T,outHeight:D,outWidth:A}=function(e,t,r,n,a,i,o,s,u,l,d){let h,c,p,f;if("valid"===e&&(e=0),"number"==typeof e){let m=0===e?"VALID":"NUMBER";h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:m};let g=function(e,t,r,n,a,i){null==a&&(a=computeDefaultPad(e,t[0],n[0]));let o=[0,0,0,1];for(let r=0;r<3;r++)e[r]+2*a>=t[r]&&(o[r]=conv_util_round((e[r]-t[r]+2*a)/n[r]+1,i));return o}([t,r,n,1],[s,u,l],0,[a,i,o],e,d);c=g[0],p=g[1],f=g[2]}else if("same"===e){c=Math.ceil(t/a),p=Math.ceil(r/i),f=Math.ceil(n/o);let e=(c-1)*a+s-t,d=(p-1)*i+u-r,m=(f-1)*o+l-n,g=Math.floor(e/2),y=Math.floor(d/2),x=Math.floor(m/2);h={top:y,bottom:d-y,left:x,right:m-x,front:g,back:e-g,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:h,outDepth:c,outHeight:p,outWidth:f}}(a,d,h,c,x,b,v,I,k,R,s),P=i?y*p:y;return"channelsFirst"===o?u=[l,P,T,D,A]:"channelsLast"===o&&(u=[l,T,D,A,P]),{batchSize:l,dataFormat:o,inDepth:d,inHeight:h,inWidth:c,inChannels:p,outDepth:T,outHeight:D,outWidth:A,outChannels:P,padInfo:$,strideDepth:x,strideHeight:b,strideWidth:v,filterDepth:f,filterHeight:m,filterWidth:g,effectiveFilterDepth:I,effectiveFilterHeight:k,effectiveFilterWidth:R,dilationDepth:w,dilationHeight:C,dilationWidth:S,inShape:e,outShape:u,filterShape:t}}function computeDefaultPad(e,t,r,n=1){let a=getEffectiveFilterSize(t,n);return Math.floor((e[0]*(r-1)-r+a)/2)}function parseTupleParam(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function parse3TupleParam(e){return"number"==typeof e?[e,e,e]:e}function getEffectiveFilterSize(e,t){return t<=1?e:e+(e-1)*(t-1)}function conv_util_round(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw Error(`Unknown roundingMode ${t}`)}}function tupleValuesAreOne(e){let[t,r,n]=parseTupleParam(e);return 1===t&&1===r&&1===n}function eitherStridesOrDilationsAreOne(e,t){return tupleValuesAreOne(e)||tupleValuesAreOne(t)}function stridesOrDilationsArePositive(e){return parseTupleParam(e).every(e=>e>0)}function convertConv2DDataFormat(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw Error(`Unknown dataFormat ${e}`)}function checkPadOnDimRoundingMode(e,t,r){if(null!=r){if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${r} but got pad ${t}.`);if("number"==typeof t)util_base_assert(isInt(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${r} but got pad ${t}.`);else if("object"==typeof t)t.forEach(t=>{t.forEach(t=>{util_base_assert(isInt(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${r} but got pad ${t}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}let nw=op({elu_:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t=tensor_util_env_convertToTensor(e,"x","elu","float32");return r_.runKernel(eD,{x:t})}}),nC=op({leakyRelu_:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t=.2){let r=tensor_util_env_convertToTensor(e,"x","leakyRelu");return r_.runKernel(eZ,{x:r},{alpha:t})}}),nS=op({prelu_:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t){let r=tensor_util_env_convertToTensor(e,"x","prelu"),n=tensor_util_env_convertToTensor(t,"alpha","prelu");return r_.runKernel(tS,{x:r,alpha:n})}}),nI=op({relu6_:/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t=tensor_util_env_convertToTensor(e,"x","relu6");return r_.runKernel(tB,{x:t})}}),nk=op({sigmoid_:/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e){let t=tensor_util_env_convertToTensor(e,"x","sigmoid","float32");return r_.runKernel(tY,{x:t})}}),nR=op({step_:/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(e,t=0){let r=tensor_util_env_convertToTensor(e,"x","step");return r_.runKernel(rg,{x:r},{alpha:t})}});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getFusedDyActivation(e,t,r){if(null==r||"linear"===r)return e;if("relu"===r)return rY(e,nR(t));throw Error(`Cannot compute gradient for fused activation ${r}.`)}function getFusedBiasGradient(e,t){let r=t,n=getReductionAxes(e.shape,t.shape);return n.length>0&&(r=nt(r,n)),r8(r,e.shape)}function applyActivation(e,t,r,n){if("linear"===t)return e;if("relu"===t)return nx(e);if("elu"===t)return nw(e);if("relu6"===t)return nI(e);if("prelu"===t)return nS(e,r);if("leakyrelu"===t)return nC(e,n);if("sigmoid"===t)return nk(e);throw Error(`Unknown fused activation ${t}.`)}let shouldFuse=(e,t)=>!(e>0)||"linear"===t;function combineRaggedTensorToTensorShapes(e,t,r){let n=[];if(null==r&&null==t)return n;if(null==t)for(;n.length<e+r.length;)n.push(-1);else n=t.slice();if(null==r)return n;if(e+r.length!==n.length)throw Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+r.length}, but shape.rank = ${n.length}`);for(let a=1;a<r.length;++a){let i=r[a],o=n[n.length-r.length+a],s=n[o];if(i>=0){if(s>=0){if(s!==i)throw Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${a+e}] = ${i} but shape[${a+e}] = ${s}`)}else n[o]=i}}return n}function getRowPartitionTypesHelper(e){let t={FIRST_DIM_SIZE:b.FIRST_DIM_SIZE,VALUE_ROWIDS:b.VALUE_ROWIDS,ROW_LENGTHS:b.ROW_LENGTHS,ROW_SPLITS:b.ROW_SPLITS,ROW_LIMITS:b.ROW_LIMITS,ROW_STARTS:b.ROW_STARTS},r=[];for(let n of e)if(n in t)r.push(t[n]);else break;return r}function getRaggedRank(e){return 0===e.length?0:e[0]===b.FIRST_DIM_SIZE?e.length-1:e.length}function validateDefaultValueShape(e,t){if(null==e||null==t)return;let r=e.length,n=t.length;if(r>=n)throw Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${r} must be less than ragged tensor input flatValues.rank = ${n})`);for(let a=0;a<Math.min(r,n-1);++a){let r=e[a],n=t[a+1];if(r>=0&&n>=0&&1!==r&&r!==n)throw Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${a-e.length}] = ${r} but ragged tensor input.flatValues.shape[${a-e.length}] = ${n}`)}}(c=b||(b={}))[c.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",c[c.VALUE_ROWIDS=1]="VALUE_ROWIDS",c[c.ROW_LENGTHS=2]="ROW_LENGTHS",c[c.ROW_SPLITS=3]="ROW_SPLITS",c[c.ROW_LIMITS=4]="ROW_LIMITS",c[c.ROW_STARTS=5]="ROW_STARTS";/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let n$=30;function computeOptimalWindowSize(e){return e<=n$?e:nearestDivisor(e,Math.floor(Math.sqrt(e)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getImageCenter(e,t,r){let n=r*("number"==typeof e?e:e[0]),a=t*("number"==typeof e?e:e[1]);return[n,a]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getReshaped(e,t,r,n=!0){let a=[];if(n)(a=a.concat(t.slice(0))).push(e[0]/r),a=a.concat(e.slice(1));else{a=a.concat(e[0]);let r=t.length;for(let n=0;n<r;++n)a=a.concat([e[n+1]/t[n],t[n]]);a=a.concat(e.slice(r+1))}return a}function getPermuted(e,t,r=!0){let n=[];if(r){n.push(t);for(let r=t+1;r<e;++r)r<=2*t?(n.push(r),n.push(r-(t+1))):n.push(r)}else{let r=[],a=[];for(let n=1;n<e;++n)n>=2*t+1||n%2==1?a.push(n):r.push(n);n.push(...r),n.push(0),n.push(...a)}return n}function getReshapedPermuted(e,t,r,n=!0){let a=[];n?a.push(e[0]/r):a.push(e[0]*r);for(let r=1;r<e.length;++r)r<=t.length?n?a.push(t[r-1]*e[r]):a.push(e[r]/t[r-1]):a.push(e[r]);return a}function getSliceBeginCoords(e,t){let r=[0];for(let n=0;n<t;++n)r.push(e[n][0]);return r}function getSliceSize(e,t,r){let n=e.slice(0,1);for(let a=0;a<r;++a)n.push(e[a+1]-t[a][0]-t[a][1]);return n}function prepareAndValidate(e,t){let r=e.shape.length,n=t.shape.length;if(r<1)throw Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${r}.`);if(n<1)throw Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${n}.`);if("int32"!==t.dtype)throw Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[n-1]>r)throw Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[n-1]} vs. ${r}`);if(0===util_base_sizeFromShape(e.shape))throw Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let a=t.shape,i=a[a.length-1],o=1;for(let e=0;e<a.length-1;++e)o*=a[e];let s=e.shape,u=a.slice();u.pop();let l=1;for(let e=i;e<r;++e)l*=s[e],u.push(s[e]);let d=[...computeStrides(e.shape).map(e=>e/l),1].slice(0,i);return[u,o,l,d]}function validateUpdateShape(e,t,r){let n=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${r.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${n}, and batchDim: ${a}.`;if(r.rank<a)throw Error(i+` update.rank < ${a}. `);if(e.length<n+(r.rank-a))throw Error(i+` Output shape length < ${n+(r.rank-a)}`);if(r.rank!==a+e.length-n)throw Error(i+` update.rank != ${a+e.length-n}`);for(let e=0;e<a;++e)if(r.shape[e]!==t.shape[e])throw Error(i+` updates.shape[${e}] (${r.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<r.rank-a;++t)if(r.shape[t+a]!==e[t+n])throw Error(i+` updates.shape[${t+a}] (${r.shape[t+a]}) != shape[${t+a}] (${e[t+a]})`)}function validateInput(e,t,r){if(t.rank<1)throw Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(r.length<1)throw Error(`Output rank must be greater or equal to 1, but got shape: ${r}`);if(0===r.length){if(0===t.size)throw Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw Error(`Updates specified for empty output. updates shape: ${e.shape}`)}validateUpdateShape(r,t,e)}function calculateShapes(e,t,r){let n=t.shape.length,a=n>1?t.shape[n-1]:1,i=r.length,o=1;for(let e=a;e<i;++e)o*=r[e];let s=a<1?1:a,u=util_base_sizeFromShape(t.shape)/s,l=[...computeStrides(r.slice(0,a)),1],d=util_base_sizeFromShape(r);return{sliceRank:a,numUpdates:u,sliceSize:o,strides:l,outputSize:d}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nT=1.7580993408473768,nD=1.0507009873554805,nE=.3275911,nA=.254829592,nP=-.284496736,n_=1.421413741,nN=-1.453152027,nF=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mergeRealAndImagArrays(e,t){if(e.length!==t.length)throw Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let r=new Float32Array(2*e.length);for(let n=0;n<r.length;n+=2)r[n]=e[n/2],r[n+1]=t[n/2];return r}function splitRealAndImagArrays(e){let t=new Float32Array(e.length/2),r=new Float32Array(e.length/2);for(let n=0;n<e.length;n+=2)t[n/2]=e[n],r[n/2]=e[n+1];return{real:t,imag:r}}function complexWithEvenIndex(e){let t=Math.ceil(e.length/4),r=new Float32Array(t),n=new Float32Array(t);for(let t=0;t<e.length;t+=4)r[Math.floor(t/4)]=e[t],n[Math.floor(t/4)]=e[t+1];return{real:r,imag:n}}function complexWithOddIndex(e){let t=Math.floor(e.length/4),r=new Float32Array(t),n=new Float32Array(t);for(let t=2;t<e.length;t+=4)r[Math.floor(t/4)]=e[t],n[Math.floor(t/4)]=e[t+1];return{real:r,imag:n}}function getComplexWithIndex(e,t){let r=e[2*t],n=e[2*t+1];return{real:r,imag:n}}function assignToTypedArray(e,t,r,n){e[2*n]=t,e[2*n+1]=r}function exponents(e,t){let r=new Float32Array(e/2),n=new Float32Array(e/2);for(let a=0;a<Math.ceil(e/2);a++){let i=(t?2:-2)*Math.PI*(a/e);r[a]=Math.cos(i),n[a]=Math.sin(i)}return{real:r,imag:n}}function exponent(e,t,r){let n=(r?2:-2)*Math.PI*(e/t),a=Math.cos(n),i=Math.sin(n);return{real:a,imag:i}}let nO=/->/g;function decodeEinsumEquation(e,t){e=e.replace(/\s/g,"");let r=(e.length-e.replace(nO,"").length)/2;if(r<1)throw Error("Equations without an arrow are not supported.");if(r>1)throw Error('Equation must contain exactly one arrow ("->").');let[n,a]=e.split("->");util_base_assert(-1===n.indexOf("..."),()=>'The ellipsis notation ("...") is not supported yet.');let i=n.split(","),o=i.length;if(t!==o)throw Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw Error("Support for more than 2 input tensors is not implemented yet.");let s=[];for(let e=0;e<a.length;++e){let t=a[e];if(!i.some(e=>-1!==e.indexOf(t)))throw Error(`Output subscripts contain the label ${t} not present in the input subscripts.`);-1===s.indexOf(t)&&s.push(t)}for(let e=0;e<n.length;++e){let t=n[e];-1===s.indexOf(t)&&","!==t&&s.push(t)}let u=Array(i.length);for(let e=0;e<o;++e){if(new Set(i[e].split("")).size!==i[e].length)throw Error(`Found duplicate axes in input component ${i[e]}. Support for duplicate axes in input is not implemented yet.`);u[e]=[];for(let t=0;t<i[e].length;++t)u[e].push(s.indexOf(i[e][t]))}let l=s.length,d=a.length,h=[];for(let e=d;e<l;++e)h.push(e);return{allDims:s,summedDims:h,idDims:u}}function getEinsumPermutation(e,t){let r=Array(e);r.fill(-1);for(let e=0;e<t.length;++e)r[t[e]]=e;let n=[];for(let t=0;t<e;++t)-1===r[t]&&n.push(t);return{permutationIndices:r=r.filter(e=>-1!==e),expandDims:n}}function checkEinsumDimSizes(e,t,r){let n=Array(e);for(let e=0;e<r.length;++e){let a=r[e].shape;for(let r=0;r<t[e].length;++r)void 0===n[t[e][r]]?n[t[e][r]]=a[r]:util_base_assert(n[t[e][r]]===a[r],()=>`Expected dimension ${n[t[e][r]]} at axis ${r} of input shaped ${JSON.stringify(a)}, but got dimension ${a[r]}`)}}function getEinsumComputePath(e,t){let r=[],n=0;0===e.length&&e.push(-1),n=e.length+1;for(let e=0;e<n;++e)r.push([]);let a=[];for(let n=0;n<e.length;++n){let i=e[n],o=function(e,t){let r=[];for(let n=0;n<e.length;++n)(0===e[n].length||-1!==e[n].indexOf(t)||-1===t)&&r.push(n);return r}(t,i);for(let e of o)-1===a.indexOf(e)&&(r[n].push(e),a.push(e))}return{path:e,steps:r}}function isIdentityPermutation(e){return e.every((e,t)=>e===t)}function prepareSplitSize(e,t,r=0){let n=[];if("number"==typeof t)util_base_assert(e.shape[r]%t==0,()=>"Number of splits must evenly divide the axis."),n=Array(t).fill(e.shape[r]/t);else{let a=t.reduce((e,t)=>(-1===t&&(e+=1),e),0);util_base_assert(a<=1,()=>"There should be only one negative value in split array.");let i=t.indexOf(-1);if(-1!==i){let n=t.reduce((e,t)=>t>0?e+t:e);t[i]=e.shape[r]-n}util_base_assert(e.shape[r]===t.reduce((e,t)=>e+t),()=>"The sum of sizes must match the size of the axis dimension."),n=t}return n}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getSparseFillEmptyRowsIndicesDenseShapeMismatch(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function getSparseFillEmptyRowsNegativeIndexErrorMessage(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(e,t,r){return`indices(${e}, 0) is invalid: ${t} >= ${r}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function getSparseReshapeNegativeOutputDimErrorMessage(e,t){return`size ${e} must be non-negative, not ${t}`}function getSparseReshapeEmptyTensorZeroOutputDimErrorMessage(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function getSparseReshapeInputOutputMultipleErrorMessage(e,t){let r=util_base_sizeFromShape(e),n=util_base_sizeFromShape(t);return`Input to reshape is a SparseTensor with ${r}
  dense values, but the requested shape requires a multiple of ${n}. inputShape=${e} outputShape= ${t}`}function getSparseReshapeInputOutputMismatchErrorMessage(e,t){let r=util_base_sizeFromShape(e),n=util_base_sizeFromShape(t);return`Input to reshape is a tensor with ${r} dense values, but the requested shape has ${n}. inputShape=${e} outputShape=${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function getSparseSegmentReductionNegativeSegmentIdsErrorMessage(){return"segment ids must be >= 0"}function getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage(){return"segment ids are not increasing"}function getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function getSparseSegmentReductionIndicesOutOfRangeErrorMessage(e,t,r){return`Bad: indices[${e}] == ${t} out of range [0, ${r})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function segOpComputeOptimalWindowSize(e,t){let r,n=!1;for(e<=n$?(r=e,n=!0):r=nearestDivisor(e,Math.floor(Math.sqrt(e)));!n;)r>t||r===e?n=!0:r=nearestDivisor(e,r+1);return r}function segment_util_computeOutShape(e,t,r){let n=[],a=e.length;for(let i=0;i<a;i++)i!==t?n.push(e[i]):n.push(r);return n}function collectGatherOpShapeInfo(e,t,r,n){let a=t.shape.length,i=e.shape.length;if(0!==n&&(n<-a||n>a))throw Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${n}`);if(n<0&&(n+=a),n>i)throw Error(`batchDims (${n}) must be less than rank(x) (
    ${i}).`);if(r<n)throw Error(`batchDims (${n}) must be less than or equal to axis (${r}).`);for(let r=0;r<n;++r)if(e.shape[r]!==t.shape[r])throw Error(`x.shape[${r}]: ${e.shape[r]} should be equal to indices.shape[${r}]: ${t.shape[r]}.`);let o=e.shape[r],s=[],u=1,l=1,d=1;for(let t=0;t<n;++t)s.push(e.shape[t]),u*=e.shape[t];for(let t=n;t<r;t++)s.push(e.shape[t]),l*=e.shape[t];for(let e=n;e<a;e++)s.push(t.shape[e]);for(let t=r+1;t<i;t++)s.push(e.shape[t]),d*=e.shape[t];return{batchSize:u,sliceSize:d,outerSize:l,dimSize:o,outputShape:s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fromUint8ToStringArray(e){try{return e.map(e=>decodeString(e))}catch(e){throw Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function fromStringArrayToUint8(e){return e.map(e=>encodeString(e))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function whereImpl(e,t){let r=[];for(let e=0;e<t.length;e++)t[e]&&r.push(e);let n=buffer(e,"int32"),a=buffer([r.length,e.length],"int32");for(let t=0;t<r.length;t++){let i=n.indexToLoc(r[t]),o=t*e.length;a.values.set(i,o)}return a.toTensor()}!/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function(){for(let e of r6)!function(e,t,r){util_base_assert(null!=e.className,()=>"Class being registered does not have the static className property defined."),util_base_assert("string"==typeof e.className,()=>"className is required to be a string, but got type "+typeof e.className),util_base_assert(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),void 0===t&&(t="Custom"),void 0===r&&(r=e.className);let n=r,a=t+">"+n;SerializationMap.register(e),r0.set(a,e),r1.set(e,a)}(e)}()},81226:function(e,t){"use strict";t.byteLength=function(e){var t=getLens(e),r=t[0],n=t[1];return(r+n)*3/4-n},t.toByteArray=function(e){var t,r,i=getLens(e),o=i[0],s=i[1],u=new a((o+s)*3/4-s),l=0,d=s>0?o-4:o;for(r=0;r<d;r+=4)t=n[e.charCodeAt(r)]<<18|n[e.charCodeAt(r+1)]<<12|n[e.charCodeAt(r+2)]<<6|n[e.charCodeAt(r+3)],u[l++]=t>>16&255,u[l++]=t>>8&255,u[l++]=255&t;return 2===s&&(t=n[e.charCodeAt(r)]<<2|n[e.charCodeAt(r+1)]>>4,u[l++]=255&t),1===s&&(t=n[e.charCodeAt(r)]<<10|n[e.charCodeAt(r+1)]<<4|n[e.charCodeAt(r+2)]>>2,u[l++]=t>>8&255,u[l++]=255&t),u},t.fromByteArray=function(e){for(var t,n=e.length,a=n%3,i=[],o=0,s=n-a;o<s;o+=16383)i.push(function(e,t,n){for(var a,i=[],o=t;o<n;o+=3)i.push(r[(a=(e[o]<<16&16711680)+(e[o+1]<<8&65280)+(255&e[o+2]))>>18&63]+r[a>>12&63]+r[a>>6&63]+r[63&a]);return i.join("")}(e,o,o+16383>s?s:o+16383));return 1===a?i.push(r[(t=e[n-1])>>2]+r[t<<4&63]+"=="):2===a&&i.push(r[(t=(e[n-2]<<8)+e[n-1])>>10]+r[t>>4&63]+r[t<<2&63]+"="),i.join("")};for(var r=[],n=[],a="undefined"!=typeof Uint8Array?Uint8Array:Array,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",o=0,s=i.length;o<s;++o)r[o]=i[o],n[i.charCodeAt(o)]=o;function getLens(e){var t=e.length;if(t%4>0)throw Error("Invalid string. Length must be a multiple of 4");var r=e.indexOf("=");-1===r&&(r=t);var n=r===t?0:4-r%4;return[r,n]}n["-".charCodeAt(0)]=62,n["_".charCodeAt(0)]=63},61900:function(e,t,r){"use strict";/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */let n=r(81226),a=r(47354),i="function"==typeof Symbol&&"function"==typeof Symbol.for?Symbol.for("nodejs.util.inspect.custom"):null;function createBuffer(e){if(e>2147483647)throw RangeError('The value "'+e+'" is invalid for option "size"');let t=new Uint8Array(e);return Object.setPrototypeOf(t,Buffer.prototype),t}function Buffer(e,t,r){if("number"==typeof e){if("string"==typeof t)throw TypeError('The "string" argument must be of type string. Received type number');return allocUnsafe(e)}return from(e,t,r)}function from(e,t,r){if("string"==typeof e)return function(e,t){if(("string"!=typeof t||""===t)&&(t="utf8"),!Buffer.isEncoding(t))throw TypeError("Unknown encoding: "+t);let r=0|byteLength(e,t),n=createBuffer(r),a=n.write(e,t);return a!==r&&(n=n.slice(0,a)),n}(e,t);if(ArrayBuffer.isView(e))return function(e){if(isInstance(e,Uint8Array)){let t=new Uint8Array(e);return fromArrayBuffer(t.buffer,t.byteOffset,t.byteLength)}return fromArrayLike(e)}(e);if(null==e)throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e);if(isInstance(e,ArrayBuffer)||e&&isInstance(e.buffer,ArrayBuffer)||"undefined"!=typeof SharedArrayBuffer&&(isInstance(e,SharedArrayBuffer)||e&&isInstance(e.buffer,SharedArrayBuffer)))return fromArrayBuffer(e,t,r);if("number"==typeof e)throw TypeError('The "value" argument must not be of type number. Received type number');let n=e.valueOf&&e.valueOf();if(null!=n&&n!==e)return Buffer.from(n,t,r);let a=function(e){var t;if(Buffer.isBuffer(e)){let t=0|checked(e.length),r=createBuffer(t);return 0===r.length||e.copy(r,0,0,t),r}return void 0!==e.length?"number"!=typeof e.length||(t=e.length)!=t?createBuffer(0):fromArrayLike(e):"Buffer"===e.type&&Array.isArray(e.data)?fromArrayLike(e.data):void 0}(e);if(a)return a;if("undefined"!=typeof Symbol&&null!=Symbol.toPrimitive&&"function"==typeof e[Symbol.toPrimitive])return Buffer.from(e[Symbol.toPrimitive]("string"),t,r);throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e)}function assertSize(e){if("number"!=typeof e)throw TypeError('"size" argument must be of type number');if(e<0)throw RangeError('The value "'+e+'" is invalid for option "size"')}function allocUnsafe(e){return assertSize(e),createBuffer(e<0?0:0|checked(e))}function fromArrayLike(e){let t=e.length<0?0:0|checked(e.length),r=createBuffer(t);for(let n=0;n<t;n+=1)r[n]=255&e[n];return r}function fromArrayBuffer(e,t,r){let n;if(t<0||e.byteLength<t)throw RangeError('"offset" is outside of buffer bounds');if(e.byteLength<t+(r||0))throw RangeError('"length" is outside of buffer bounds');return Object.setPrototypeOf(n=void 0===t&&void 0===r?new Uint8Array(e):void 0===r?new Uint8Array(e,t):new Uint8Array(e,t,r),Buffer.prototype),n}function checked(e){if(e>=2147483647)throw RangeError("Attempt to allocate Buffer larger than maximum size: 0x7fffffff bytes");return 0|e}function byteLength(e,t){if(Buffer.isBuffer(e))return e.length;if(ArrayBuffer.isView(e)||isInstance(e,ArrayBuffer))return e.byteLength;if("string"!=typeof e)throw TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof e);let r=e.length,n=arguments.length>2&&!0===arguments[2];if(!n&&0===r)return 0;let a=!1;for(;;)switch(t){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":return utf8ToBytes(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return base64ToBytes(e).length;default:if(a)return n?-1:utf8ToBytes(e).length;t=(""+t).toLowerCase(),a=!0}}function slowToString(e,t,r){let a=!1;if((void 0===t||t<0)&&(t=0),t>this.length||((void 0===r||r>this.length)&&(r=this.length),r<=0||(r>>>=0)<=(t>>>=0)))return"";for(e||(e="utf8");;)switch(e){case"hex":return function(e,t,r){let n=e.length;(!t||t<0)&&(t=0),(!r||r<0||r>n)&&(r=n);let a="";for(let n=t;n<r;++n)a+=u[e[n]];return a}(this,t,r);case"utf8":case"utf-8":return utf8Slice(this,t,r);case"ascii":return function(e,t,r){let n="";r=Math.min(e.length,r);for(let a=t;a<r;++a)n+=String.fromCharCode(127&e[a]);return n}(this,t,r);case"latin1":case"binary":return function(e,t,r){let n="";r=Math.min(e.length,r);for(let a=t;a<r;++a)n+=String.fromCharCode(e[a]);return n}(this,t,r);case"base64":var i,o;return i=t,o=r,0===i&&o===this.length?n.fromByteArray(this):n.fromByteArray(this.slice(i,o));case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return function(e,t,r){let n=e.slice(t,r),a="";for(let e=0;e<n.length-1;e+=2)a+=String.fromCharCode(n[e]+256*n[e+1]);return a}(this,t,r);default:if(a)throw TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),a=!0}}function swap(e,t,r){let n=e[t];e[t]=e[r],e[r]=n}function bidirectionalIndexOf(e,t,r,n,a){var i;if(0===e.length)return -1;if("string"==typeof r?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),(i=r=+r)!=i&&(r=a?0:e.length-1),r<0&&(r=e.length+r),r>=e.length){if(a)return -1;r=e.length-1}else if(r<0){if(!a)return -1;r=0}if("string"==typeof t&&(t=Buffer.from(t,n)),Buffer.isBuffer(t))return 0===t.length?-1:arrayIndexOf(e,t,r,n,a);if("number"==typeof t)return(t&=255,"function"==typeof Uint8Array.prototype.indexOf)?a?Uint8Array.prototype.indexOf.call(e,t,r):Uint8Array.prototype.lastIndexOf.call(e,t,r):arrayIndexOf(e,[t],r,n,a);throw TypeError("val must be string, number or Buffer")}function arrayIndexOf(e,t,r,n,a){let i,o=1,s=e.length,u=t.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(e.length<2||t.length<2)return -1;o=2,s/=2,u/=2,r/=2}function read(e,t){return 1===o?e[t]:e.readUInt16BE(t*o)}if(a){let n=-1;for(i=r;i<s;i++)if(read(e,i)===read(t,-1===n?0:i-n)){if(-1===n&&(n=i),i-n+1===u)return n*o}else -1!==n&&(i-=i-n),n=-1}else for(r+u>s&&(r=s-u),i=r;i>=0;i--){let r=!0;for(let n=0;n<u;n++)if(read(e,i+n)!==read(t,n)){r=!1;break}if(r)return i}return -1}function utf8Slice(e,t,r){r=Math.min(e.length,r);let n=[],a=t;for(;a<r;){let t=e[a],i=null,o=t>239?4:t>223?3:t>191?2:1;if(a+o<=r){let r,n,s,u;switch(o){case 1:t<128&&(i=t);break;case 2:(192&(r=e[a+1]))==128&&(u=(31&t)<<6|63&r)>127&&(i=u);break;case 3:r=e[a+1],n=e[a+2],(192&r)==128&&(192&n)==128&&(u=(15&t)<<12|(63&r)<<6|63&n)>2047&&(u<55296||u>57343)&&(i=u);break;case 4:r=e[a+1],n=e[a+2],s=e[a+3],(192&r)==128&&(192&n)==128&&(192&s)==128&&(u=(15&t)<<18|(63&r)<<12|(63&n)<<6|63&s)>65535&&u<1114112&&(i=u)}}null===i?(i=65533,o=1):i>65535&&(i-=65536,n.push(i>>>10&1023|55296),i=56320|1023&i),n.push(i),a+=o}return function(e){let t=e.length;if(t<=4096)return String.fromCharCode.apply(String,e);let r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=4096));return r}(n)}function checkOffset(e,t,r){if(e%1!=0||e<0)throw RangeError("offset is not uint");if(e+t>r)throw RangeError("Trying to access beyond buffer length")}function checkInt(e,t,r,n,a,i){if(!Buffer.isBuffer(e))throw TypeError('"buffer" argument must be a Buffer instance');if(t>a||t<i)throw RangeError('"value" argument is out of bounds');if(r+n>e.length)throw RangeError("Index out of range")}function wrtBigUInt64LE(e,t,r,n,a){checkIntBI(t,n,a,e,r,7);let i=Number(t&BigInt(4294967295));e[r++]=i,i>>=8,e[r++]=i,i>>=8,e[r++]=i,i>>=8,e[r++]=i;let o=Number(t>>BigInt(32)&BigInt(4294967295));return e[r++]=o,o>>=8,e[r++]=o,o>>=8,e[r++]=o,o>>=8,e[r++]=o,r}function wrtBigUInt64BE(e,t,r,n,a){checkIntBI(t,n,a,e,r,7);let i=Number(t&BigInt(4294967295));e[r+7]=i,i>>=8,e[r+6]=i,i>>=8,e[r+5]=i,i>>=8,e[r+4]=i;let o=Number(t>>BigInt(32)&BigInt(4294967295));return e[r+3]=o,o>>=8,e[r+2]=o,o>>=8,e[r+1]=o,o>>=8,e[r]=o,r+8}function checkIEEE754(e,t,r,n,a,i){if(r+n>e.length||r<0)throw RangeError("Index out of range")}function writeFloat(e,t,r,n,i){return t=+t,r>>>=0,i||checkIEEE754(e,t,r,4,34028234663852886e22,-34028234663852886e22),a.write(e,t,r,n,23,4),r+4}function writeDouble(e,t,r,n,i){return t=+t,r>>>=0,i||checkIEEE754(e,t,r,8,17976931348623157e292,-17976931348623157e292),a.write(e,t,r,n,52,8),r+8}t.lW=Buffer,t.h2=50,Buffer.TYPED_ARRAY_SUPPORT=function(){try{let e=new Uint8Array(1),t={foo:function(){return 42}};return Object.setPrototypeOf(t,Uint8Array.prototype),Object.setPrototypeOf(e,t),42===e.foo()}catch(e){return!1}}(),Buffer.TYPED_ARRAY_SUPPORT||"undefined"==typeof console||"function"!=typeof console.error||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(Buffer.prototype,"parent",{enumerable:!0,get:function(){if(Buffer.isBuffer(this))return this.buffer}}),Object.defineProperty(Buffer.prototype,"offset",{enumerable:!0,get:function(){if(Buffer.isBuffer(this))return this.byteOffset}}),Buffer.poolSize=8192,Buffer.from=function(e,t,r){return from(e,t,r)},Object.setPrototypeOf(Buffer.prototype,Uint8Array.prototype),Object.setPrototypeOf(Buffer,Uint8Array),Buffer.alloc=function(e,t,r){return(assertSize(e),e<=0)?createBuffer(e):void 0!==t?"string"==typeof r?createBuffer(e).fill(t,r):createBuffer(e).fill(t):createBuffer(e)},Buffer.allocUnsafe=function(e){return allocUnsafe(e)},Buffer.allocUnsafeSlow=function(e){return allocUnsafe(e)},Buffer.isBuffer=function(e){return null!=e&&!0===e._isBuffer&&e!==Buffer.prototype},Buffer.compare=function(e,t){if(isInstance(e,Uint8Array)&&(e=Buffer.from(e,e.offset,e.byteLength)),isInstance(t,Uint8Array)&&(t=Buffer.from(t,t.offset,t.byteLength)),!Buffer.isBuffer(e)||!Buffer.isBuffer(t))throw TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(e===t)return 0;let r=e.length,n=t.length;for(let a=0,i=Math.min(r,n);a<i;++a)if(e[a]!==t[a]){r=e[a],n=t[a];break}return r<n?-1:n<r?1:0},Buffer.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},Buffer.concat=function(e,t){let r;if(!Array.isArray(e))throw TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return Buffer.alloc(0);if(void 0===t)for(r=0,t=0;r<e.length;++r)t+=e[r].length;let n=Buffer.allocUnsafe(t),a=0;for(r=0;r<e.length;++r){let t=e[r];if(isInstance(t,Uint8Array))a+t.length>n.length?(Buffer.isBuffer(t)||(t=Buffer.from(t)),t.copy(n,a)):Uint8Array.prototype.set.call(n,t,a);else if(Buffer.isBuffer(t))t.copy(n,a);else throw TypeError('"list" argument must be an Array of Buffers');a+=t.length}return n},Buffer.byteLength=byteLength,Buffer.prototype._isBuffer=!0,Buffer.prototype.swap16=function(){let e=this.length;if(e%2!=0)throw RangeError("Buffer size must be a multiple of 16-bits");for(let t=0;t<e;t+=2)swap(this,t,t+1);return this},Buffer.prototype.swap32=function(){let e=this.length;if(e%4!=0)throw RangeError("Buffer size must be a multiple of 32-bits");for(let t=0;t<e;t+=4)swap(this,t,t+3),swap(this,t+1,t+2);return this},Buffer.prototype.swap64=function(){let e=this.length;if(e%8!=0)throw RangeError("Buffer size must be a multiple of 64-bits");for(let t=0;t<e;t+=8)swap(this,t,t+7),swap(this,t+1,t+6),swap(this,t+2,t+5),swap(this,t+3,t+4);return this},Buffer.prototype.toString=function(){let e=this.length;return 0===e?"":0==arguments.length?utf8Slice(this,0,e):slowToString.apply(this,arguments)},Buffer.prototype.toLocaleString=Buffer.prototype.toString,Buffer.prototype.equals=function(e){if(!Buffer.isBuffer(e))throw TypeError("Argument must be a Buffer");return this===e||0===Buffer.compare(this,e)},Buffer.prototype.inspect=function(){let e="",r=t.h2;return e=this.toString("hex",0,r).replace(/(.{2})/g,"$1 ").trim(),this.length>r&&(e+=" ... "),"<Buffer "+e+">"},i&&(Buffer.prototype[i]=Buffer.prototype.inspect),Buffer.prototype.compare=function(e,t,r,n,a){if(isInstance(e,Uint8Array)&&(e=Buffer.from(e,e.offset,e.byteLength)),!Buffer.isBuffer(e))throw TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof e);if(void 0===t&&(t=0),void 0===r&&(r=e?e.length:0),void 0===n&&(n=0),void 0===a&&(a=this.length),t<0||r>e.length||n<0||a>this.length)throw RangeError("out of range index");if(n>=a&&t>=r)return 0;if(n>=a)return -1;if(t>=r)return 1;if(t>>>=0,r>>>=0,n>>>=0,a>>>=0,this===e)return 0;let i=a-n,o=r-t,s=Math.min(i,o),u=this.slice(n,a),l=e.slice(t,r);for(let e=0;e<s;++e)if(u[e]!==l[e]){i=u[e],o=l[e];break}return i<o?-1:o<i?1:0},Buffer.prototype.includes=function(e,t,r){return -1!==this.indexOf(e,t,r)},Buffer.prototype.indexOf=function(e,t,r){return bidirectionalIndexOf(this,e,t,r,!0)},Buffer.prototype.lastIndexOf=function(e,t,r){return bidirectionalIndexOf(this,e,t,r,!1)},Buffer.prototype.write=function(e,t,r,n){var a,i,o,s,u,l,d,h;if(void 0===t)n="utf8",r=this.length,t=0;else if(void 0===r&&"string"==typeof t)n=t,r=this.length,t=0;else if(isFinite(t))t>>>=0,isFinite(r)?(r>>>=0,void 0===n&&(n="utf8")):(n=r,r=void 0);else throw Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");let c=this.length-t;if((void 0===r||r>c)&&(r=c),e.length>0&&(r<0||t<0)||t>this.length)throw RangeError("Attempt to write outside buffer bounds");n||(n="utf8");let p=!1;for(;;)switch(n){case"hex":return function(e,t,r,n){let a;r=Number(r)||0;let i=e.length-r;n?(n=Number(n))>i&&(n=i):n=i;let o=t.length;for(n>o/2&&(n=o/2),a=0;a<n;++a){let n=parseInt(t.substr(2*a,2),16);if(n!=n)break;e[r+a]=n}return a}(this,e,t,r);case"utf8":case"utf-8":return a=t,i=r,blitBuffer(utf8ToBytes(e,this.length-a),this,a,i);case"ascii":case"latin1":case"binary":return o=t,s=r,blitBuffer(function(e){let t=[];for(let r=0;r<e.length;++r)t.push(255&e.charCodeAt(r));return t}(e),this,o,s);case"base64":return u=t,l=r,blitBuffer(base64ToBytes(e),this,u,l);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return d=t,h=r,blitBuffer(function(e,t){let r,n;let a=[];for(let i=0;i<e.length&&!((t-=2)<0);++i)n=(r=e.charCodeAt(i))>>8,a.push(r%256),a.push(n);return a}(e,this.length-d),this,d,h);default:if(p)throw TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),p=!0}},Buffer.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}},Buffer.prototype.slice=function(e,t){let r=this.length;e=~~e,t=void 0===t?r:~~t,e<0?(e+=r)<0&&(e=0):e>r&&(e=r),t<0?(t+=r)<0&&(t=0):t>r&&(t=r),t<e&&(t=e);let n=this.subarray(e,t);return Object.setPrototypeOf(n,Buffer.prototype),n},Buffer.prototype.readUintLE=Buffer.prototype.readUIntLE=function(e,t,r){e>>>=0,t>>>=0,r||checkOffset(e,t,this.length);let n=this[e],a=1,i=0;for(;++i<t&&(a*=256);)n+=this[e+i]*a;return n},Buffer.prototype.readUintBE=Buffer.prototype.readUIntBE=function(e,t,r){e>>>=0,t>>>=0,r||checkOffset(e,t,this.length);let n=this[e+--t],a=1;for(;t>0&&(a*=256);)n+=this[e+--t]*a;return n},Buffer.prototype.readUint8=Buffer.prototype.readUInt8=function(e,t){return e>>>=0,t||checkOffset(e,1,this.length),this[e]},Buffer.prototype.readUint16LE=Buffer.prototype.readUInt16LE=function(e,t){return e>>>=0,t||checkOffset(e,2,this.length),this[e]|this[e+1]<<8},Buffer.prototype.readUint16BE=Buffer.prototype.readUInt16BE=function(e,t){return e>>>=0,t||checkOffset(e,2,this.length),this[e]<<8|this[e+1]},Buffer.prototype.readUint32LE=Buffer.prototype.readUInt32LE=function(e,t){return e>>>=0,t||checkOffset(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},Buffer.prototype.readUint32BE=Buffer.prototype.readUInt32BE=function(e,t){return e>>>=0,t||checkOffset(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},Buffer.prototype.readBigUInt64LE=defineBigIntMethod(function(e){validateNumber(e>>>=0,"offset");let t=this[e],r=this[e+7];(void 0===t||void 0===r)&&boundsError(e,this.length-8);let n=t+256*this[++e]+65536*this[++e]+16777216*this[++e],a=this[++e]+256*this[++e]+65536*this[++e]+16777216*r;return BigInt(n)+(BigInt(a)<<BigInt(32))}),Buffer.prototype.readBigUInt64BE=defineBigIntMethod(function(e){validateNumber(e>>>=0,"offset");let t=this[e],r=this[e+7];(void 0===t||void 0===r)&&boundsError(e,this.length-8);let n=16777216*t+65536*this[++e]+256*this[++e]+this[++e],a=16777216*this[++e]+65536*this[++e]+256*this[++e]+r;return(BigInt(n)<<BigInt(32))+BigInt(a)}),Buffer.prototype.readIntLE=function(e,t,r){e>>>=0,t>>>=0,r||checkOffset(e,t,this.length);let n=this[e],a=1,i=0;for(;++i<t&&(a*=256);)n+=this[e+i]*a;return n>=(a*=128)&&(n-=Math.pow(2,8*t)),n},Buffer.prototype.readIntBE=function(e,t,r){e>>>=0,t>>>=0,r||checkOffset(e,t,this.length);let n=t,a=1,i=this[e+--n];for(;n>0&&(a*=256);)i+=this[e+--n]*a;return i>=(a*=128)&&(i-=Math.pow(2,8*t)),i},Buffer.prototype.readInt8=function(e,t){return(e>>>=0,t||checkOffset(e,1,this.length),128&this[e])?-((255-this[e]+1)*1):this[e]},Buffer.prototype.readInt16LE=function(e,t){e>>>=0,t||checkOffset(e,2,this.length);let r=this[e]|this[e+1]<<8;return 32768&r?4294901760|r:r},Buffer.prototype.readInt16BE=function(e,t){e>>>=0,t||checkOffset(e,2,this.length);let r=this[e+1]|this[e]<<8;return 32768&r?4294901760|r:r},Buffer.prototype.readInt32LE=function(e,t){return e>>>=0,t||checkOffset(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},Buffer.prototype.readInt32BE=function(e,t){return e>>>=0,t||checkOffset(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},Buffer.prototype.readBigInt64LE=defineBigIntMethod(function(e){validateNumber(e>>>=0,"offset");let t=this[e],r=this[e+7];(void 0===t||void 0===r)&&boundsError(e,this.length-8);let n=this[e+4]+256*this[e+5]+65536*this[e+6]+(r<<24);return(BigInt(n)<<BigInt(32))+BigInt(t+256*this[++e]+65536*this[++e]+16777216*this[++e])}),Buffer.prototype.readBigInt64BE=defineBigIntMethod(function(e){validateNumber(e>>>=0,"offset");let t=this[e],r=this[e+7];(void 0===t||void 0===r)&&boundsError(e,this.length-8);let n=(t<<24)+65536*this[++e]+256*this[++e]+this[++e];return(BigInt(n)<<BigInt(32))+BigInt(16777216*this[++e]+65536*this[++e]+256*this[++e]+r)}),Buffer.prototype.readFloatLE=function(e,t){return e>>>=0,t||checkOffset(e,4,this.length),a.read(this,e,!0,23,4)},Buffer.prototype.readFloatBE=function(e,t){return e>>>=0,t||checkOffset(e,4,this.length),a.read(this,e,!1,23,4)},Buffer.prototype.readDoubleLE=function(e,t){return e>>>=0,t||checkOffset(e,8,this.length),a.read(this,e,!0,52,8)},Buffer.prototype.readDoubleBE=function(e,t){return e>>>=0,t||checkOffset(e,8,this.length),a.read(this,e,!1,52,8)},Buffer.prototype.writeUintLE=Buffer.prototype.writeUIntLE=function(e,t,r,n){if(e=+e,t>>>=0,r>>>=0,!n){let n=Math.pow(2,8*r)-1;checkInt(this,e,t,r,n,0)}let a=1,i=0;for(this[t]=255&e;++i<r&&(a*=256);)this[t+i]=e/a&255;return t+r},Buffer.prototype.writeUintBE=Buffer.prototype.writeUIntBE=function(e,t,r,n){if(e=+e,t>>>=0,r>>>=0,!n){let n=Math.pow(2,8*r)-1;checkInt(this,e,t,r,n,0)}let a=r-1,i=1;for(this[t+a]=255&e;--a>=0&&(i*=256);)this[t+a]=e/i&255;return t+r},Buffer.prototype.writeUint8=Buffer.prototype.writeUInt8=function(e,t,r){return e=+e,t>>>=0,r||checkInt(this,e,t,1,255,0),this[t]=255&e,t+1},Buffer.prototype.writeUint16LE=Buffer.prototype.writeUInt16LE=function(e,t,r){return e=+e,t>>>=0,r||checkInt(this,e,t,2,65535,0),this[t]=255&e,this[t+1]=e>>>8,t+2},Buffer.prototype.writeUint16BE=Buffer.prototype.writeUInt16BE=function(e,t,r){return e=+e,t>>>=0,r||checkInt(this,e,t,2,65535,0),this[t]=e>>>8,this[t+1]=255&e,t+2},Buffer.prototype.writeUint32LE=Buffer.prototype.writeUInt32LE=function(e,t,r){return e=+e,t>>>=0,r||checkInt(this,e,t,4,4294967295,0),this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e,t+4},Buffer.prototype.writeUint32BE=Buffer.prototype.writeUInt32BE=function(e,t,r){return e=+e,t>>>=0,r||checkInt(this,e,t,4,4294967295,0),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},Buffer.prototype.writeBigUInt64LE=defineBigIntMethod(function(e,t=0){return wrtBigUInt64LE(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))}),Buffer.prototype.writeBigUInt64BE=defineBigIntMethod(function(e,t=0){return wrtBigUInt64BE(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))}),Buffer.prototype.writeIntLE=function(e,t,r,n){if(e=+e,t>>>=0,!n){let n=Math.pow(2,8*r-1);checkInt(this,e,t,r,n-1,-n)}let a=0,i=1,o=0;for(this[t]=255&e;++a<r&&(i*=256);)e<0&&0===o&&0!==this[t+a-1]&&(o=1),this[t+a]=(e/i>>0)-o&255;return t+r},Buffer.prototype.writeIntBE=function(e,t,r,n){if(e=+e,t>>>=0,!n){let n=Math.pow(2,8*r-1);checkInt(this,e,t,r,n-1,-n)}let a=r-1,i=1,o=0;for(this[t+a]=255&e;--a>=0&&(i*=256);)e<0&&0===o&&0!==this[t+a+1]&&(o=1),this[t+a]=(e/i>>0)-o&255;return t+r},Buffer.prototype.writeInt8=function(e,t,r){return e=+e,t>>>=0,r||checkInt(this,e,t,1,127,-128),e<0&&(e=255+e+1),this[t]=255&e,t+1},Buffer.prototype.writeInt16LE=function(e,t,r){return e=+e,t>>>=0,r||checkInt(this,e,t,2,32767,-32768),this[t]=255&e,this[t+1]=e>>>8,t+2},Buffer.prototype.writeInt16BE=function(e,t,r){return e=+e,t>>>=0,r||checkInt(this,e,t,2,32767,-32768),this[t]=e>>>8,this[t+1]=255&e,t+2},Buffer.prototype.writeInt32LE=function(e,t,r){return e=+e,t>>>=0,r||checkInt(this,e,t,4,2147483647,-2147483648),this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24,t+4},Buffer.prototype.writeInt32BE=function(e,t,r){return e=+e,t>>>=0,r||checkInt(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},Buffer.prototype.writeBigInt64LE=defineBigIntMethod(function(e,t=0){return wrtBigUInt64LE(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),Buffer.prototype.writeBigInt64BE=defineBigIntMethod(function(e,t=0){return wrtBigUInt64BE(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),Buffer.prototype.writeFloatLE=function(e,t,r){return writeFloat(this,e,t,!0,r)},Buffer.prototype.writeFloatBE=function(e,t,r){return writeFloat(this,e,t,!1,r)},Buffer.prototype.writeDoubleLE=function(e,t,r){return writeDouble(this,e,t,!0,r)},Buffer.prototype.writeDoubleBE=function(e,t,r){return writeDouble(this,e,t,!1,r)},Buffer.prototype.copy=function(e,t,r,n){if(!Buffer.isBuffer(e))throw TypeError("argument should be a Buffer");if(r||(r=0),n||0===n||(n=this.length),t>=e.length&&(t=e.length),t||(t=0),n>0&&n<r&&(n=r),n===r||0===e.length||0===this.length)return 0;if(t<0)throw RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw RangeError("Index out of range");if(n<0)throw RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),e.length-t<n-r&&(n=e.length-t+r);let a=n-r;return this===e&&"function"==typeof Uint8Array.prototype.copyWithin?this.copyWithin(t,r,n):Uint8Array.prototype.set.call(e,this.subarray(r,n),t),a},Buffer.prototype.fill=function(e,t,r,n){let a;if("string"==typeof e){if("string"==typeof t?(n=t,t=0,r=this.length):"string"==typeof r&&(n=r,r=this.length),void 0!==n&&"string"!=typeof n)throw TypeError("encoding must be a string");if("string"==typeof n&&!Buffer.isEncoding(n))throw TypeError("Unknown encoding: "+n);if(1===e.length){let t=e.charCodeAt(0);("utf8"===n&&t<128||"latin1"===n)&&(e=t)}}else"number"==typeof e?e&=255:"boolean"==typeof e&&(e=Number(e));if(t<0||this.length<t||this.length<r)throw RangeError("Out of range index");if(r<=t)return this;if(t>>>=0,r=void 0===r?this.length:r>>>0,e||(e=0),"number"==typeof e)for(a=t;a<r;++a)this[a]=e;else{let i=Buffer.isBuffer(e)?e:Buffer.from(e,n),o=i.length;if(0===o)throw TypeError('The value "'+e+'" is invalid for argument "value"');for(a=0;a<r-t;++a)this[a+t]=i[a%o]}return this};let o={};function E(e,t,r){o[e]=class extends r{constructor(){super(),Object.defineProperty(this,"message",{value:t.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${e}]`,this.stack,delete this.name}get code(){return e}set code(e){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:e,writable:!0})}toString(){return`${this.name} [${e}]: ${this.message}`}}}function addNumericalSeparator(e){let t="",r=e.length,n="-"===e[0]?1:0;for(;r>=n+4;r-=3)t=`_${e.slice(r-3,r)}${t}`;return`${e.slice(0,r)}${t}`}function checkIntBI(e,t,r,n,a,i){if(e>r||e<t){let n;let a="bigint"==typeof t?"n":"";throw n=i>3?0===t||t===BigInt(0)?`>= 0${a} and < 2${a} ** ${(i+1)*8}${a}`:`>= -(2${a} ** ${(i+1)*8-1}${a}) and < 2 ** ${(i+1)*8-1}${a}`:`>= ${t}${a} and <= ${r}${a}`,new o.ERR_OUT_OF_RANGE("value",n,e)}validateNumber(a,"offset"),(void 0===n[a]||void 0===n[a+i])&&boundsError(a,n.length-(i+1))}function validateNumber(e,t){if("number"!=typeof e)throw new o.ERR_INVALID_ARG_TYPE(t,"number",e)}function boundsError(e,t,r){if(Math.floor(e)!==e)throw validateNumber(e,r),new o.ERR_OUT_OF_RANGE(r||"offset","an integer",e);if(t<0)throw new o.ERR_BUFFER_OUT_OF_BOUNDS;throw new o.ERR_OUT_OF_RANGE(r||"offset",`>= ${r?1:0} and <= ${t}`,e)}E("ERR_BUFFER_OUT_OF_BOUNDS",function(e){return e?`${e} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),E("ERR_INVALID_ARG_TYPE",function(e,t){return`The "${e}" argument must be of type number. Received type ${typeof t}`},TypeError),E("ERR_OUT_OF_RANGE",function(e,t,r){let n=`The value of "${e}" is out of range.`,a=r;return Number.isInteger(r)&&Math.abs(r)>4294967296?a=addNumericalSeparator(String(r)):"bigint"==typeof r&&(a=String(r),(r>BigInt(2)**BigInt(32)||r<-(BigInt(2)**BigInt(32)))&&(a=addNumericalSeparator(a)),a+="n"),n+=` It must be ${t}. Received ${a}`},RangeError);let s=/[^+/0-9A-Za-z-_]/g;function utf8ToBytes(e,t){let r;t=t||1/0;let n=e.length,a=null,i=[];for(let o=0;o<n;++o){if((r=e.charCodeAt(o))>55295&&r<57344){if(!a){if(r>56319||o+1===n){(t-=3)>-1&&i.push(239,191,189);continue}a=r;continue}if(r<56320){(t-=3)>-1&&i.push(239,191,189),a=r;continue}r=(a-55296<<10|r-56320)+65536}else a&&(t-=3)>-1&&i.push(239,191,189);if(a=null,r<128){if((t-=1)<0)break;i.push(r)}else if(r<2048){if((t-=2)<0)break;i.push(r>>6|192,63&r|128)}else if(r<65536){if((t-=3)<0)break;i.push(r>>12|224,r>>6&63|128,63&r|128)}else if(r<1114112){if((t-=4)<0)break;i.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}else throw Error("Invalid code point")}return i}function base64ToBytes(e){return n.toByteArray(function(e){if((e=(e=e.split("=")[0]).trim().replace(s,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function blitBuffer(e,t,r,n){let a;for(a=0;a<n&&!(a+r>=t.length)&&!(a>=e.length);++a)t[a+r]=e[a];return a}function isInstance(e,t){return e instanceof t||null!=e&&null!=e.constructor&&null!=e.constructor.name&&e.constructor.name===t.name}let u=function(){let e="0123456789abcdef",t=Array(256);for(let r=0;r<16;++r){let n=16*r;for(let a=0;a<16;++a)t[n+a]=e[r]+e[a]}return t}();function defineBigIntMethod(e){return"undefined"==typeof BigInt?BufferBigIntNotDefined:e}function BufferBigIntNotDefined(){throw Error("BigInt not supported")}},47354:function(e,t){/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */t.read=function(e,t,r,n,a){var i,o,s=8*a-n-1,u=(1<<s)-1,l=u>>1,d=-7,h=r?a-1:0,c=r?-1:1,p=e[t+h];for(h+=c,i=p&(1<<-d)-1,p>>=-d,d+=s;d>0;i=256*i+e[t+h],h+=c,d-=8);for(o=i&(1<<-d)-1,i>>=-d,d+=n;d>0;o=256*o+e[t+h],h+=c,d-=8);if(0===i)i=1-l;else{if(i===u)return o?NaN:(p?-1:1)*(1/0);o+=Math.pow(2,n),i-=l}return(p?-1:1)*o*Math.pow(2,i-n)},t.write=function(e,t,r,n,a,i){var o,s,u,l=8*i-a-1,d=(1<<l)-1,h=d>>1,c=23===a?5960464477539062e-23:0,p=n?0:i-1,f=n?1:-1,m=t<0||0===t&&1/t<0?1:0;for(isNaN(t=Math.abs(t))||t===1/0?(s=isNaN(t)?1:0,o=d):(o=Math.floor(Math.log(t)/Math.LN2),t*(u=Math.pow(2,-o))<1&&(o--,u*=2),o+h>=1?t+=c/u:t+=c*Math.pow(2,1-h),t*u>=2&&(o++,u/=2),o+h>=d?(s=0,o=d):o+h>=1?(s=(t*u-1)*Math.pow(2,a),o+=h):(s=t*Math.pow(2,h-1)*Math.pow(2,a),o=0));a>=8;e[r+p]=255&s,p+=f,s/=256,a-=8);for(o=o<<a|s,l+=a;l>0;e[r+p]=255&o,p+=f,o/=256,l-=8);e[r+p-f]|=128*m}},6017:function(e){e.exports=Long;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function Long(e,t,r){this.low=0|e,this.high=0|t,this.unsigned=!!r}function isLong(e){return!0===(e&&e.__isLong__)}Long.prototype.__isLong__,Object.defineProperty(Long.prototype,"__isLong__",{value:!0}),Long.isLong=isLong;var r={},n={};function fromInt(e,t){var a,i,o;return t?(e>>>=0,(o=0<=e&&e<256)&&(i=n[e]))?i:(a=fromBits(e,(0|e)<0?-1:0,!0),o&&(n[e]=a),a):(e|=0,(o=-128<=e&&e<128)&&(i=r[e]))?i:(a=fromBits(e,e<0?-1:0,!1),o&&(r[e]=a),a)}function fromNumber(e,t){if(isNaN(e))return t?d:l;if(t){if(e<0)return d;if(e>=o)return m}else{if(e<=-s)return g;if(e+1>=s)return f}return e<0?fromNumber(-e,t).neg():fromBits(e%i|0,e/i|0,t)}function fromBits(e,t,r){return new Long(e,t,r)}Long.fromInt=fromInt,Long.fromNumber=fromNumber,Long.fromBits=fromBits;var a=Math.pow;function fromString(e,t,r){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return l;if("number"==typeof t?(r=t,t=!1):t=!!t,(r=r||10)<2||36<r)throw RangeError("radix");if((n=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===n)return fromString(e.substring(1),t,r).neg();for(var n,i=fromNumber(a(r,8)),o=l,s=0;s<e.length;s+=8){var u=Math.min(8,e.length-s),d=parseInt(e.substring(s,s+u),r);if(u<8){var h=fromNumber(a(r,u));o=o.mul(h).add(fromNumber(d))}else o=(o=o.mul(i)).add(fromNumber(d))}return o.unsigned=t,o}function fromValue(e,t){return"number"==typeof e?fromNumber(e,t):"string"==typeof e?fromString(e,t):fromBits(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}Long.fromString=fromString,Long.fromValue=fromValue;var i=4294967296,o=18446744073709552e3,s=0x7fffffffffffffff,u=fromInt(16777216),l=fromInt(0);Long.ZERO=l;var d=fromInt(0,!0);Long.UZERO=d;var h=fromInt(1);Long.ONE=h;var c=fromInt(1,!0);Long.UONE=c;var p=fromInt(-1);Long.NEG_ONE=p;var f=fromBits(-1,2147483647,!1);Long.MAX_VALUE=f;var m=fromBits(-1,-1,!0);Long.MAX_UNSIGNED_VALUE=m;var g=fromBits(0,-2147483648,!1);Long.MIN_VALUE=g;var y=Long.prototype;y.toInt=function(){return this.unsigned?this.low>>>0:this.low},y.toNumber=function(){return this.unsigned?(this.high>>>0)*i+(this.low>>>0):this.high*i+(this.low>>>0)},y.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(!this.eq(g))return"-"+this.neg().toString(e);var t=fromNumber(e),r=this.div(t),n=r.mul(t).sub(this);return r.toString(e)+n.toInt().toString(e)}for(var i=fromNumber(a(e,6),this.unsigned),o=this,s="";;){var u=o.div(i),l=(o.sub(u.mul(i)).toInt()>>>0).toString(e);if((o=u).isZero())return l+s;for(;l.length<6;)l="0"+l;s=""+l+s}},y.getHighBits=function(){return this.high},y.getHighBitsUnsigned=function(){return this.high>>>0},y.getLowBits=function(){return this.low},y.getLowBitsUnsigned=function(){return this.low>>>0},y.getNumBitsAbs=function(){if(this.isNegative())return this.eq(g)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&(e&1<<t)==0;t--);return 0!=this.high?t+33:t+1},y.isZero=function(){return 0===this.high&&0===this.low},y.eqz=y.isZero,y.isNegative=function(){return!this.unsigned&&this.high<0},y.isPositive=function(){return this.unsigned||this.high>=0},y.isOdd=function(){return(1&this.low)==1},y.isEven=function(){return(1&this.low)==0},y.equals=function(e){return isLong(e)||(e=fromValue(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&this.high===e.high&&this.low===e.low},y.eq=y.equals,y.notEquals=function(e){return!this.eq(e)},y.neq=y.notEquals,y.ne=y.notEquals,y.lessThan=function(e){return 0>this.comp(e)},y.lt=y.lessThan,y.lessThanOrEqual=function(e){return 0>=this.comp(e)},y.lte=y.lessThanOrEqual,y.le=y.lessThanOrEqual,y.greaterThan=function(e){return this.comp(e)>0},y.gt=y.greaterThan,y.greaterThanOrEqual=function(e){return this.comp(e)>=0},y.gte=y.greaterThanOrEqual,y.ge=y.greaterThanOrEqual,y.compare=function(e){if(isLong(e)||(e=fromValue(e)),this.eq(e))return 0;var t=this.isNegative(),r=e.isNegative();return t&&!r?-1:!t&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},y.comp=y.compare,y.negate=function(){return!this.unsigned&&this.eq(g)?g:this.not().add(h)},y.neg=y.negate,y.add=function(e){isLong(e)||(e=fromValue(e));var t,r,n=this.high>>>16,a=65535&this.high,i=this.low>>>16,o=65535&this.low,s=e.high>>>16,u=65535&e.high,l=e.low>>>16,d=65535&e.low,h=0,c=0;return t=0+((r=0+(o+d))>>>16),r&=65535,t+=i+l,c+=t>>>16,t&=65535,c+=a+u,h+=c>>>16,c&=65535,h+=n+s,fromBits(t<<16|r,(h&=65535)<<16|c,this.unsigned)},y.subtract=function(e){return isLong(e)||(e=fromValue(e)),this.add(e.neg())},y.sub=y.subtract,y.multiply=function(e){if(this.isZero())return l;if(isLong(e)||(e=fromValue(e)),t)return fromBits(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return l;if(this.eq(g))return e.isOdd()?g:l;if(e.eq(g))return this.isOdd()?g:l;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(u)&&e.lt(u))return fromNumber(this.toNumber()*e.toNumber(),this.unsigned);var r,n,a=this.high>>>16,i=65535&this.high,o=this.low>>>16,s=65535&this.low,d=e.high>>>16,h=65535&e.high,c=e.low>>>16,p=65535&e.low,f=0,m=0;return r=0+((n=0+s*p)>>>16),n&=65535,r+=o*p,m+=r>>>16,r&=65535,r+=s*c,m+=r>>>16,r&=65535,m+=i*p,f+=m>>>16,m&=65535,m+=o*c,f+=m>>>16,m&=65535,m+=s*h,f+=m>>>16,m&=65535,f+=a*p+i*c+o*h+s*d,fromBits(r<<16|n,(f&=65535)<<16|m,this.unsigned)},y.mul=y.multiply,y.divide=function(e){if(isLong(e)||(e=fromValue(e)),e.isZero())throw Error("division by zero");if(t){var r,n,i;return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?fromBits((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this}if(this.isZero())return this.unsigned?d:l;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return d;if(e.gt(this.shru(1)))return c;i=d}else{if(this.eq(g))return e.eq(h)||e.eq(p)?g:e.eq(g)?h:(r=this.shr(1).div(e).shl(1)).eq(l)?e.isNegative()?h:p:(n=this.sub(e.mul(r)),i=r.add(n.div(e)));if(e.eq(g))return this.unsigned?d:l;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();i=l}for(n=this;n.gte(e);){for(var o=Math.ceil(Math.log(r=Math.max(1,Math.floor(n.toNumber()/e.toNumber())))/Math.LN2),s=o<=48?1:a(2,o-48),u=fromNumber(r),f=u.mul(e);f.isNegative()||f.gt(n);)r-=s,f=(u=fromNumber(r,this.unsigned)).mul(e);u.isZero()&&(u=h),i=i.add(u),n=n.sub(f)}return i},y.div=y.divide,y.modulo=function(e){return(isLong(e)||(e=fromValue(e)),t)?fromBits((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},y.mod=y.modulo,y.rem=y.modulo,y.not=function(){return fromBits(~this.low,~this.high,this.unsigned)},y.and=function(e){return isLong(e)||(e=fromValue(e)),fromBits(this.low&e.low,this.high&e.high,this.unsigned)},y.or=function(e){return isLong(e)||(e=fromValue(e)),fromBits(this.low|e.low,this.high|e.high,this.unsigned)},y.xor=function(e){return isLong(e)||(e=fromValue(e)),fromBits(this.low^e.low,this.high^e.high,this.unsigned)},y.shiftLeft=function(e){return(isLong(e)&&(e=e.toInt()),0==(e&=63))?this:e<32?fromBits(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):fromBits(0,this.low<<e-32,this.unsigned)},y.shl=y.shiftLeft,y.shiftRight=function(e){return(isLong(e)&&(e=e.toInt()),0==(e&=63))?this:e<32?fromBits(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):fromBits(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},y.shr=y.shiftRight,y.shiftRightUnsigned=function(e){if(isLong(e)&&(e=e.toInt()),0==(e&=63))return this;var t=this.high;return e<32?fromBits(this.low>>>e|t<<32-e,t>>>e,this.unsigned):32===e?fromBits(t,0,this.unsigned):fromBits(t>>>e-32,0,this.unsigned)},y.shru=y.shiftRightUnsigned,y.shr_u=y.shiftRightUnsigned,y.toSigned=function(){return this.unsigned?fromBits(this.low,this.high,!1):this},y.toUnsigned=function(){return this.unsigned?this:fromBits(this.low,this.high,!0)},y.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},y.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},y.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},Long.fromBytes=function(e,t,r){return r?Long.fromBytesLE(e,t):Long.fromBytesBE(e,t)},Long.fromBytesLE=function(e,t){return new Long(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},Long.fromBytesBE=function(e,t){return new Long(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},28070:function(e){var t,r,n,a=e.exports={};function defaultSetTimout(){throw Error("setTimeout has not been defined")}function defaultClearTimeout(){throw Error("clearTimeout has not been defined")}function runTimeout(e){if(t===setTimeout)return setTimeout(e,0);if((t===defaultSetTimout||!t)&&setTimeout)return t=setTimeout,setTimeout(e,0);try{return t(e,0)}catch(r){try{return t.call(null,e,0)}catch(r){return t.call(this,e,0)}}}!function(){try{t="function"==typeof setTimeout?setTimeout:defaultSetTimout}catch(e){t=defaultSetTimout}try{r="function"==typeof clearTimeout?clearTimeout:defaultClearTimeout}catch(e){r=defaultClearTimeout}}();var i=[],o=!1,s=-1;function cleanUpNextTick(){o&&n&&(o=!1,n.length?i=n.concat(i):s=-1,i.length&&drainQueue())}function drainQueue(){if(!o){var e=runTimeout(cleanUpNextTick);o=!0;for(var t=i.length;t;){for(n=i,i=[];++s<t;)n&&n[s].run();s=-1,t=i.length}n=null,o=!1,function(e){if(r===clearTimeout)return clearTimeout(e);if((r===defaultClearTimeout||!r)&&clearTimeout)return r=clearTimeout,clearTimeout(e);try{r(e)}catch(t){try{return r.call(null,e)}catch(t){return r.call(this,e)}}}(e)}}function Item(e,t){this.fun=e,this.array=t}function noop(){}a.nextTick=function(e){var t=Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];i.push(new Item(e,t)),1!==i.length||o||runTimeout(drainQueue)},Item.prototype.run=function(){this.fun.apply(null,this.array)},a.title="browser",a.browser=!0,a.env={},a.argv=[],a.version="",a.versions={},a.on=noop,a.addListener=noop,a.once=noop,a.off=noop,a.removeListener=noop,a.removeAllListeners=noop,a.emit=noop,a.prependListener=noop,a.prependOnceListener=noop,a.listeners=function(e){return[]},a.binding=function(e){throw Error("process.binding is not supported")},a.cwd=function(){return"/"},a.chdir=function(e){throw Error("process.chdir is not supported")},a.umask=function(){return 0}},23377:function(e,t,r){"use strict";r.d(t,{x:function(){return l}});var n=r(90701),a=r(15101),i=r(18343),o=r(46642),s=r(97475),u=r(67155),l=function(e){function Subject(){var t=e.call(this)||this;return t.closed=!1,t.currentObservers=null,t.observers=[],t.isStopped=!1,t.hasError=!1,t.thrownError=null,t}return(0,n.ZT)(Subject,e),Subject.prototype.lift=function(e){var t=new d(this,this);return t.operator=e,t},Subject.prototype._throwIfClosed=function(){if(this.closed)throw new o.N},Subject.prototype.next=function(e){var t=this;(0,u.x)(function(){var r,a;if(t._throwIfClosed(),!t.isStopped){t.currentObservers||(t.currentObservers=Array.from(t.observers));try{for(var i=(0,n.XA)(t.currentObservers),o=i.next();!o.done;o=i.next())o.value.next(e)}catch(e){r={error:e}}finally{try{o&&!o.done&&(a=i.return)&&a.call(i)}finally{if(r)throw r.error}}}})},Subject.prototype.error=function(e){var t=this;(0,u.x)(function(){if(t._throwIfClosed(),!t.isStopped){t.hasError=t.isStopped=!0,t.thrownError=e;for(var r=t.observers;r.length;)r.shift().error(e)}})},Subject.prototype.complete=function(){var e=this;(0,u.x)(function(){if(e._throwIfClosed(),!e.isStopped){e.isStopped=!0;for(var t=e.observers;t.length;)t.shift().complete()}})},Subject.prototype.unsubscribe=function(){this.isStopped=this.closed=!0,this.observers=this.currentObservers=null},Object.defineProperty(Subject.prototype,"observed",{get:function(){var e;return(null===(e=this.observers)||void 0===e?void 0:e.length)>0},enumerable:!1,configurable:!0}),Subject.prototype._trySubscribe=function(t){return this._throwIfClosed(),e.prototype._trySubscribe.call(this,t)},Subject.prototype._subscribe=function(e){return this._throwIfClosed(),this._checkFinalizedStatuses(e),this._innerSubscribe(e)},Subject.prototype._innerSubscribe=function(e){var t=this,r=this.hasError,n=this.isStopped,a=this.observers;return r||n?i.Lc:(this.currentObservers=null,a.push(e),new i.w0(function(){t.currentObservers=null,(0,s.P)(a,e)}))},Subject.prototype._checkFinalizedStatuses=function(e){var t=this.hasError,r=this.thrownError,n=this.isStopped;t?e.error(r):n&&e.complete()},Subject.prototype.asObservable=function(){var e=new a.y;return e.source=this,e},Subject.create=function(e,t){return new d(e,t)},Subject}(a.y),d=function(e){function AnonymousSubject(t,r){var n=e.call(this)||this;return n.destination=t,n.source=r,n}return(0,n.ZT)(AnonymousSubject,e),AnonymousSubject.prototype.next=function(e){var t,r;null===(r=null===(t=this.destination)||void 0===t?void 0:t.next)||void 0===r||r.call(t,e)},AnonymousSubject.prototype.error=function(e){var t,r;null===(r=null===(t=this.destination)||void 0===t?void 0:t.error)||void 0===r||r.call(t,e)},AnonymousSubject.prototype.complete=function(){var e,t;null===(t=null===(e=this.destination)||void 0===e?void 0:e.complete)||void 0===t||t.call(e)},AnonymousSubject.prototype._subscribe=function(e){var t,r;return null!==(r=null===(t=this.source)||void 0===t?void 0:t.subscribe(e))&&void 0!==r?r:i.Lc},AnonymousSubject}(l)},8873:function(e,t,r){"use strict";r.d(t,{T:function(){return merge}});var n=r(53692),a=r(3995),i=r(55044),o=r(21123),s=r(62434);function merge(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var r=(0,o.yG)(e),u=(0,o._6)(e,1/0);return e.length?1===e.length?(0,a.Xf)(e[0]):(0,n.J)(u)((0,s.D)(e,r)):i.E}},14444:function(e,t,r){"use strict";r.d(t,{R:function(){return scan}});var n=r(32782),a=r(73392);function scan(e,t){var r;return(0,n.e)((r=arguments.length>=2,function(n,i){var o=r,s=t,u=0;n.subscribe((0,a.x)(i,function(t){var r=u++;s=o?e(s,t,r):(o=!0,t),i.next(s)},void 0))}))}},93660:function(e,t,r){"use strict";r.d(t,{d:function(){return shareReplay}});var n=r(65827),a=r(85092);function shareReplay(e,t,r){var i,o,s,u,l=!1;return e&&"object"==typeof e?(u=void 0===(i=e.bufferSize)?1/0:i,t=void 0===(o=e.windowTime)?1/0:o,l=void 0!==(s=e.refCount)&&s,r=e.scheduler):u=null!=e?e:1/0,(0,a.B)({connector:function(){return new n.t(u,t,r)},resetOnError:!0,resetOnComplete:!1,resetOnRefCountZero:l})}},48804:function(e,t,r){"use strict";r.d(t,{w:function(){return switchMap}});var n=r(3995),a=r(32782),i=r(73392);function switchMap(e,t){return(0,a.e)(function(r,a){var o=null,s=0,u=!1,checkComplete=function(){return u&&!o&&a.complete()};r.subscribe((0,i.x)(a,function(r){null==o||o.unsubscribe();var u=0,l=s++;(0,n.Xf)(e(r,l)).subscribe(o=(0,i.x)(a,function(e){return a.next(t?t(r,e,l,u++):e)},function(){o=null,checkComplete()}))},function(){u=!0,checkComplete()}))})}},7158:function(e,t,r){"use strict";r.d(t,{w:function(){return switchScan}});var n=r(48804),a=r(32782);function switchScan(e,t){return(0,a.e)(function(r,a){var i=t;return(0,n.w)(function(t,r){return e(i,t,r)},function(e,t){return i=t,t})(r).subscribe(a),function(){i=null}})}},77446:function(e,t,r){"use strict";r.d(t,{P:function(){return throttle}});var n=r(32782),a=r(73392),i=r(3995);function throttle(e,t){return(0,n.e)(function(r,n){var o=null!=t?t:{},s=o.leading,u=void 0===s||s,l=o.trailing,d=void 0!==l&&l,h=!1,c=null,p=null,f=!1,endThrottling=function(){null==p||p.unsubscribe(),p=null,d&&(send(),f&&n.complete())},cleanupThrottling=function(){p=null,f&&n.complete()},startThrottle=function(t){return p=(0,i.Xf)(e(t)).subscribe((0,a.x)(n,endThrottling,cleanupThrottling))},send=function(){if(h){h=!1;var e=c;c=null,n.next(e),f||startThrottle(e)}};r.subscribe((0,a.x)(n,function(e){h=!0,c=e,p&&!p.closed||(u?send():startThrottle(e))},function(){f=!0,d&&h&&p&&!p.closed||n.complete()}))})}},68131:function(e,t,r){"use strict";r.d(t,{z:function(){return a}});var n=r(77303),a=new(r(19142)).v(n.o)},21123:function(e,t,r){"use strict";r.d(t,{_6:function(){return popNumber},yG:function(){return popScheduler}});var n=r(20431);function last(e){return e[e.length-1]}function popScheduler(e){return(0,n.K)(last(e))?e.pop():void 0}function popNumber(e,t){return"number"==typeof last(e)?e.pop():t}},89727:function(e,t,r){"use strict";r.d(t,{U:function(){return pipeFromArray},z:function(){return pipe}});var n=r(40438);function pipe(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];return pipeFromArray(e)}function pipeFromArray(e){return 0===e.length?n.y:1===e.length?e[0]:function(t){return e.reduce(function(e,t){return t(e)},t)}}},10158:function(e,t,r){"use strict";r.d(t,{YX:function(){return runWorker}});var n=r(89098),a=r(62434),i=r(20498),o=r(64772),s=r(29130),u=r(71708),l=r(29445);function runWorker(e){let t=new e,r=(0,i.R)(self,"message");return(function(e,t){let r=t.pipe((0,o.U)(e=>new n.P_(e.data.kind,e.data.value,e.data.error)),(0,s.D)());return e.workUnit?r.pipe((0,u.b)(t=>(0,a.D)(e.workUnit(t)).pipe((0,l.i)()))):e.work(r).pipe((0,l.i)())})(t,r).subscribe(e=>{let r=postMessage;t.selectTransferables&&e.hasValue?r(e,t.selectTransferables(e.value)):r(e)})}},90701:function(e,t,r){"use strict";r.d(t,{CR:function(){return __read},FC:function(){return __asyncGenerator},Jh:function(){return __generator},KL:function(){return __asyncValues},XA:function(){return __values},ZT:function(){return __extends},ev:function(){return __spreadArray},mG:function(){return __awaiter},qq:function(){return __await}});var extendStatics=function(e,t){return(extendStatics=Object.setPrototypeOf||({__proto__:[]})instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])})(e,t)};function __extends(e,t){if("function"!=typeof t&&null!==t)throw TypeError("Class extends value "+String(t)+" is not a constructor or null");function __(){this.constructor=e}extendStatics(e,t),e.prototype=null===t?Object.create(t):(__.prototype=t.prototype,new __)}function __awaiter(e,t,r,n){return new(r||(r=Promise))(function(a,i){function fulfilled(e){try{step(n.next(e))}catch(e){i(e)}}function rejected(e){try{step(n.throw(e))}catch(e){i(e)}}function step(e){var t;e.done?a(e.value):((t=e.value)instanceof r?t:new r(function(e){e(t)})).then(fulfilled,rejected)}step((n=n.apply(e,t||[])).next())})}function __generator(e,t){var r,n,a,i,o={label:0,sent:function(){if(1&a[0])throw a[1];return a[1]},trys:[],ops:[]};return i={next:verb(0),throw:verb(1),return:verb(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function verb(s){return function(u){return function(s){if(r)throw TypeError("Generator is already executing.");for(;i&&(i=0,s[0]&&(o=0)),o;)try{if(r=1,n&&(a=2&s[0]?n.return:s[0]?n.throw||((a=n.return)&&a.call(n),0):n.next)&&!(a=a.call(n,s[1])).done)return a;switch(n=0,a&&(s=[2&s[0],a.value]),s[0]){case 0:case 1:a=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,n=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!(a=(a=o.trys).length>0&&a[a.length-1])&&(6===s[0]||2===s[0])){o=0;continue}if(3===s[0]&&(!a||s[1]>a[0]&&s[1]<a[3])){o.label=s[1];break}if(6===s[0]&&o.label<a[1]){o.label=a[1],a=s;break}if(a&&o.label<a[2]){o.label=a[2],o.ops.push(s);break}a[2]&&o.ops.pop(),o.trys.pop();continue}s=t.call(e,o)}catch(e){s=[6,e],n=0}finally{r=a=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,u])}}}function __values(e){var t="function"==typeof Symbol&&Symbol.iterator,r=t&&e[t],n=0;if(r)return r.call(e);if(e&&"number"==typeof e.length)return{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}};throw TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}function __read(e,t){var r="function"==typeof Symbol&&e[Symbol.iterator];if(!r)return e;var n,a,i=r.call(e),o=[];try{for(;(void 0===t||t-- >0)&&!(n=i.next()).done;)o.push(n.value)}catch(e){a={error:e}}finally{try{n&&!n.done&&(r=i.return)&&r.call(i)}finally{if(a)throw a.error}}return o}function __spreadArray(e,t,r){if(r||2==arguments.length)for(var n,a=0,i=t.length;a<i;a++)!n&&a in t||(n||(n=Array.prototype.slice.call(t,0,a)),n[a]=t[a]);return e.concat(n||Array.prototype.slice.call(t))}function __await(e){return this instanceof __await?(this.v=e,this):new __await(e)}function __asyncGenerator(e,t,r){if(!Symbol.asyncIterator)throw TypeError("Symbol.asyncIterator is not defined.");var n,a=r.apply(e,t||[]),i=[];return n={},verb("next"),verb("throw"),verb("return"),n[Symbol.asyncIterator]=function(){return this},n;function verb(e){a[e]&&(n[e]=function(t){return new Promise(function(r,n){i.push([e,t,r,n])>1||resume(e,t)})})}function resume(e,t){try{var r;(r=a[e](t)).value instanceof __await?Promise.resolve(r.value.v).then(fulfill,reject):settle(i[0][2],r)}catch(e){settle(i[0][3],e)}}function fulfill(e){resume("next",e)}function reject(e){resume("throw",e)}function settle(e,t){e(t),i.shift(),i.length&&resume(i[0][0],i[0][1])}}function __asyncValues(e){if(!Symbol.asyncIterator)throw TypeError("Symbol.asyncIterator is not defined.");var t,r=e[Symbol.asyncIterator];return r?r.call(e):(e=__values(e),t={},verb("next"),verb("throw"),verb("return"),t[Symbol.asyncIterator]=function(){return this},t);function verb(r){t[r]=e[r]&&function(t){return new Promise(function(n,a){!function(e,t,r,n){Promise.resolve(n).then(function(t){e({value:t,done:r})},t)}(n,a,(t=e[r](t)).done,t.value)})}}}"function"==typeof SuppressedError&&SuppressedError}}]);
//# sourceMappingURL=5136.5c43c226cf8045f1.js.map