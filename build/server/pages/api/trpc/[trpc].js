"use strict";(()=>{var e={};e.id=829,e.ids=[829,2888],e.modules={18910:e=>{e.exports=require("@tanstack/react-query")},85337:e=>{e.exports=require("@trpc/client")},4129:e=>{e.exports=require("@trpc/next")},56368:e=>{e.exports=require("@trpc/server")},41169:e=>{e.exports=require("class-variance-authority")},68103:e=>{e.exports=require("clsx")},56988:e=>{e.exports=require("deep-equal")},54230:e=>{e.exports=require("glob")},20145:e=>{e.exports=require("next/dist/compiled/next-server/pages-api.runtime.prod.js")},24580:e=>{e.exports=require("node-cache")},71569:e=>{e.exports=require("object-hash")},58545:e=>{e.exports=require("pino")},80666:e=>{e.exports=require("pino-pretty-browser")},16689:e=>{e.exports=require("react")},7636:e=>{e.exports=require("react-use-websocket")},20997:e=>{e.exports=require("react/jsx-runtime")},29755:e=>{e.exports=require("recoil")},44101:e=>{e.exports=require("recoil-sync")},5873:e=>{e.exports=require("tailwind-merge")},53489:e=>{e.exports=require("ts-deepmerge")},38316:e=>{e.exports=require("zod")},15140:e=>{e.exports=require("zod-refine")},32081:e=>{e.exports=require("child_process")},57147:e=>{e.exports=require("fs")},73292:e=>{e.exports=require("fs/promises")},22037:e=>{e.exports=require("os")},71017:e=>{e.exports=require("path")},14521:e=>{e.exports=require("readline")},73837:e=>{e.exports=require("util")},98043:(e,t,r)=>{r.r(t),r.d(t,{config:()=>ec,default:()=>eo,routeModule:()=>el});var n={};r.r(n),r.d(n,{config:()=>ea,default:()=>es});var i=r(2573),a=r(29444),s=r(11089),o=r(19953),c=r(57147),l=r(73837),d=r(32081);let hasSsid=e=>e.ssid,hasKeys=e=>0!==Object.keys(e).length,bySignal=(e,t)=>t.signal-e.signal,parseCell=e=>{var t,r={};return(t=e.match(/BSS ([0-9A-Fa-f:-]{17})\(on/))&&(r.address=t[1].toLowerCase()),(t=e.match(/freq: ([0-9]+)/))&&(r.frequency=parseInt(t[1],10)),(t=e.match(/signal: (-?[0-9.]+) dBm/))&&(r.signal=parseFloat(t[1])),(t=e.match(/last seen: ([0-9]+) ms ago/))&&(r.lastSeenMs=parseInt(t[1],10)),(t=e.match(/SSID: \\x00/))?delete r.ssid:(t=e.match(/SSID: ([^\n]*)/))&&(r.ssid=t[1]),(t=e.match(/Country: ([^\t]*)/))&&(r.country=t[1]),(t=e.match(/DS Parameter set: channel ([0-9]+)/))?r.channel=parseInt(t[1],10):(t=e.match(/\* primary channel: ([0-9]+)/))&&(r.channel=parseInt(t[1],10)),(t=e.match(/RSN:[\s*]+Version: 1/))?r.security="wpa2":(t=e.match(/WPA:[\s*]+Version: 1/))?r.security="wpa":(t=e.match(/capability: ESS Privacy/))?r.security="wep":(t=e.match(/capability: ESS/))&&(r.security="open"),r},parseScan=e=>function({stdout:t,stderr:r}){return e?t.split(/(^|\n)(?=BSS )/).map(parseCell).filter(hasKeys).sort(bySignal):t.split(/(^|\n)(?=BSS )/).map(parseCell).filter(hasSsid).sort(bySignal)},getWirelessInterface=async()=>{let e=await (0,l.promisify)(d.exec)("iw dev | awk '$1==\"Interface\"{print $2}' | head -n1");return e.stdout.trim()},scan=async(e,t)=>{let r=t.apForce?" ap-force":"",n=await (0,l.promisify)(d.exec)("sudo iw dev "+e+" scan"+r);return parseScan(t.showHidden??!1)(n)};var u=r(39210),m=r(38316);let p=m.z.object({hostname:m.z.string().min(2).regex(/^([a-zA-Z0-9]|-)+$/,"Hostname can only include a-Z, 0-9 and dashes.")}),g=m.z.object({ssid:m.z.string().min(1).max(32),passphrase:m.z.string().min(8).max(63),frequencies:m.z.string(),country:m.z.string().optional(),hidden:m.z.boolean().optional()});var y=r(82757),f=r(34110),w=r(56368),x=r(71017),h=r.n(x);let b=(0,f.Nd)({hostname:f.$y.input(p).mutation(async({input:e})=>{let t=(0,u.xg)();try{await (0,l.promisify)(d.exec)(`sudo ${h().join(t,"change-hostname.sh")} ${e.hostname}`)}catch(e){throw e instanceof Error&&(0,o.j)().error(e.message),new w.TRPCError({message:"An error occured while attempting to change the hostname",code:"INTERNAL_SERVER_ERROR",cause:e})}return{result:"success"}}),join:f.$y.input(g).mutation(async({input:e})=>{try{console.log(await (0,y.$)("add-wifi-network.sh",e.ssid,e.passphrase,e.country??"GB",e.frequencies,e.hidden?"hidden":"shown"))}catch(e){throw e instanceof Error&&(0,o.j)().error(e.message),new w.TRPCError({message:"Invalid wifi credentials",code:"PRECONDITION_FAILED",cause:e})}return{result:"success"}}),scan:f.$y.input(m.z.object({showHidden:m.z.boolean().default(!1)})).query(async({input:e})=>{let t=await getWirelessInterface();if(null==t||""===t.trim())throw new w.TRPCError({message:"No wifi interface available on device, if you're connected via ethernet you can skip this step.",code:"INTERNAL_SERVER_ERROR"});try{return await scan(t,{apForce:!0,showHidden:e.showHidden})}catch(e){throw e instanceof Error&&(0,o.j)().error(e.message),new w.TRPCError({message:"Failed to scan wifi networks",code:"INTERNAL_SERVER_ERROR",cause:e})}})});var E=r(16906),S=r(71689),j=r(73292);m.z.object({fileName:m.z.string(),path:m.z.string(),extensionName:m.z.string()}),m.z.object({errorIfExists:m.z.boolean().optional(),errorIfNotExists:m.z.boolean().optional()});let symlinkExtensions=async e=>{let t=e.extensions.slice(),r=[];if(0===t.length)return{report:"No extensions registered, nothing to do.",cleanedUpExtensions:r,symlinkResults:[]};let n=h().resolve(h().join(e.gitRepoPath,".git","info","exclude")),i=await Promise.all(t.map(async t=>{if(!(0,c.existsSync)(h().resolve(h().join(t.path,t.fileName))))return{result:"error",message:`Extension file "${t.fileName}" does not exist in ${t.path} and has been removed from the list of registered extensions`};{r.push(t);let i=h().join("function"==typeof e.relativePath?e.relativePath(t):e.relativePath,t.fileName),a=h().resolve(h().join(e.gitRepoPath,i)),s=RegExp(`^${i}$`),o=await (0,u.M_)(n,s),l=(0,c.existsSync)(a);try{if(!1===l)await (0,j.symlink)(h().resolve(h().join(t.path,t.fileName)),a);else if(e.options?.errorIfExists)throw new w.TRPCError({code:"PRECONDITION_FAILED",message:`Symlink for "${t.fileName}" already exists.`});return!1===o&&await (0,j.appendFile)(n,`${i}
`),{result:"success",message:l?`Symlink for "${t.fileName}" already exists. Skipping.`:`Symlink for "${t.fileName}" created`}}catch(e){return{result:"error",message:`Failed to create symlink for "${t.fileName}"${e instanceof Error?`:
	${e.message}`:""}`}}}}));r.length!==t.length&&e.saveExtensions(r);let a=i.filter(e=>"success"===e.result).length,s=`Symlinked ${a}/${i.length} extension(s): 
`;return i.forEach(e=>{s+=`${e.message} 
`}),{report:s,cleanedUpExtensions:r,symlinkResults:i}},unlinkExtension=async e=>{let t=e.extension,r=h().join("function"==typeof e.relativePath?e.relativePath(t):e.relativePath,t.fileName),n=h().resolve(e.gitRepoPath,".git","info","exclude"),i=h().resolve(h().join(e.gitRepoPath,r));if(!(0,c.existsSync)(h().resolve(h().join(t.path,t.fileName))))return{result:"success",message:`Extension file "${t.fileName}" does not exist in ${t.path}. Nothing to do.`};{let a=RegExp(`^${r}$`);await (0,u.u5)(n,a,null);let s=(0,c.existsSync)(i);try{if(!0===s)await (0,j.unlink)(i);else if(e.options?.errorIfNotExists)throw new w.TRPCError({code:"PRECONDITION_FAILED",message:`Symlink for "${t.fileName}" doesn't exist.`});return{result:"success",message:s?`Symlink for "${t.fileName}" has been removed.`:`Symlink for "${t.fileName}" doesn't exist. Skipping.`}}catch(e){return{result:"error",message:`Failed to remove symlink for "${t.fileName}"`}}}},z=m.z.object({fileName:m.z.string(),path:m.z.string(),extensionName:m.z.string(),errorIfExists:m.z.boolean().optional(),errorIfNotExists:m.z.boolean().optional(),isKinematics:m.z.boolean().optional()}),I=m.z.array(z),getExtensions=()=>{let e=S.Rz.parse(process.env),t=e.RATOS_DATA_DIR,r=h().join(t,"klippy-extensions.json");(0,c.existsSync)(t)||(0,c.mkdirSync)(t),(0,c.existsSync)(r)||(0,c.writeFileSync)(r,"[]");let n=I.parse(JSON.parse((0,c.readFileSync)(r).toString()));return n},saveExtensions=e=>{let t=S.Rz.parse(process.env),r=t.RATOS_DATA_DIR,n=h().join(r,"klippy-extensions.json");(0,c.existsSync)(r)||(0,c.mkdirSync)(r),(0,c.writeFileSync)(n,JSON.stringify(e))},symlinkKlippyExtensions=async e=>{let t=S.Rz.parse(process.env),r=getExtensions();return await symlinkExtensions({extensions:r,options:{errorIfExists:e},gitRepoPath:t.KLIPPER_DIR,relativePath,saveExtensions})},relativePath=e=>e.isKinematics?"klippy/kinematics":"klippy/extras",R=(0,f.Nd)({register:f.$y.input(m.z.object({json:z})).mutation(async({input:e})=>{let t=getExtensions(),{path:r,fileName:n,errorIfExists:i,extensionName:a}=e.json,s=h().join(r,n);if(!(0,c.existsSync)(s))throw new w.TRPCError({message:`File "${s}" does not exist`,code:"PRECONDITION_FAILED"});if(t.find(t=>t.extensionName===a||t.fileName===n&&!!t.isKinematics==!!e.json.isKinematics)){if(!0===i)throw new w.TRPCError({message:`${e.json.isKinematics?"A kinematic":"An"} extension called "${a}" with fileName "${n}" is already registered`,code:"PRECONDITION_FAILED"});return(0,o.j)().warn(`${e.json.isKinematics?"A kinematic":"An"} extension called "${a}" with the fileName "${n}" is already registered, ignoring...`),!0}return t.push(e.json),saveExtensions(t),!0}),unregister:f.$y.input(m.z.object({extensionName:m.z.string(),errorIfNotExists:m.z.boolean().optional()})).mutation(async({input:e})=>{let t=getExtensions(),{extensionName:r}=e,n=t.findIndex(e=>e.extensionName===r);if(-1===n){if(!0===e.errorIfNotExists)throw new w.TRPCError({message:`Extension with the name "${r}" is not registered`,code:"PRECONDITION_FAILED"});return(0,o.j)().warn(`Extension with the name "${r}" is not registered, ignoring...`),{result:"success",message:`Extension file "${r}" does not exist. Nothing to do.`}}let i=t.splice(n,1);if(1!==i.length)throw Error("Failed to remove extension");let a=await unlinkExtension({extension:i[0],gitRepoPath:S.Rz.parse(process.env).KLIPPER_DIR,relativePath});return"success"===a.result&&saveExtensions(t),a}),symlink:f.$y.input(m.z.object({errorIfExists:m.z.boolean().optional()})).mutation(async({input:e})=>await symlinkKlippyExtensions(e.errorIfExists)),unlink:f.$y.mutation(async()=>{let e=getExtensions();return await Promise.all(e.map(async e=>{let t=await unlinkExtension({extension:e,gitRepoPath:S.Rz.parse(process.env).KLIPPER_DIR,relativePath});return t}))}),list:f.$y.output(I).query(async()=>getExtensions())}),$=m.z.object({fileName:m.z.string(),path:m.z.string(),extensionName:m.z.string(),errorIfExists:m.z.boolean().optional()}),v=m.z.array($),moonraker_extensions_getExtensions=()=>{let e=S.Rz.parse(process.env),t=e.RATOS_DATA_DIR,r=h().join(t,"moonraker-extensions.json");(0,c.existsSync)(t)||(0,c.mkdirSync)(t),(0,c.existsSync)(r)||(0,c.writeFileSync)(r,"[]");let n=v.parse(JSON.parse((0,c.readFileSync)(r).toString()));return n},moonraker_extensions_saveExtensions=e=>{let t=S.Rz.parse(process.env),r=t.RATOS_DATA_DIR,n=h().join(r,"moonraker-extensions.json");(0,c.existsSync)(r)||(0,c.mkdirSync)(r),(0,c.writeFileSync)(n,JSON.stringify(e))},symlinkMoonrakerExtensions=async e=>{let t=S.Rz.parse(process.env),r=moonraker_extensions_getExtensions();return await symlinkExtensions({extensions:r,options:{errorIfExists:e},gitRepoPath:t.MOONRAKER_DIR,relativePath:()=>"moonraker/components",saveExtensions:moonraker_extensions_saveExtensions})},A=(0,f.Nd)({register:f.$y.input(m.z.object({json:$})).mutation(async({input:e})=>{let t=moonraker_extensions_getExtensions(),{path:r,fileName:n,errorIfExists:i}=e.json,a=h().join(r,n);if(!(0,c.existsSync)(a))throw(0,o.j)().error(`File "${a}" does not exist`),new w.TRPCError({message:`File "${a}" does not exist`,code:"PRECONDITION_FAILED"});if(t.find(e=>e.fileName===n)){if(!0===i)throw(0,o.j)().error(`An extension with the fileName "${n}" is already registered`),new w.TRPCError({message:`An extension with the fileName "${n}" is already registered`,code:"PRECONDITION_FAILED"});return(0,o.j)().warn(`An extension with the fileName "${n}" is already registered, ignoring...`),!0}return t.push(e.json),moonraker_extensions_saveExtensions(t),!0}),symlink:f.$y.input(m.z.object({errorIfExists:m.z.boolean().optional()})).mutation(async({input:e})=>await symlinkMoonrakerExtensions(e.errorIfExists)),unlink:f.$y.mutation(async()=>{let e=moonraker_extensions_getExtensions(),t=S.Rz.parse(process.env);return await Promise.all(e.map(async e=>{let r=await unlinkExtension({extension:e,gitRepoPath:t.MOONRAKER_DIR,relativePath:"moonraker/components"});return r}))}),unregister:f.$y.input(m.z.object({extensionName:m.z.string(),errorIfNotExists:m.z.boolean().optional()})).mutation(async({input:e})=>{let t=S.Rz.parse(process.env),r=moonraker_extensions_getExtensions(),{extensionName:n}=e,i=r.findIndex(e=>e.extensionName===n);if(-1===i){if(!0===e.errorIfNotExists)throw new w.TRPCError({message:`Extension with the name "${n}" is not registered`,code:"PRECONDITION_FAILED"});return(0,o.j)().warn(`Extension with the name "${n}" is not registered, ignoring...`),{result:"success",message:`Extension with the name "${n}" is not registered`}}let a=r.splice(i,1);if(1!==a.length)throw Error("Failed to remove extension");let s=await unlinkExtension({extension:a[0],gitRepoPath:t.MOONRAKER_DIR,relativePath:"moonraker/components"});return"success"===s.result&&moonraker_extensions_saveExtensions(r),s}),list:f.$y.output(v).query(async()=>moonraker_extensions_getExtensions())});var N=r(43323),T=r(81358),O=r(10384),k=r(22471);let _=m.z.union([m.z.literal("time"),m.z.literal("x_acceleration"),m.z.literal("y_acceleration"),m.z.literal("z_acceleration")]);m.z.object({header:m.z.tuple([_,_,_,_])}),m.z.object({data:m.z.array(m.z.tuple([m.z.number(),m.z.number(),m.z.number(),m.z.number()])),overflows:m.z.number().optional()});let P=m.z.object({frequencies:m.z.array(m.z.number()),estimates:m.z.array(m.z.number()),powerRange:m.z.object({max:m.z.number(),min:m.z.number()})}),D=m.z.object({x:P,y:P,z:P,total:P,source:m.z.object({x:m.z.array(P),y:m.z.array(P),z:m.z.array(P),total:m.z.array(P)})}),q=m.z.string().brand("MacroID"),C=m.z.string().brand("MacroSequenceID"),F=m.z.string().brand("MacroRecordingID"),M=m.z.string().brand("MacroRecordingRunID"),L=m.z.object({capturePSD:m.z.boolean().default(!1),accelerometer:k.Yx.optional(),color:m.z.string().optional()}).superRefine((e,t)=>(e.capturePSD&&null==e.accelerometer&&t.addIssue({code:m.z.ZodIssueCode.custom,message:"Required when recording resonance data",path:["accelerometer"]}),e)),B=m.z.object({id:F,macroRecordingRunId:M,macroId:q,sequenceId:C,startTimeStamp:m.z.number(),endTimeStamp:m.z.number(),accelerometer:k.Yx,recordingHardwareName:m.z.string(),psd:D,name:m.z.string()}),K=B.extend({psd:D.omit({source:!0})}),H=m.z.object({id:C,name:m.z.string(),recording:L.nullable(),gcode:m.z.string().min(2)}),J=m.z.object({id:q,name:m.z.string(),description:m.z.string(),createdAtTimeStamp:m.z.number(),updatedAtTimeStamp:m.z.number().nullable(),recordingCount:m.z.record(C,m.z.number()),sequences:m.z.array(H)}),Z=J.omit({recordingCount:!0,createdAtTimeStamp:!0,updatedAtTimeStamp:!0}),V=require("ndjson");var W=r.n(V);/**
 * @file ndjson.ts
 * @description
 * This file contains helper functions for reading, writing, and transforming newline delimited JSON files.
 * The functions in this file are used to create object storage with common CRUD operations.
 * The object storage is used to store and manage data in a file using newline delimited JSON format.
 * The object storage can be initialized with a Zod schema to validate the objects in the storage.
 * The object storage provides common operations such as getAll, find, findById, insert, update, upsert, transform, replace, and remove.
 * The object storage also provides a destroyStorage operation to delete the storage file.
 *
 * @author Mikkel Schmidt <mikkel.schmidt@gmail.com>
 * @license MIT
 * @copyright 2024
 */let U=S.Rz.parse(process.env),G=h().join(U.RATOS_DATA_DIR,"object-storage.ndjson");m.z.object({id:m.z.coerce.string().brand()});let Y=m.z.object({id:m.z.string().brand("ObjectStorageStatsID"),total:m.z.number().default(0),lastModifiedTimeStamp:m.z.number().nullable().default(null),lastAccessedTimeStamp:m.z.number().nullable().default(null),version:m.z.number().default(0)}),_baseObjectStorage=(e,t)=>{(0,c.existsSync)(e)||((0,c.mkdirSync)(h().dirname(e),{recursive:!0}),(0,c.writeFileSync)(e,""));let getAll=async(r=0,n=1/0)=>await readObjects(e,t,r,n),find=async r=>await findObject(e,t,r),findAll=async(r,n=1/0)=>await findAllObjects(e,t,r,n),findById=async r=>await findObject(e,t,e=>e.id===("object"==typeof r?r.id:r)),insert=async r=>{let n=await findById(r);if(n)throw Error(`Object with id ${r.id} already exists`);let i=await saveObject(e,t,r);return i},update=async(r,n)=>{let i=await replaceObjects(e,t,e=>e.id===n?t.parse({...e,...r}):e);if(0===i)throw Error(`Object with id ${n} found`);return i},upsert=async(r,n=!1)=>{let i=t.parse(r),a=await replaceObjects(e,t,e=>e.id===r.id?i=t.parse({...!0===n?e:{},...r}):e);return 0===a?{updateCount:0,result:await insert(r)}:(a>1&&(0,o.j)().warn(`Upserted more than one object with id ${r.id}`),{updateCount:a,result:i})},transform=async r=>await transformObjects(e,t,r),replace=async r=>await replaceObjects(e,t,r),del=async r=>await replaceObjects(e,t,e=>r(e)?null:t.parse(e)),destroyStorage=async()=>{(0,c.existsSync)(e)&&await new Promise((t,r)=>{(0,j.unlink)(e).then(()=>{(0,o.j)().info(`Deleted object storage file: ${e}`),t()}).catch(t=>{(0,o.j)().error(`Error deleting object storage file: ${e}: ${t instanceof Error?t.message:t}`),r(t)})})};return{getAll,find,findAll,findById,insert,update,upsert,transform,replace,remove:del,destroyStorage}},logStatError=async(e,t=!1)=>{try{return await e()}catch(e){if((0,o.j)().error(`Object storage stat update error: ${e instanceof Error?e.message:e instanceof String?e:"Unknown error"}`),!t)throw e}return null},initObjectStorage=(e,t)=>{let r=_baseObjectStorage(G,Y),n=_baseObjectStorage(e,t),getAll=async(t=0,i=1/0)=>{let a=await n.getAll(t,i),s=await logStatError(()=>r.upsert({id:e,lastAccessedTimeStamp:new Date().getTime()},!0));return{...a,total:s.result.total}},find=async t=>{let i=await n.find(t);return await logStatError(()=>r.upsert({id:e,lastAccessedTimeStamp:new Date().getTime()},!0),!0),i},findById=async t=>{let i=await n.findById(t);return await logStatError(()=>r.upsert({id:e,lastAccessedTimeStamp:new Date().getTime()},!0),!0),i},findAll=async(t,i=1/0)=>{let a=await n.findAll(t,i);return await logStatError(()=>r.upsert({id:e,lastAccessedTimeStamp:new Date().getTime()},!0),!0),a},insert=async t=>{let i=await n.insert(t);return await logStatError(async()=>{let t=await r.find(t=>t.id===e);return r.upsert({id:e,lastAccessedTimeStamp:new Date().getTime(),lastModifiedTimeStamp:new Date().getTime(),total:(t?.total??0)+1},!0)}),i},update=async(t,i)=>{let a=await n.update(t,i);return await logStatError(()=>r.upsert({id:e,lastAccessedTimeStamp:new Date().getTime(),lastModifiedTimeStamp:new Date().getTime()},!0)),{updateCount:a,result:await n.findById(i)}},upsert=async t=>{let i=await n.upsert(t);return await logStatError(async()=>{let t=await r.find(t=>t.id===e);return r.upsert({id:e,lastAccessedTimeStamp:new Date().getTime(),lastModifiedTimeStamp:new Date().getTime(),total:(t?.total??0)+(0===i.updateCount?1:0)},!0)}),i},transform=async(t,i)=>{let a=await n.transform(t);return await logStatError(async()=>{let t={id:e,lastAccessedTimeStamp:new Date().getTime(),lastModifiedTimeStamp:new Date().getTime(),total:a};return null!=i&&(t.version=i),r.upsert(t,!0)}),a},replace=async t=>{let i=await n.replace(t);return await logStatError(()=>r.upsert({id:e,lastAccessedTimeStamp:new Date().getTime(),lastModifiedTimeStamp:new Date().getTime()},!0)),i},del=async t=>{let i=await n.remove(e=>e.id===t);return await logStatError(async()=>{let t=await r.find(t=>t.id===e);return r.upsert({id:e,lastAccessedTimeStamp:new Date().getTime(),lastModifiedTimeStamp:new Date().getTime(),total:(t?.total??0)-i})}),i},destroyStorage=async()=>{await n.destroyStorage();let t=(await r.findById(e))?.total??0;return await r.remove(t=>t.id===e),t};return{getAll,find,findAll,findById,insert,update,upsert,transform,replace,remove:del,destroyStorage}},readObjects=async(e,t,r=0,n=1/0)=>{if(!(0,c.existsSync)(e))return{result:[],cursor:0,hasNextPage:!1};let i=(0,c.createReadStream)(e,{encoding:"utf-8",start:r}),a=i.readableLength,s=[],l=W().parse();return i.pipe(l).on("data",function(a){try{s.push(t.parse(a)),s.length>=n&&i.destroy()}catch(t){throw t instanceof m.z.ZodError&&(0,o.j)().warn(t,`readObjects: Error parsing object from file ${e} at ${i.bytesRead+r} bytes`),t}}),l.on("error",t=>{throw(0,o.j)().error(t,`readObjects: Error reading object from file ${e} at ${i.bytesRead+r} bytes`),t}),await new Promise((e,t)=>{i.on("close",e),i.on("error",t)}),{result:s,cursor:i.bytesRead,hasNextPage:i.bytesRead<a}},findObject=async(e,t,r)=>{if(!(0,c.existsSync)(e))return null;let n=(0,c.createReadStream)(e,{encoding:"utf-8"}),i=null;return await new Promise((a,s)=>{n.pipe(W().parse()).on("data",function(a){try{let e=t.parse(a);r(e)&&(i=e,n.destroy())}catch(t){throw t instanceof m.z.ZodError&&(0,o.j)().warn(t,`findObject: Error parsing object from file ${e}`),t}}),n.on("close",a),n.on("error",s)}),i},findAllObjects=async(e,t,r,n=1/0)=>{if(!(0,c.existsSync)(e))return[];let i=(0,c.createReadStream)(e,{encoding:"utf-8"}),a=[];return await new Promise((s,c)=>{i.pipe(W().parse()).on("data",function(s){try{let e=t.parse(s);r(e)&&a.push(e),a.length>=n&&i.destroy()}catch(t){throw t instanceof m.z.ZodError&&(0,o.j)().warn(t,`findObject: Error parsing object from file ${e}`),t}}),i.on("close",s),i.on("error",c)}),a},saveObject=async(e,t,r)=>{let n=(0,c.createWriteStream)(e,{flags:"a+",encoding:"utf-8"}),i=t.parse(r);var a=W().stringify();return a.pipe(n),a.write(i),a.end(),await new Promise((e,t)=>{n.on("close",e),n.on("error",t)}),i},transformObjects=async(e,t,r)=>{if(!(0,c.existsSync)(e))throw Error("File does not exist: "+e);return await (0,u.u5)(e,(n,i)=>{try{let e=t.parse(JSON.parse(n));return JSON.stringify(r(e))}catch(t){if(t instanceof m.z.ZodError)return(0,o.j)().warn(t,`transformObjects: Error parsing line ${i} of ${e}: ${t instanceof Error?t.message:t}`),n;throw t}})},replaceObjects=async(e,t,r)=>{if(!(0,c.existsSync)(e))throw Error("File does not exist: "+e);let n=await (0,u.u5)(e,(n,i)=>{try{let e=t.parse(JSON.parse(n));return JSON.stringify(r(e))}catch(t){if(t instanceof m.z.ZodError)return(0,o.j)().warn(t,`replaceObjects: Error parsing line ${i} of ${e}: ${t instanceof Error?t.message:t}`),n;throw t}});return n},X=S.Rz.parse(process.env),Q=h().join(X.RATOS_DATA_DIR,"analysis"),ee=h().join(X.RATOS_DATA_DIR,"analysis","recordings"),et=initObjectStorage(h().join(Q,"macros.ndjson"),J),er=(0,f.Nd)({createMacro:f.$y.input(Z).mutation(async({input:e})=>await et.upsert({...e,recordingCount:{},createdAtTimeStamp:Date.now(),updatedAtTimeStamp:null})),updateMacro:f.$y.input(Z).mutation(async({input:e})=>{let t=h().join(ee,`${e}.ndjson`),r=initObjectStorage(t,B);return await r.destroyStorage(),(0,o.j)().info(`Deleted recordings for macro "${e.name}" (${e.id})`),await et.update({...e,recordingCount:{},updatedAtTimeStamp:Date.now()},e.id)}),deleteMacro:f.$y.input(q).mutation(async({input:e})=>{let t=await et.findById(e);if(null==t)throw Error(`Can't delete macro: macro with id ${e} not found`);let r=h().join(ee,`${e}.ndjson`),n=initObjectStorage(r,B),i=await n.destroyStorage();(0,o.j)().info(`Deleted recordings for macro "${t.name}" (${t.id})`);let a=await et.remove(e);return(0,o.j)().info(`Deleted macro "${t.name}" (${t.id})`),{result:"success",totalRecordingsRemoved:i,macrosRemoved:a}}),findMacro:f.$y.input(m.z.object({id:m.z.string()})).query(async({input:e})=>{let t=await et.findById(e.id);if(null==t)throw Error(`Macro with id ${e.id} not found`);return t}),getMacros:f.$y.input(m.z.object({cursor:m.z.number().default(0),limit:m.z.number().default(50)})).query(async({input:e})=>await et.getAll(e.cursor,e.limit)),saveRecording:f.$y.input(m.z.object({recording:B})).mutation(async({input:e})=>{let t=await et.findById(e.recording.macroId);if(null==t)throw Error(`Can't save recording: macro with id ${e.recording.macroId} not found`);if(!t.sequences.some(t=>t.id===e.recording.sequenceId))throw Error(`Can't save recording: sequence with id ${e.recording.sequenceId} not found in "${t.name}" macro`);let r=h().join(ee,`${e.recording.macroId}.ndjson`),n=initObjectStorage(r,B),i=await n.upsert(e.recording);return await et.update({recordingCount:{[e.recording.sequenceId]:(t.recordingCount[e.recording.sequenceId]??0)+1},updatedAtTimeStamp:Date.now()},e.recording.macroId),i}),getRecordings:f.$y.input(m.z.object({macroId:q,sequenceId:C.optional(),includeSource:m.z.boolean().default(!1),limit:m.z.number().default(50),cursor:m.z.number().default(0)})).query(async({input:e})=>{let t=h().join(ee,`${e.macroId}.ndjson`),r=initObjectStorage(t,e.includeSource?B:K),n=await r.getAll(e.cursor,e.limit);if(e.sequenceId){let t=await et.findById(e.macroId);if(null==t)throw Error(`Macro with id ${e.macroId} not found`);n.result=n.result.filter(t=>t.sequenceId===e.sequenceId),n.total=t.recordingCount[e.sequenceId]??0}return n}),getRecording:f.$y.input(m.z.object({macroId:q,recordingId:F})).output(B.nullable()).query(async({input:e})=>{let t=h().join(ee,`${e.macroId}.ndjson`),r=initObjectStorage(t,B);return await r.find(t=>t.id===e.recordingId)}),getRunRecordings:f.$y.input(m.z.object({runId:M,macroId:q})).query(async({input:e})=>{let t=h().join(ee,`${e.macroId}.ndjson`),r=initObjectStorage(t,B);return await r.findAll(t=>t.macroRecordingRunId===e.runId)})}),en=(0,f.Nd)({clientLog:f.$y.input(m.z.object({level:m.z.enum(["trace","debug","info","warn","error","fatal"]),logEvent:O.s})).mutation(async({input:e})=>{let t=(0,o.j)().child({source:"frontend"},{level:e.level});for(let r of e.logEvent.bindings)t=t.child(r);t[e.logEvent.level.label](e.logEvent.messages[0],e.logEvent.messages[1],...e.logEvent.messages.slice(2))}),version:f.$y.query(async()=>await (0,l.promisify)(d.exec)("git describe --tags --always",{cwd:process.env.RATOS_CONFIGURATION_PATH}).then(({stdout:e})=>e.trim())),klipperVersion:f.$y.query(async()=>await (0,l.promisify)(d.exec)("git describe --tags --always",{cwd:process.env.KLIPPER_DIR}).then(({stdout:e})=>e.trim())),osVersion:f.$y.query(async()=>{let e=(0,c.statSync)("/etc/ratos-release").isFile()?"/etc/ratos-release":"/etc/RatOS-release";return await (0,l.promisify)(d.exec)(`cat ${e}`).then(({stdout:e})=>e.trim().replace("RatOS ",""))}),ipAddress:f.$y.query(async()=>{let e=await getWirelessInterface(),t=null==e||""===e.trim()?"eth0":e.trim();return await (0,l.promisify)(d.exec)(`ip address | grep "${t}"`).then(({stdout:e})=>e.match(/inet\s(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/)?.[1])??"Unknown IP"}),resetCache:f.$y.mutation(async()=>(T.oA.flushAll(),{result:"success"})),kill:f.$y.query(async()=>{process.exit()}),reboot:f.$y.mutation(async()=>(setTimeout(()=>{(0,l.promisify)(d.exec)("reboot")},500),{result:"success"})),mcu:E.px,printer:N.Cu,wifi:b,"klippy-extensions":R,"moonraker-extensions":A,analysis:er}),ei=require("@trpc/server/adapters/next"),ea={api:{bodyParser:{sizeLimit:"100mb"},responseLimit:"100mb"}},es=ei.createNextApiHandler({router:en,createContext:()=>({boards:[]}),onError:e=>{(0,o.j)().error(e.error)}}),eo=(0,s.l)(n,"default"),ec=(0,s.l)(n,"config"),el=new i.PagesAPIRouteModule({definition:{kind:a.x.PAGES_API,page:"/api/trpc/[trpc]",pathname:"/api/trpc/[trpc]",bundlePath:"",filename:""},userland:n})}};var t=require("../../../webpack-api-runtime.js");t.C(e);var __webpack_exec__=e=>t(t.s=e),r=t.X(0,[1022,9953,1406],()=>__webpack_exec__(98043));module.exports=r})();