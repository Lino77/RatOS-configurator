"use strict";exports.id=8241,exports.ids=[8241],exports.modules={18241:(e,s,t)=>{t.d(s,{symlinkKlippyExtensions:()=>symlinkKlippyExtensions});var i=t(38316),n=t(56368),r=t(57147),o=t(36523),a=t(98765),l=t(71017),c=t.n(l),p=t(81115),x=t(62807);let m=i.z.object({fileName:i.z.string(),path:i.z.string(),extensionName:i.z.string(),errorIfExists:i.z.boolean().optional(),errorIfNotExists:i.z.boolean().optional(),isKinematics:i.z.boolean().optional()}),y=i.z.array(m),getExtensions=()=>{let e=p.serverSchema.parse(process.env),s=e.RATOS_DATA_DIR,t=c().join(s,"klippy-extensions.json");(0,r.existsSync)(s)||(0,r.mkdirSync)(s),(0,r.existsSync)(t)||(0,r.writeFileSync)(t,"[]");let i=y.parse(JSON.parse((0,r.readFileSync)(t).toString()));return i},saveExtensions=e=>{let s=p.serverSchema.parse(process.env),t=s.RATOS_DATA_DIR,i=c().join(t,"klippy-extensions.json");(0,r.existsSync)(t)||(0,r.mkdirSync)(t),(0,r.writeFileSync)(i,JSON.stringify(e))},symlinkKlippyExtensions=async e=>{let s=p.serverSchema.parse(process.env),t=getExtensions();return await (0,x.b)({extensions:t,options:{errorIfExists:e},gitRepoPath:s.KLIPPER_DIR,relativePath,saveExtensions})},relativePath=e=>e.isKinematics?"klippy/kinematics":"klippy/extras";(0,a.Nd)({register:a.$y.input(i.z.object({json:m})).mutation(async({input:e})=>{let s=getExtensions(),{path:t,fileName:i,errorIfExists:a,extensionName:l}=e.json,p=c().join(t,i);if(!(0,r.existsSync)(p))throw new n.TRPCError({message:`File "${p}" does not exist`,code:"PRECONDITION_FAILED"});if(s.find(s=>s.extensionName===l||s.fileName===i&&!!s.isKinematics==!!e.json.isKinematics)){if(!0===a)throw new n.TRPCError({message:`${e.json.isKinematics?"A kinematic":"An"} extension called "${l}" with fileName "${i}" is already registered`,code:"PRECONDITION_FAILED"});return(0,o.getLogger)().warn(`${e.json.isKinematics?"A kinematic":"An"} extension called "${l}" with the fileName "${i}" is already registered, ignoring...`),!0}return s.push(e.json),saveExtensions(s),!0}),unregister:a.$y.input(i.z.object({extensionName:i.z.string(),errorIfNotExists:i.z.boolean().optional()})).mutation(async({input:e})=>{let s=getExtensions(),{extensionName:t}=e,i=s.findIndex(e=>e.extensionName===t);if(-1===i){if(!0===e.errorIfNotExists)throw new n.TRPCError({message:`Extension with the name "${t}" is not registered`,code:"PRECONDITION_FAILED"});return(0,o.getLogger)().warn(`Extension with the name "${t}" is not registered, ignoring...`),{result:"success",message:`Extension file "${t}" does not exist. Nothing to do.`}}let r=s.splice(i,1);if(1!==r.length)throw Error("Failed to remove extension");let a=await (0,x.Y)({extension:r[0],gitRepoPath:p.serverSchema.parse(process.env).KLIPPER_DIR,relativePath});return"success"===a.result&&saveExtensions(s),a}),symlink:a.$y.input(i.z.object({errorIfExists:i.z.boolean().optional()})).mutation(async({input:e})=>await symlinkKlippyExtensions(e.errorIfExists)),unlink:a.$y.mutation(async()=>{let e=getExtensions();return await Promise.all(e.map(async e=>{let s=await (0,x.Y)({extension:e,gitRepoPath:p.serverSchema.parse(process.env).KLIPPER_DIR,relativePath});return s}))}),list:a.$y.output(y).query(async()=>getExtensions())})}};